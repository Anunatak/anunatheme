(function ($) {

				if (!$.fn.watch && !$.fn.unwatch) {

								/**
         * Watches an element for a change in a property
         * @param  {string}   id The property to watch
         * @param  {Function} fn The function to execute when something has changed
         */
								$.fn.watch = function (id, fn) {

												return this.each(function () {

																var self = this;

																var oldVal = self[id];
																$(self).data('watch_timer', setInterval(function () {
																				if (self[id] !== oldVal) {
																								fn.call(self, id, oldVal, self[id]);
																								oldVal = self[id];
																				}
																}, 100));
												});
								};

								/**
         * Unwatches an element
         */
								$.fn.unwatch = function () {

												return this.each(function () {
																clearInterval($(this).data('watch_timer'));
												});
								};
				}

				if (!$.DOMRouter) {
								$.DOMRouter = {
												router: function router(el, routes) {
																var base = this;
																base.$el = $(el);
																base.el = el;
																base.$el.data('DOMRouter.router', base);

																base.element = base.$el.find($.DOMRouter.defaults.element);

																base.element.addClass('dom-router-ready');

																/**
                 * Initalize the functions
                 * @return {void}
                 */
																base.init = function () {
																				base.routes = routes;
																				$(document).ready(base.load);

																				base.executed = [];

																				base.element.watch('className', function (property, oldClasses, newClasses) {
																								var classes = newClasses.replace(/-/g, '_').split(/\s+/);

																								$.each(classes, function (i, className) {
																												if (!base.routeExecuted(className)) {
																																base.fire(className);
																																base.executed.push(className);
																												}
																								});
																				});
																};

																/**
                 * Checks if a route has been executed already
                 * @param  {string} 	route        [description]
                 * @return {boolean}
                 */
																base.routeExecuted = function (route) {
																				return base.executed.indexOf(route) > -1;
																};

																/**
                 * Gets the classes on the body element
                 * @return {array}
                 */
																base.classes = function () {
																				return base.element.get(0).className.replace(/-/g, '_').split(/\s+/);
																};

																/**
                 * Load all events to be fired
                 * @return {void}
                 */
																base.load = function () {
																				base.fire('common');
																				$.each(base.classes(), function (i, className) {
																								base.fire(className);
																								base.executed.push(className);
																				});
																};

																/**
                 * Fire an event
                 * @param  {Function} func The function to be fired
                 * @param  {Array} args Arguments
                 * @return {Void}
                 */
																base.fire = function (func, args) {
																				var fire,
																				    routes = base.routes;

																				fire = func !== '';
																				fire = fire && routes[func];
																				fire = fire && typeof routes[func] === 'function';

																				if (fire) {
																								routes[func](args);
																				}
																};

																// Run initializer
																base.init();
												},
												defaults: {
																element: 'body'
												}
								};
				}

				$.fn.router = function (routes) {
								return this.each(function () {
												new $.DOMRouter.router(this, routes);
								});
				};

				if (typeof module !== 'undefined' && module.exports) {
								module.exports = $.DOMRouter.router;
				}
})(jQuery);

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};





var asyncGenerator = function () {
  function AwaitValue(value) {
    this.value = value;
  }

  function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg);
        var value = result.value;

        if (value instanceof AwaitValue) {
          Promise.resolve(value.value).then(function (arg) {
            resume("next", arg);
          }, function (arg) {
            resume("throw", arg);
          });
        } else {
          settle(result.done ? "return" : "normal", result.value);
        }
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({
            value: value,
            done: true
          });
          break;

        case "throw":
          front.reject(value);
          break;

        default:
          front.resolve({
            value: value,
            done: false
          });
          break;
      }

      front = front.next;

      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  if (typeof Symbol === "function" && Symbol.asyncIterator) {
    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
      return this;
    };
  }

  AsyncGenerator.prototype.next = function (arg) {
    return this._invoke("next", arg);
  };

  AsyncGenerator.prototype.throw = function (arg) {
    return this._invoke("throw", arg);
  };

  AsyncGenerator.prototype.return = function (arg) {
    return this._invoke("return", arg);
  };

  return {
    wrap: function (fn) {
      return function () {
        return new AsyncGenerator(fn.apply(this, arguments));
      };
    },
    await: function (value) {
      return new AwaitValue(value);
    }
  };
}();





var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();







var get$1 = function get$1(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent === null) {
      return undefined;
    } else {
      return get$1(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};

















var set = function set(object, property, value, receiver) {
  var desc = Object.getOwnPropertyDescriptor(object, property);

  if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);

    if (parent !== null) {
      set(parent, property, value, receiver);
    }
  } else if ("value" in desc && desc.writable) {
    desc.value = value;
  } else {
    var setter = desc.set;

    if (setter !== undefined) {
      setter.call(receiver, value);
    }
  }

  return value;
};

!function($){"use strict";var FOUNDATION_VERSION='6.2.3';// Global Foundation object
// This is attached to the window, or used as a module for AMD/Browserify
var Foundation={version:FOUNDATION_VERSION,/**
     * Stores initialized plugins.
     */_plugins:{},/**
     * Stores generated unique ids for plugin instances
     */_uuids:[],/**
     * Returns a boolean for RTL support
     */rtl:function rtl(){return $('html').attr('dir')==='rtl';},/**
     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
     * @param {Object} plugin - The constructor of the plugin.
     */plugin:function plugin(_plugin,name){// Object key to use when adding to global Foundation object
// Examples: Foundation.Reveal, Foundation.OffCanvas
var className=name||functionName(_plugin);// Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
// Examples: data-reveal, data-off-canvas
var attrName=hyphenate(className);// Add to the Foundation object and the plugins list (for reflowing)
this._plugins[attrName]=this[className]=_plugin;},/**
     * @function
     * Populates the _uuids array with pointers to each individual plugin instance.
     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
     * Also fires the initialization event for each plugin, consolidating repetitive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @param {String} name - the name of the plugin, passed as a camelCased string.
     * @fires Plugin#init
     */registerPlugin:function registerPlugin(plugin,name){var pluginName=name?hyphenate(name):functionName(plugin.constructor).toLowerCase();plugin.uuid=this.GetYoDigits(6,pluginName);if(!plugin.$element.attr('data-'+pluginName)){plugin.$element.attr('data-'+pluginName,plugin.uuid);}if(!plugin.$element.data('zfPlugin')){plugin.$element.data('zfPlugin',plugin);}/**
       * Fires when the plugin has initialized.
       * @event Plugin#init
       */plugin.$element.trigger('init.zf.'+pluginName);this._uuids.push(plugin.uuid);return;},/**
     * @function
     * Removes the plugins uuid from the _uuids array.
     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
     * Also fires the destroyed event for the plugin, consolidating repetitive code.
     * @param {Object} plugin - an instance of a plugin, usually `this` in context.
     * @fires Plugin#destroyed
     */unregisterPlugin:function unregisterPlugin(plugin){var pluginName=hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));this._uuids.splice(this._uuids.indexOf(plugin.uuid),1);plugin.$element.removeAttr('data-'+pluginName).removeData('zfPlugin')/**
       * Fires when the plugin has been destroyed.
       * @event Plugin#destroyed
       */.trigger('destroyed.zf.'+pluginName);for(var prop in plugin){plugin[prop]=null;//clean up script to prep for garbage collection.
}return;},/**
     * @function
     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
     * @default If no argument is passed, reflow all currently active plugins.
     */reInit:function reInit(plugins){var isJQ=plugins instanceof $;try{if(isJQ){plugins.each(function(){$(this).data('zfPlugin')._init();});}else{var type=typeof plugins==='undefined'?'undefined':_typeof(plugins),_this=this,fns={'object':function object(plgs){plgs.forEach(function(p){p=hyphenate(p);$('[data-'+p+']').foundation('_init');});},'string':function string(){plugins=hyphenate(plugins);$('[data-'+plugins+']').foundation('_init');},'undefined':function undefined(){this['object'](Object.keys(_this._plugins));}};fns[type](plugins);}}catch(err){console.error(err);}finally{return plugins;}},/**
     * returns a random base-36 uid with namespacing
     * @function
     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
     * @param {String} namespace - name of plugin to be incorporated in uid, optional.
     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
     * @returns {String} - unique id
     */GetYoDigits:function GetYoDigits(length,namespace){length=length||6;return Math.round(Math.pow(36,length+1)-Math.random()*Math.pow(36,length)).toString(36).slice(1)+(namespace?'-'+namespace:'');},/**
     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
     */reflow:function reflow(elem,plugins){// If plugins is undefined, just grab everything
if(typeof plugins==='undefined'){plugins=Object.keys(this._plugins);}// If plugins is a string, convert it to an array with one item
else if(typeof plugins==='string'){plugins=[plugins];}var _this=this;// Iterate through each plugin
$.each(plugins,function(i,name){// Get the current plugin
var plugin=_this._plugins[name];// Localize the search to all elements inside elem, as well as elem itself, unless elem === document
var $elem=$(elem).find('[data-'+name+']').addBack('[data-'+name+']');// For each plugin found, initialize it
$elem.each(function(){var $el=$(this),opts={};// Don't double-dip on plugins
if($el.data('zfPlugin')){console.warn("Tried to initialize "+name+" on an element that already has a Foundation plugin.");return;}if($el.attr('data-options')){var thing=$el.attr('data-options').split(';').forEach(function(e,i){var opt=e.split(':').map(function(el){return el.trim();});if(opt[0])opts[opt[0]]=parseValue(opt[1]);});}try{$el.data('zfPlugin',new plugin($(this),opts));}catch(er){console.error(er);}finally{return;}});});},getFnName:functionName,transitionend:function transitionend($elem){var transitions={'transition':'transitionend','WebkitTransition':'webkitTransitionEnd','MozTransition':'transitionend','OTransition':'otransitionend'};var elem=document.createElement('div'),end;for(var t in transitions){if(typeof elem.style[t]!=='undefined'){end=transitions[t];}}if(end){return end;}else{end=setTimeout(function(){$elem.triggerHandler('transitionend',[$elem]);},1);return'transitionend';}}};Foundation.util={/**
     * Function for applying a debounce effect to a function call.
     * @function
     * @param {Function} func - Function to be called at end of timeout.
     * @param {Number} delay - Time in ms to delay the call of `func`.
     * @returns function
     */throttle:function throttle(func,delay){var timer=null;return function(){var context=this,args=arguments;if(timer===null){timer=setTimeout(function(){func.apply(context,args);timer=null;},delay);}};}};// TODO: consider not making this a jQuery function
// TODO: need way to reflow vs. re-initialize
/**
   * The Foundation jQuery method.
   * @param {String|Array} method - An action to perform on the current jQuery object.
   */var foundation=function foundation(method){var type=typeof method==='undefined'?'undefined':_typeof(method),$meta=$('meta.foundation-mq'),$noJS=$('.no-js');if(!$meta.length){$('<meta class="foundation-mq">').appendTo(document.head);}if($noJS.length){$noJS.removeClass('no-js');}if(type==='undefined'){//needs to initialize the Foundation object, or an individual plugin.
Foundation.MediaQuery._init();Foundation.reflow(this);}else if(type==='string'){//an individual method to invoke on a plugin or group of plugins
var args=Array.prototype.slice.call(arguments,1);//collect all the arguments, if necessary
var plugClass=this.data('zfPlugin');//determine the class of plugin
if(plugClass!==undefined&&plugClass[method]!==undefined){//make sure both the class and method exist
if(this.length===1){//if there's only one, call it directly.
plugClass[method].apply(plugClass,args);}else{this.each(function(i,el){//otherwise loop through the jQuery collection and invoke the method on each
plugClass[method].apply($(el).data('zfPlugin'),args);});}}else{//error for no class or no method
throw new ReferenceError("We're sorry, '"+method+"' is not an available method for "+(plugClass?functionName(plugClass):'this element')+'.');}}else{//error for invalid argument type
throw new TypeError('We\'re sorry, '+type+' is not a valid parameter. You must use a string representing the method you wish to invoke.');}return this;};window.Foundation=Foundation;$.fn.foundation=foundation;// Polyfill for requestAnimationFrame
(function(){if(!Date.now||!window.Date.now)window.Date.now=Date.now=function(){return new Date().getTime();};var vendors=['webkit','moz'];for(var i=0;i<vendors.length&&!window.requestAnimationFrame;++i){var vp=vendors[i];window.requestAnimationFrame=window[vp+'RequestAnimationFrame'];window.cancelAnimationFrame=window[vp+'CancelAnimationFrame']||window[vp+'CancelRequestAnimationFrame'];}if(/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent)||!window.requestAnimationFrame||!window.cancelAnimationFrame){var lastTime=0;window.requestAnimationFrame=function(callback){var now=Date.now();var nextTime=Math.max(lastTime+16,now);return setTimeout(function(){callback(lastTime=nextTime);},nextTime-now);};window.cancelAnimationFrame=clearTimeout;}/**
     * Polyfill for performance.now, required by rAF
     */if(!window.performance||!window.performance.now){window.performance={start:Date.now(),now:function now(){return Date.now()-this.start;}};}})();if(!Function.prototype.bind){Function.prototype.bind=function(oThis){if(typeof this!=='function'){// closest thing possible to the ECMAScript 5
// internal IsCallable function
throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');}var aArgs=Array.prototype.slice.call(arguments,1),fToBind=this,fNOP=function fNOP(){},fBound=function fBound(){return fToBind.apply(this instanceof fNOP?this:oThis,aArgs.concat(Array.prototype.slice.call(arguments)));};if(this.prototype){// native functions don't have a prototype
fNOP.prototype=this.prototype;}fBound.prototype=new fNOP();return fBound;};}// Polyfill to get the name of a function in IE9
function functionName(fn){if(Function.prototype.name===undefined){var funcNameRegex=/function\s([^(]{1,})\(/;var results=funcNameRegex.exec(fn.toString());return results&&results.length>1?results[1].trim():"";}else if(fn.prototype===undefined){return fn.constructor.name;}else{return fn.prototype.constructor.name;}}function parseValue(str){if(/true/.test(str))return true;else if(/false/.test(str))return false;else if(!isNaN(str*1))return parseFloat(str);return str;}// Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580
function hyphenate(str){return str.replace(/([a-z])([A-Z])/g,'$1-$2').toLowerCase();}}(jQuery);!function($){Foundation.Box={ImNotTouchingYou:ImNotTouchingYou,GetDimensions:GetDimensions,GetOffsets:GetOffsets};/**
   * Compares the dimensions of an element to a container and determines collision events with container.
   * @function
   * @param {jQuery} element - jQuery object to test for collisions.
   * @param {jQuery} parent - jQuery object to use as bounding container.
   * @param {Boolean} lrOnly - set to true to check left and right values only.
   * @param {Boolean} tbOnly - set to true to check top and bottom values only.
   * @default if no parent object passed, detects collisions with `window`.
   * @returns {Boolean} - true if collision free, false if a collision in any direction.
   */function ImNotTouchingYou(element,parent,lrOnly,tbOnly){var eleDims=GetDimensions(element),top,bottom,left,right;if(parent){var parDims=GetDimensions(parent);bottom=eleDims.offset.top+eleDims.height<=parDims.height+parDims.offset.top;top=eleDims.offset.top>=parDims.offset.top;left=eleDims.offset.left>=parDims.offset.left;right=eleDims.offset.left+eleDims.width<=parDims.width+parDims.offset.left;}else{bottom=eleDims.offset.top+eleDims.height<=eleDims.windowDims.height+eleDims.windowDims.offset.top;top=eleDims.offset.top>=eleDims.windowDims.offset.top;left=eleDims.offset.left>=eleDims.windowDims.offset.left;right=eleDims.offset.left+eleDims.width<=eleDims.windowDims.width;}var allDirs=[bottom,top,left,right];if(lrOnly){return left===right===true;}if(tbOnly){return top===bottom===true;}return allDirs.indexOf(false)===-1;}/**
   * Uses native methods to return an object of dimension values.
   * @function
   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
   * @returns {Object} - nested object of integer pixel values
   * TODO - if element is window, return only those values.
   */function GetDimensions(elem,test){elem=elem.length?elem[0]:elem;if(elem===window||elem===document){throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");}var rect=elem.getBoundingClientRect(),parRect=elem.parentNode.getBoundingClientRect(),winRect=document.body.getBoundingClientRect(),winY=window.pageYOffset,winX=window.pageXOffset;return{width:rect.width,height:rect.height,offset:{top:rect.top+winY,left:rect.left+winX},parentDims:{width:parRect.width,height:parRect.height,offset:{top:parRect.top+winY,left:parRect.left+winX}},windowDims:{width:winRect.width,height:winRect.height,offset:{top:winY,left:winX}}};}/**
   * Returns an object of top and left integer pixel values for dynamically rendered elements,
   * such as: Tooltip, Reveal, and Dropdown
   * @function
   * @param {jQuery} element - jQuery object for the element being positioned.
   * @param {jQuery} anchor - jQuery object for the element's anchor point.
   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
   * TODO alter/rewrite to work with `em` values as well/instead of pixels
   */function GetOffsets(element,anchor,position,vOffset,hOffset,isOverflow){var $eleDims=GetDimensions(element),$anchorDims=anchor?GetDimensions(anchor):null;switch(position){case'top':return{left:Foundation.rtl()?$anchorDims.offset.left-$eleDims.width+$anchorDims.width:$anchorDims.offset.left,top:$anchorDims.offset.top-($eleDims.height+vOffset)};break;case'left':return{left:$anchorDims.offset.left-($eleDims.width+hOffset),top:$anchorDims.offset.top};break;case'right':return{left:$anchorDims.offset.left+$anchorDims.width+hOffset,top:$anchorDims.offset.top};break;case'center top':return{left:$anchorDims.offset.left+$anchorDims.width/2-$eleDims.width/2,top:$anchorDims.offset.top-($eleDims.height+vOffset)};break;case'center bottom':return{left:isOverflow?hOffset:$anchorDims.offset.left+$anchorDims.width/2-$eleDims.width/2,top:$anchorDims.offset.top+$anchorDims.height+vOffset};break;case'center left':return{left:$anchorDims.offset.left-($eleDims.width+hOffset),top:$anchorDims.offset.top+$anchorDims.height/2-$eleDims.height/2};break;case'center right':return{left:$anchorDims.offset.left+$anchorDims.width+hOffset+1,top:$anchorDims.offset.top+$anchorDims.height/2-$eleDims.height/2};break;case'center':return{left:$eleDims.windowDims.offset.left+$eleDims.windowDims.width/2-$eleDims.width/2,top:$eleDims.windowDims.offset.top+$eleDims.windowDims.height/2-$eleDims.height/2};break;case'reveal':return{left:($eleDims.windowDims.width-$eleDims.width)/2,top:$eleDims.windowDims.offset.top+vOffset};case'reveal full':return{left:$eleDims.windowDims.offset.left,top:$eleDims.windowDims.offset.top};break;case'left bottom':return{left:$anchorDims.offset.left-($eleDims.width+hOffset),top:$anchorDims.offset.top+$anchorDims.height};break;case'right bottom':return{left:$anchorDims.offset.left+$anchorDims.width+hOffset-$eleDims.width,top:$anchorDims.offset.top+$anchorDims.height};break;default:return{left:Foundation.rtl()?$anchorDims.offset.left-$eleDims.width+$anchorDims.width:$anchorDims.offset.left,top:$anchorDims.offset.top+$anchorDims.height+vOffset};}}}(jQuery);/*******************************************
 *                                         *
 * This util was created by Marius Olbertz *
 * Please thank Marius on GitHub /owlbertz *
 * or the web http://www.mariusolbertz.de/ *
 *                                         *
 ******************************************/!function($){var keyCodes={9:'TAB',13:'ENTER',27:'ESCAPE',32:'SPACE',37:'ARROW_LEFT',38:'ARROW_UP',39:'ARROW_RIGHT',40:'ARROW_DOWN'};var commands={};var Keyboard={keys:getKeyCodes(keyCodes),/**
     * Parses the (keyboard) event and returns a String that represents its key
     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
     * @param {Event} event - the event generated by the event handler
     * @return String key - String that represents the key pressed
     */parseKey:function parseKey(event){var key=keyCodes[event.which||event.keyCode]||String.fromCharCode(event.which).toUpperCase();if(event.shiftKey)key='SHIFT_'+key;if(event.ctrlKey)key='CTRL_'+key;if(event.altKey)key='ALT_'+key;return key;},/**
     * Handles the given (keyboard) event
     * @param {Event} event - the event generated by the event handler
     * @param {String} component - Foundation component's name, e.g. Slider or Reveal
     * @param {Objects} functions - collection of functions that are to be executed
     */handleKey:function handleKey(event,component,functions){var commandList=commands[component],keyCode=this.parseKey(event),cmds,command,fn;if(!commandList)return console.warn('Component not defined!');if(typeof commandList.ltr==='undefined'){// this component does not differentiate between ltr and rtl
cmds=commandList;// use plain list
}else{// merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
if(Foundation.rtl())cmds=$.extend({},commandList.ltr,commandList.rtl);else cmds=$.extend({},commandList.rtl,commandList.ltr);}command=cmds[keyCode];fn=functions[command];if(fn&&typeof fn==='function'){// execute function  if exists
var returnValue=fn.apply();if(functions.handled||typeof functions.handled==='function'){// execute function when event was handled
functions.handled(returnValue);}}else{if(functions.unhandled||typeof functions.unhandled==='function'){// execute function when event was not handled
functions.unhandled();}}},/**
     * Finds all focusable elements within the given `$element`
     * @param {jQuery} $element - jQuery object to search within
     * @return {jQuery} $focusable - all focusable elements within `$element`
     */findFocusable:function findFocusable($element){return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function(){if(!$(this).is(':visible')||$(this).attr('tabindex')<0){return false;}//only have visible elements and those that have a tabindex greater or equal 0
return true;});},/**
     * Returns the component name name
     * @param {Object} component - Foundation component, e.g. Slider or Reveal
     * @return String componentName
     */register:function register(componentName,cmds){commands[componentName]=cmds;}};/*
   * Constants for easier comparing.
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   */function getKeyCodes(kcs){var k={};for(var kc in kcs){k[kcs[kc]]=kcs[kc];}return k;}Foundation.Keyboard=Keyboard;}(jQuery);!function($){// Default set of media queries
var defaultQueries={'default':'only screen',landscape:'only screen and (orientation: landscape)',portrait:'only screen and (orientation: portrait)',retina:'only screen and (-webkit-min-device-pixel-ratio: 2),'+'only screen and (min--moz-device-pixel-ratio: 2),'+'only screen and (-o-min-device-pixel-ratio: 2/1),'+'only screen and (min-device-pixel-ratio: 2),'+'only screen and (min-resolution: 192dpi),'+'only screen and (min-resolution: 2dppx)'};var MediaQuery={queries:[],current:'',/**
     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
     * @function
     * @private
     */_init:function _init(){var self=this;var extractedStyles=$('.foundation-mq').css('font-family');var namedQueries;namedQueries=parseStyleToObject(extractedStyles);for(var key in namedQueries){if(namedQueries.hasOwnProperty(key)){self.queries.push({name:key,value:'only screen and (min-width: '+namedQueries[key]+')'});}}this.current=this._getCurrentSize();this._watcher();},/**
     * Checks if the screen is at least as wide as a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to check.
     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
     */atLeast:function atLeast(size){var query=this.get(size);if(query){return window.matchMedia(query).matches;}return false;},/**
     * Gets the media query of a breakpoint.
     * @function
     * @param {String} size - Name of the breakpoint to get.
     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
     */get:function get(size){for(var i in this.queries){if(this.queries.hasOwnProperty(i)){var query=this.queries[i];if(size===query.name)return query.value;}}return null;},/**
     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
     * @function
     * @private
     * @returns {String} Name of the current breakpoint.
     */_getCurrentSize:function _getCurrentSize(){var matched;for(var i=0;i<this.queries.length;i++){var query=this.queries[i];if(window.matchMedia(query.value).matches){matched=query;}}if((typeof matched==='undefined'?'undefined':_typeof(matched))==='object'){return matched.name;}else{return matched;}},/**
     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
     * @function
     * @private
     */_watcher:function _watcher(){var _this=this;$(window).on('resize.zf.mediaquery',function(){var newSize=_this._getCurrentSize(),currentSize=_this.current;if(newSize!==currentSize){// Change the current media query
_this.current=newSize;// Broadcast the media query change on the window
$(window).trigger('changed.zf.mediaquery',[newSize,currentSize]);}});}};Foundation.MediaQuery=MediaQuery;// matchMedia() polyfill - Test a CSS media type/query in JS.
// Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
window.matchMedia||(window.matchMedia=function(){'use strict';// For browsers that support matchMedium api such as IE 9 and webkit
var styleMedia=window.styleMedia||window.media;// For those that don't support matchMedium
if(!styleMedia){var style=document.createElement('style'),script=document.getElementsByTagName('script')[0],info=null;style.type='text/css';style.id='matchmediajs-test';script.parentNode.insertBefore(style,script);// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
info='getComputedStyle'in window&&window.getComputedStyle(style,null)||style.currentStyle;styleMedia={matchMedium:function matchMedium(media){var text='@media '+media+'{ #matchmediajs-test { width: 1px; } }';// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
if(style.styleSheet){style.styleSheet.cssText=text;}else{style.textContent=text;}// Test if media query is true or false
return info.width==='1px';}};}return function(media){return{matches:styleMedia.matchMedium(media||'all'),media:media||'all'};};}());// Thank you: https://github.com/sindresorhus/query-string
function parseStyleToObject(str){var styleObject={};if(typeof str!=='string'){return styleObject;}str=str.trim().slice(1,-1);// browsers re-quote string style values
if(!str){return styleObject;}styleObject=str.split('&').reduce(function(ret,param){var parts=param.replace(/\+/g,' ').split('=');var key=parts[0];var val=parts[1];key=decodeURIComponent(key);// missing `=` should be `null`:
// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
val=val===undefined?null:decodeURIComponent(val);if(!ret.hasOwnProperty(key)){ret[key]=val;}else if(Array.isArray(ret[key])){ret[key].push(val);}else{ret[key]=[ret[key],val];}return ret;},{});return styleObject;}Foundation.MediaQuery=MediaQuery;}(jQuery);!function($){/**
   * Motion module.
   * @module foundation.motion
   */var initClasses=['mui-enter','mui-leave'];var activeClasses=['mui-enter-active','mui-leave-active'];var Motion={animateIn:function animateIn(element,animation,cb){animate(true,element,animation,cb);},animateOut:function animateOut(element,animation,cb){animate(false,element,animation,cb);}};function Move(duration,elem,fn){var anim,prog,start=null;// console.log('called');
function move(ts){if(!start)start=window.performance.now();// console.log(start, ts);
prog=ts-start;fn.apply(elem);if(prog<duration){anim=window.requestAnimationFrame(move,elem);}else{window.cancelAnimationFrame(anim);elem.trigger('finished.zf.animate',[elem]).triggerHandler('finished.zf.animate',[elem]);}}anim=window.requestAnimationFrame(move);}/**
   * Animates an element in or out using a CSS transition class.
   * @function
   * @private
   * @param {Boolean} isIn - Defines if the animation is in or out.
   * @param {Object} element - jQuery or HTML object to animate.
   * @param {String} animation - CSS class to use.
   * @param {Function} cb - Callback to run when animation is finished.
   */function animate(isIn,element,animation,cb){element=$(element).eq(0);if(!element.length)return;var initClass=isIn?initClasses[0]:initClasses[1];var activeClass=isIn?activeClasses[0]:activeClasses[1];// Set up the animation
reset();element.addClass(animation).css('transition','none');requestAnimationFrame(function(){element.addClass(initClass);if(isIn)element.show();});// Start the animation
requestAnimationFrame(function(){element[0].offsetWidth;element.css('transition','').addClass(activeClass);});// Clean up the animation when it finishes
element.one(Foundation.transitionend(element),finish);// Hides the element (for out animations), resets the element, and runs a callback
function finish(){if(!isIn)element.hide();reset();if(cb)cb.apply(element);}// Resets transitions and removes motion-specific classes
function reset(){element[0].style.transitionDuration=0;element.removeClass(initClass+' '+activeClass+' '+animation);}}Foundation.Move=Move;Foundation.Motion=Motion;}(jQuery);!function($){var Nest={Feather:function Feather(menu){var type=arguments.length<=1||arguments[1]===undefined?'zf':arguments[1];menu.attr('role','menubar');var items=menu.find('li').attr({'role':'menuitem'}),subMenuClass='is-'+type+'-submenu',subItemClass=subMenuClass+'-item',hasSubClass='is-'+type+'-submenu-parent';menu.find('a:first').attr('tabindex',0);items.each(function(){var $item=$(this),$sub=$item.children('ul');if($sub.length){$item.addClass(hasSubClass).attr({'aria-haspopup':true,'aria-expanded':false,'aria-label':$item.children('a:first').text()});$sub.addClass('submenu '+subMenuClass).attr({'data-submenu':'','aria-hidden':true,'role':'menu'});}if($item.parent('[data-submenu]').length){$item.addClass('is-submenu-item '+subItemClass);}});return;},Burn:function Burn(menu,type){var items=menu.find('li').removeAttr('tabindex'),subMenuClass='is-'+type+'-submenu',subItemClass=subMenuClass+'-item',hasSubClass='is-'+type+'-submenu-parent';menu.find('*').removeClass(subMenuClass+' '+subItemClass+' '+hasSubClass+' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display','');// console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
//           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
//           .removeAttr('data-submenu'));
// items.each(function(){
//   var $item = $(this),
//       $sub = $item.children('ul');
//   if($item.parent('[data-submenu]').length){
//     $item.removeClass('is-submenu-item ' + subItemClass);
//   }
//   if($sub.length){
//     $item.removeClass('has-submenu');
//     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
//   }
// });
}};Foundation.Nest=Nest;}(jQuery);!function($){function Timer(elem,options,cb){var _this=this,duration=options.duration,//options is an object for easily adding features later.
nameSpace=Object.keys(elem.data())[0]||'timer',remain=-1,start,timer;this.isPaused=false;this.restart=function(){remain=-1;clearTimeout(timer);this.start();};this.start=function(){this.isPaused=false;// if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
clearTimeout(timer);remain=remain<=0?duration:remain;elem.data('paused',false);start=Date.now();timer=setTimeout(function(){if(options.infinite){_this.restart();//rerun the timer.
}cb();},remain);elem.trigger('timerstart.zf.'+nameSpace);};this.pause=function(){this.isPaused=true;//if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
clearTimeout(timer);elem.data('paused',true);var end=Date.now();remain=remain-(end-start);elem.trigger('timerpaused.zf.'+nameSpace);};}/**
   * Runs a callback function when images are fully loaded.
   * @param {Object} images - Image(s) to check if loaded.
   * @param {Func} callback - Function to execute when image is fully loaded.
   */function onImagesLoaded(images,callback){var self=this,unloaded=images.length;if(unloaded===0){callback();}images.each(function(){if(this.complete){singleImageLoaded();}else if(typeof this.naturalWidth!=='undefined'&&this.naturalWidth>0){singleImageLoaded();}else{$(this).one('load',function(){singleImageLoaded();});}});function singleImageLoaded(){unloaded--;if(unloaded===0){callback();}}}Foundation.Timer=Timer;Foundation.onImagesLoaded=onImagesLoaded;}(jQuery);//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function($){$.spotSwipe={version:'1.0.0',enabled:'ontouchstart'in document.documentElement,preventDefault:false,moveThreshold:75,timeThreshold:200};var startPosX,startPosY,startTime,elapsedTime,isMoving=false;function onTouchEnd(){//  alert(this);
this.removeEventListener('touchmove',onTouchMove);this.removeEventListener('touchend',onTouchEnd);isMoving=false;}function onTouchMove(e){if($.spotSwipe.preventDefault){e.preventDefault();}if(isMoving){var x=e.touches[0].pageX;var y=e.touches[0].pageY;var dx=startPosX-x;var dy=startPosY-y;var dir;elapsedTime=new Date().getTime()-startTime;if(Math.abs(dx)>=$.spotSwipe.moveThreshold&&elapsedTime<=$.spotSwipe.timeThreshold){dir=dx>0?'left':'right';}// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
//   dir = dy > 0 ? 'down' : 'up';
// }
if(dir){e.preventDefault();onTouchEnd.call(this);$(this).trigger('swipe',dir).trigger('swipe'+dir);}}}function onTouchStart(e){if(e.touches.length==1){startPosX=e.touches[0].pageX;startPosY=e.touches[0].pageY;isMoving=true;startTime=new Date().getTime();this.addEventListener('touchmove',onTouchMove,false);this.addEventListener('touchend',onTouchEnd,false);}}function init(){this.addEventListener&&this.addEventListener('touchstart',onTouchStart,false);}function teardown(){this.removeEventListener('touchstart',onTouchStart);}$.event.special.swipe={setup:init};$.each(['left','up','down','right'],function(){$.event.special['swipe'+this]={setup:function setup(){$(this).on('swipe',$.noop);}};});})(jQuery);/****************************************************
 * Method for adding psuedo drag events to elements *
 ***************************************************/!function($){$.fn.addTouch=function(){this.each(function(i,el){$(el).bind('touchstart touchmove touchend touchcancel',function(){//we pass the original event object because the jQuery event
//object is normalized to w3c specs and does not provide the TouchList
handleTouch(event);});});var handleTouch=function handleTouch(event){var touches=event.changedTouches,first=touches[0],eventTypes={touchstart:'mousedown',touchmove:'mousemove',touchend:'mouseup'},type=eventTypes[event.type],simulatedEvent;if('MouseEvent'in window&&typeof window.MouseEvent==='function'){simulatedEvent=new window.MouseEvent(type,{'bubbles':true,'cancelable':true,'screenX':first.screenX,'screenY':first.screenY,'clientX':first.clientX,'clientY':first.clientY});}else{simulatedEvent=document.createEvent('MouseEvent');simulatedEvent.initMouseEvent(type,true,true,window,1,first.screenX,first.screenY,first.clientX,first.clientY,false,false,false,false,0/*left*/,null);}first.target.dispatchEvent(simulatedEvent);};};}(jQuery);//**********************************
!function($){var MutationObserver=function(){var prefixes=['WebKit','Moz','O','Ms',''];for(var i=0;i<prefixes.length;i++){if(prefixes[i]+'MutationObserver'in window){return window[prefixes[i]+'MutationObserver'];}}return false;}();var triggers=function triggers(el,type){el.data(type).split(' ').forEach(function(id){$('#'+id)[type==='close'?'trigger':'triggerHandler'](type+'.zf.trigger',[el]);});};// Elements with [data-open] will reveal a plugin that supports it when clicked.
$(document).on('click.zf.trigger','[data-open]',function(){triggers($(this),'open');});// Elements with [data-close] will close a plugin that supports it when clicked.
// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
$(document).on('click.zf.trigger','[data-close]',function(){var id=$(this).data('close');if(id){triggers($(this),'close');}else{$(this).trigger('close.zf.trigger');}});// Elements with [data-toggle] will toggle a plugin that supports it when clicked.
$(document).on('click.zf.trigger','[data-toggle]',function(){triggers($(this),'toggle');});// Elements with [data-closable] will respond to close.zf.trigger events.
$(document).on('close.zf.trigger','[data-closable]',function(e){e.stopPropagation();var animation=$(this).data('closable');if(animation!==''){Foundation.Motion.animateOut($(this),animation,function(){$(this).trigger('closed.zf');});}else{$(this).fadeOut().trigger('closed.zf');}});$(document).on('focus.zf.trigger blur.zf.trigger','[data-toggle-focus]',function(){var id=$(this).data('toggle-focus');$('#'+id).triggerHandler('toggle.zf.trigger',[$(this)]);});/**
  * Fires once after all other scripts have loaded
  * @function
  * @private
  */$(window).load(function(){checkListeners();});function checkListeners(){eventsListener();resizeListener();scrollListener();closemeListener();}//******** only fires this function once on load, if there's something to watch ********
function closemeListener(pluginName){var yetiBoxes=$('[data-yeti-box]'),plugNames=['dropdown','tooltip','reveal'];if(pluginName){if(typeof pluginName==='string'){plugNames.push(pluginName);}else if((typeof pluginName==='undefined'?'undefined':_typeof(pluginName))==='object'&&typeof pluginName[0]==='string'){plugNames.concat(pluginName);}else{console.error('Plugin names must be strings');}}if(yetiBoxes.length){var listeners=plugNames.map(function(name){return'closeme.zf.'+name;}).join(' ');$(window).off(listeners).on(listeners,function(e,pluginId){var plugin=e.namespace.split('.')[0];var plugins=$('[data-'+plugin+']').not('[data-yeti-box="'+pluginId+'"]');plugins.each(function(){var _this=$(this);_this.triggerHandler('close.zf.trigger',[_this]);});});}}function resizeListener(debounce){var timer=void 0,$nodes=$('[data-resize]');if($nodes.length){$(window).off('resize.zf.trigger').on('resize.zf.trigger',function(e){if(timer){clearTimeout(timer);}timer=setTimeout(function(){if(!MutationObserver){//fallback for IE 9
$nodes.each(function(){$(this).triggerHandler('resizeme.zf.trigger');});}//trigger all listening elements and signal a resize event
$nodes.attr('data-events',"resize");},debounce||10);//default time to emit resize event
});}}function scrollListener(debounce){var timer=void 0,$nodes=$('[data-scroll]');if($nodes.length){$(window).off('scroll.zf.trigger').on('scroll.zf.trigger',function(e){if(timer){clearTimeout(timer);}timer=setTimeout(function(){if(!MutationObserver){//fallback for IE 9
$nodes.each(function(){$(this).triggerHandler('scrollme.zf.trigger');});}//trigger all listening elements and signal a scroll event
$nodes.attr('data-events',"scroll");},debounce||10);//default time to emit scroll event
});}}function eventsListener(){if(!MutationObserver){return false;}var nodes=document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');//element callback
var listeningElementsMutation=function listeningElementsMutation(mutationRecordsList){var $target=$(mutationRecordsList[0].target);//trigger the event handler for the element depending on type
switch($target.attr("data-events")){case"resize":$target.triggerHandler('resizeme.zf.trigger',[$target]);break;case"scroll":$target.triggerHandler('scrollme.zf.trigger',[$target,window.pageYOffset]);break;// case "mutate" :
// console.log('mutate', $target);
// $target.triggerHandler('mutate.zf.trigger');
//
// //make sure we don't get stuck in an infinite loop from sloppy codeing
// if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
//   domMutationObserver();
// }
// break;
default:return false;//nothing
}};if(nodes.length){//for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
for(var i=0;i<=nodes.length-1;i++){var elementObserver=new MutationObserver(listeningElementsMutation);elementObserver.observe(nodes[i],{attributes:true,childList:false,characterData:false,subtree:false,attributeFilter:["data-events"]});}}}// ------------------------------------
// [PH]
// Foundation.CheckWatchers = checkWatchers;
Foundation.IHearYou=checkListeners;// Foundation.ISeeYou = scrollListener;
// Foundation.IFeelYou = closemeListener;
}(jQuery);// function domMutationObserver(debounce) {
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Abide module.
   * @module foundation.abide
   */var Abide=function(){/**
     * Creates a new instance of Abide.
     * @class
     * @fires Abide#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Abide(element){var options=arguments.length<=1||arguments[1]===undefined?{}:arguments[1];_classCallCheck(this,Abide);this.$element=element;this.options=$.extend({},Abide.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Abide');}/**
     * Initializes the Abide plugin and calls functions to get Abide functioning on load.
     * @private
     */_createClass(Abide,[{key:'_init',value:function _init(){this.$inputs=this.$element.find('input, textarea, select');this._events();}/**
       * Initializes events for Abide.
       * @private
       */},{key:'_events',value:function _events(){var _this2=this;this.$element.off('.abide').on('reset.zf.abide',function(){_this2.resetForm();}).on('submit.zf.abide',function(){return _this2.validateForm();});if(this.options.validateOn==='fieldChange'){this.$inputs.off('change.zf.abide').on('change.zf.abide',function(e){_this2.validateInput($(e.target));});}if(this.options.liveValidate){this.$inputs.off('input.zf.abide').on('input.zf.abide',function(e){_this2.validateInput($(e.target));});}}/**
       * Calls necessary functions to update Abide upon DOM change
       * @private
       */},{key:'_reflow',value:function _reflow(){this._init();}/**
       * Checks whether or not a form element has the required attribute and if it's checked or not
       * @param {Object} element - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */},{key:'requiredCheck',value:function requiredCheck($el){if(!$el.attr('required'))return true;var isGood=true;switch($el[0].type){case'checkbox':isGood=$el[0].checked;break;case'select':case'select-one':case'select-multiple':var opt=$el.find('option:selected');if(!opt.length||!opt.val())isGood=false;break;default:if(!$el.val()||!$el.val().length)isGood=false;}return isGood;}/**
       * Based on $el, get the first element with selector in this order:
       * 1. The element's direct sibling('s).
       * 3. The element's parent's children.
       *
       * This allows for multiple form errors per input, though if none are found, no form errors will be shown.
       *
       * @param {Object} $el - jQuery object to use as reference to find the form error selector.
       * @returns {Object} jQuery object with the selector.
       */},{key:'findFormError',value:function findFormError($el){var $error=$el.siblings(this.options.formErrorSelector);if(!$error.length){$error=$el.parent().find(this.options.formErrorSelector);}return $error;}/**
       * Get the first element in this order:
       * 2. The <label> with the attribute `[for="someInputId"]`
       * 3. The `.closest()` <label>
       *
       * @param {Object} $el - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */},{key:'findLabel',value:function findLabel($el){var id=$el[0].id;var $label=this.$element.find('label[for="'+id+'"]');if(!$label.length){return $el.closest('label');}return $label;}/**
       * Get the set of labels associated with a set of radio els in this order
       * 2. The <label> with the attribute `[for="someInputId"]`
       * 3. The `.closest()` <label>
       *
       * @param {Object} $el - jQuery object to check for required attribute
       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty
       */},{key:'findRadioLabels',value:function findRadioLabels($els){var _this3=this;var labels=$els.map(function(i,el){var id=el.id;var $label=_this3.$element.find('label[for="'+id+'"]');if(!$label.length){$label=$(el).closest('label');}return $label[0];});return $(labels);}/**
       * Adds the CSS error class as specified by the Abide settings to the label, input, and the form
       * @param {Object} $el - jQuery object to add the class to
       */},{key:'addErrorClasses',value:function addErrorClasses($el){var $label=this.findLabel($el);var $formError=this.findFormError($el);if($label.length){$label.addClass(this.options.labelErrorClass);}if($formError.length){$formError.addClass(this.options.formErrorClass);}$el.addClass(this.options.inputErrorClass).attr('data-invalid','');}/**
       * Remove CSS error classes etc from an entire radio button group
       * @param {String} groupName - A string that specifies the name of a radio button group
       *
       */},{key:'removeRadioErrorClasses',value:function removeRadioErrorClasses(groupName){var $els=this.$element.find(':radio[name="'+groupName+'"]');var $labels=this.findRadioLabels($els);var $formErrors=this.findFormError($els);if($labels.length){$labels.removeClass(this.options.labelErrorClass);}if($formErrors.length){$formErrors.removeClass(this.options.formErrorClass);}$els.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');}/**
       * Removes CSS error class as specified by the Abide settings from the label, input, and the form
       * @param {Object} $el - jQuery object to remove the class from
       */},{key:'removeErrorClasses',value:function removeErrorClasses($el){// radios need to clear all of the els
if($el[0].type=='radio'){return this.removeRadioErrorClasses($el.attr('name'));}var $label=this.findLabel($el);var $formError=this.findFormError($el);if($label.length){$label.removeClass(this.options.labelErrorClass);}if($formError.length){$formError.removeClass(this.options.formErrorClass);}$el.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');}/**
       * Goes through a form to find inputs and proceeds to validate them in ways specific to their type
       * @fires Abide#invalid
       * @fires Abide#valid
       * @param {Object} element - jQuery object to validate, should be an HTML input
       * @returns {Boolean} goodToGo - If the input is valid or not.
       */},{key:'validateInput',value:function validateInput($el){var clearRequire=this.requiredCheck($el),validated=false,customValidator=true,validator=$el.attr('data-validator'),equalTo=true;// don't validate ignored inputs or hidden inputs
if($el.is('[data-abide-ignore]')||$el.is('[type="hidden"]')){return true;}switch($el[0].type){case'radio':validated=this.validateRadio($el.attr('name'));break;case'checkbox':validated=clearRequire;break;case'select':case'select-one':case'select-multiple':validated=clearRequire;break;default:validated=this.validateText($el);}if(validator){customValidator=this.matchValidation($el,validator,$el.attr('required'));}if($el.attr('data-equalto')){equalTo=this.options.validators.equalTo($el);}var goodToGo=[clearRequire,validated,customValidator,equalTo].indexOf(false)===-1;var message=(goodToGo?'valid':'invalid')+'.zf.abide';this[goodToGo?'removeErrorClasses':'addErrorClasses']($el);/**
         * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`
         * Trigger includes the DOM element of the input.
         * @event Abide#valid
         * @event Abide#invalid
         */$el.trigger(message,[$el]);return goodToGo;}/**
       * Goes through a form and if there are any invalid inputs, it will display the form error element
       * @returns {Boolean} noError - true if no errors were detected...
       * @fires Abide#formvalid
       * @fires Abide#forminvalid
       */},{key:'validateForm',value:function validateForm(){var acc=[];var _this=this;this.$inputs.each(function(){acc.push(_this.validateInput($(this)));});var noError=acc.indexOf(false)===-1;this.$element.find('[data-abide-error]').css('display',noError?'none':'block');/**
         * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.
         * Trigger includes the element of the form.
         * @event Abide#formvalid
         * @event Abide#forminvalid
         */this.$element.trigger((noError?'formvalid':'forminvalid')+'.zf.abide',[this.$element]);return noError;}/**
       * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.
       * @param {Object} $el - jQuery object to validate, should be a text input HTML element
       * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns
       * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified
       */},{key:'validateText',value:function validateText($el,pattern){// A pattern can be passed to this function, or it will be infered from the input's "pattern" attribute, or it's "type" attribute
pattern=pattern||$el.attr('pattern')||$el.attr('type');var inputText=$el.val();var valid=false;if(inputText.length){// If the pattern attribute on the element is in Abide's list of patterns, then test that regexp
if(this.options.patterns.hasOwnProperty(pattern)){valid=this.options.patterns[pattern].test(inputText);}// If the pattern name isn't also the type attribute of the field, then test it as a regexp
else if(pattern!==$el.attr('type')){valid=new RegExp(pattern).test(inputText);}else{valid=true;}}// An empty field is valid if it's not required
else if(!$el.prop('required')){valid=true;}return valid;}/**
       * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.
       * @param {String} groupName - A string that specifies the name of a radio button group
       * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)
       */},{key:'validateRadio',value:function validateRadio(groupName){// If at least one radio in the group has the `required` attribute, the group is considered required
// Per W3C spec, all radio buttons in a group should have `required`, but we're being nice
var $group=this.$element.find(':radio[name="'+groupName+'"]');var valid=false,required=false;// For the group to be required, at least one radio needs to be required
$group.each(function(i,e){if($(e).attr('required')){required=true;}});if(!required)valid=true;if(!valid){// For the group to be valid, at least one radio needs to be checked
$group.each(function(i,e){if($(e).prop('checked')){valid=true;}});}return valid;}/**
       * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator="foo bar baz"` in a space separated listed.
       * @param {Object} $el - jQuery input element.
       * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.
       * @param {Boolean} required - self explanatory?
       * @returns {Boolean} - true if validations passed.
       */},{key:'matchValidation',value:function matchValidation($el,validators,required){var _this4=this;required=required?true:false;var clear=validators.split(' ').map(function(v){return _this4.options.validators[v]($el,required,$el.parent());});return clear.indexOf(false)===-1;}/**
       * Resets form inputs and styles
       * @fires Abide#formreset
       */},{key:'resetForm',value:function resetForm(){var $form=this.$element,opts=this.options;$('.'+opts.labelErrorClass,$form).not('small').removeClass(opts.labelErrorClass);$('.'+opts.inputErrorClass,$form).not('small').removeClass(opts.inputErrorClass);$(opts.formErrorSelector+'.'+opts.formErrorClass).removeClass(opts.formErrorClass);$form.find('[data-abide-error]').css('display','none');$(':input',$form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').removeAttr('data-invalid');$(':input:radio',$form).not('[data-abide-ignore]').prop('checked',false).removeAttr('data-invalid');$(':input:checkbox',$form).not('[data-abide-ignore]').prop('checked',false).removeAttr('data-invalid');/**
         * Fires when the form has been reset.
         * @event Abide#formreset
         */$form.trigger('formreset.zf.abide',[$form]);}/**
       * Destroys an instance of Abide.
       * Removes error styles and classes from elements, without resetting their values.
       */},{key:'destroy',value:function destroy(){var _this=this;this.$element.off('.abide').find('[data-abide-error]').css('display','none');this.$inputs.off('.abide').each(function(){_this.removeErrorClasses($(this));});Foundation.unregisterPlugin(this);}}]);return Abide;}();/**
   * Default settings for plugin
   */Abide.defaults={/**
     * The default event to validate inputs. Checkboxes and radios validate immediately.
     * Remove or change this value for manual validation.
     * @option
     * @example 'fieldChange'
     */validateOn:'fieldChange',/**
     * Class to be applied to input labels on failed validation.
     * @option
     * @example 'is-invalid-label'
     */labelErrorClass:'is-invalid-label',/**
     * Class to be applied to inputs on failed validation.
     * @option
     * @example 'is-invalid-input'
     */inputErrorClass:'is-invalid-input',/**
     * Class selector to use to target Form Errors for show/hide.
     * @option
     * @example '.form-error'
     */formErrorSelector:'.form-error',/**
     * Class added to Form Errors on failed validation.
     * @option
     * @example 'is-visible'
     */formErrorClass:'is-visible',/**
     * Set to true to validate text inputs on any value change.
     * @option
     * @example false
     */liveValidate:false,patterns:{alpha:/^[a-zA-Z]+$/,alpha_numeric:/^[a-zA-Z0-9]+$/,integer:/^[-+]?\d+$/,number:/^[-+]?\d*(?:[\.\,]\d+)?$/,// amex, visa, diners
card:/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,cvv:/^([0-9]){3,4}$/,// http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
email:/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,url:/^(https?|ftp|file|ssh):\/\/(((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-zA-Z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/,// abc.de
domain:/^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,datetime:/^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,// YYYY-MM-DD
date:/(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,// HH:MM:SS
time:/^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,dateISO:/^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,// MM/DD/YYYY
month_day_year:/^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,// DD/MM/YYYY
day_month_year:/^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,// #FFF or #FFFFFF
color:/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/},/**
     * Optional validation functions to be used. `equalTo` being the only default included function.
     * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:
     * el : The jQuery element to validate.
     * required : Boolean value of the required attribute be present or not.
     * parent : The direct parent of the input.
     * @option
     */validators:{equalTo:function equalTo(el,required,parent){return $('#'+el.attr('data-equalto')).val()===el.val();}}};// Window exports
Foundation.plugin(Abide,'Abide');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Accordion module.
   * @module foundation.accordion
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   */var Accordion=function(){/**
     * Creates a new instance of an accordion.
     * @class
     * @fires Accordion#init
     * @param {jQuery} element - jQuery object to make into an accordion.
     * @param {Object} options - a plain object with settings to override the default options.
     */function Accordion(element,options){_classCallCheck(this,Accordion);this.$element=element;this.options=$.extend({},Accordion.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Accordion');Foundation.Keyboard.register('Accordion',{'ENTER':'toggle','SPACE':'toggle','ARROW_DOWN':'next','ARROW_UP':'previous'});}/**
     * Initializes the accordion by animating the preset active pane(s).
     * @private
     */_createClass(Accordion,[{key:'_init',value:function _init(){this.$element.attr('role','tablist');this.$tabs=this.$element.children('li, [data-accordion-item]');this.$tabs.each(function(idx,el){var $el=$(el),$content=$el.children('[data-tab-content]'),id=$content[0].id||Foundation.GetYoDigits(6,'accordion'),linkId=el.id||id+'-label';$el.find('a:first').attr({'aria-controls':id,'role':'tab','id':linkId,'aria-expanded':false,'aria-selected':false});$content.attr({'role':'tabpanel','aria-labelledby':linkId,'aria-hidden':true,'id':id});});var $initActive=this.$element.find('.is-active').children('[data-tab-content]');if($initActive.length){this.down($initActive,true);}this._events();}/**
       * Adds event handlers for items within the accordion.
       * @private
       */},{key:'_events',value:function _events(){var _this=this;this.$tabs.each(function(){var $elem=$(this);var $tabContent=$elem.children('[data-tab-content]');if($tabContent.length){$elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion',function(e){// $(this).children('a').on('click.zf.accordion', function(e) {
e.preventDefault();if($elem.hasClass('is-active')){if(_this.options.allowAllClosed||$elem.siblings().hasClass('is-active')){_this.up($tabContent);}}else{_this.down($tabContent);}}).on('keydown.zf.accordion',function(e){Foundation.Keyboard.handleKey(e,'Accordion',{toggle:function toggle(){_this.toggle($tabContent);},next:function next(){var $a=$elem.next().find('a').focus();if(!_this.options.multiExpand){$a.trigger('click.zf.accordion');}},previous:function previous(){var $a=$elem.prev().find('a').focus();if(!_this.options.multiExpand){$a.trigger('click.zf.accordion');}},handled:function handled(){e.preventDefault();e.stopPropagation();}});});}});}/**
       * Toggles the selected content pane's open/close state.
       * @param {jQuery} $target - jQuery object of the pane to toggle.
       * @function
       */},{key:'toggle',value:function toggle($target){if($target.parent().hasClass('is-active')){if(this.options.allowAllClosed||$target.parent().siblings().hasClass('is-active')){this.up($target);}else{return;}}else{this.down($target);}}/**
       * Opens the accordion tab defined by `$target`.
       * @param {jQuery} $target - Accordion pane to open.
       * @param {Boolean} firstTime - flag to determine if reflow should happen.
       * @fires Accordion#down
       * @function
       */},{key:'down',value:function down($target,firstTime){var _this2=this;if(!this.options.multiExpand&&!firstTime){var $currentActive=this.$element.children('.is-active').children('[data-tab-content]');if($currentActive.length){this.up($currentActive);}}$target.attr('aria-hidden',false).parent('[data-tab-content]').addBack().parent().addClass('is-active');$target.slideDown(this.options.slideSpeed,function(){/**
           * Fires when the tab is done opening.
           * @event Accordion#down
           */_this2.$element.trigger('down.zf.accordion',[$target]);});$('#'+$target.attr('aria-labelledby')).attr({'aria-expanded':true,'aria-selected':true});}/**
       * Closes the tab defined by `$target`.
       * @param {jQuery} $target - Accordion tab to close.
       * @fires Accordion#up
       * @function
       */},{key:'up',value:function up($target){var $aunts=$target.parent().siblings(),_this=this;var canClose=this.options.multiExpand?$aunts.hasClass('is-active'):$target.parent().hasClass('is-active');if(!this.options.allowAllClosed&&!canClose){return;}// Foundation.Move(this.options.slideSpeed, $target, function(){
$target.slideUp(_this.options.slideSpeed,function(){/**
           * Fires when the tab is done collapsing up.
           * @event Accordion#up
           */_this.$element.trigger('up.zf.accordion',[$target]);});// });
$target.attr('aria-hidden',true).parent().removeClass('is-active');$('#'+$target.attr('aria-labelledby')).attr({'aria-expanded':false,'aria-selected':false});}/**
       * Destroys an instance of an accordion.
       * @fires Accordion#destroyed
       * @function
       */},{key:'destroy',value:function destroy(){this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display','');this.$element.find('a').off('.zf.accordion');Foundation.unregisterPlugin(this);}}]);return Accordion;}();Accordion.defaults={/**
     * Amount of time to animate the opening of an accordion pane.
     * @option
     * @example 250
     */slideSpeed:250,/**
     * Allow the accordion to have multiple open panes.
     * @option
     * @example false
     */multiExpand:false,/**
     * Allow the accordion to close all panes.
     * @option
     * @example false
     */allowAllClosed:false};// Window exports
Foundation.plugin(Accordion,'Accordion');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * AccordionMenu module.
   * @module foundation.accordionMenu
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.nest
   */var AccordionMenu=function(){/**
     * Creates a new instance of an accordion menu.
     * @class
     * @fires AccordionMenu#init
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */function AccordionMenu(element,options){_classCallCheck(this,AccordionMenu);this.$element=element;this.options=$.extend({},AccordionMenu.defaults,this.$element.data(),options);Foundation.Nest.Feather(this.$element,'accordion');this._init();Foundation.registerPlugin(this,'AccordionMenu');Foundation.Keyboard.register('AccordionMenu',{'ENTER':'toggle','SPACE':'toggle','ARROW_RIGHT':'open','ARROW_UP':'up','ARROW_DOWN':'down','ARROW_LEFT':'close','ESCAPE':'closeAll','TAB':'down','SHIFT_TAB':'up'});}/**
     * Initializes the accordion menu by hiding all nested menus.
     * @private
     */_createClass(AccordionMenu,[{key:'_init',value:function _init(){this.$element.find('[data-submenu]').not('.is-active').slideUp(0);//.find('a').css('padding-left', '1rem');
this.$element.attr({'role':'tablist','aria-multiselectable':this.options.multiOpen});this.$menuLinks=this.$element.find('.is-accordion-submenu-parent');this.$menuLinks.each(function(){var linkId=this.id||Foundation.GetYoDigits(6,'acc-menu-link'),$elem=$(this),$sub=$elem.children('[data-submenu]'),subId=$sub[0].id||Foundation.GetYoDigits(6,'acc-menu'),isActive=$sub.hasClass('is-active');$elem.attr({'aria-controls':subId,'aria-expanded':isActive,'role':'tab','id':linkId});$sub.attr({'aria-labelledby':linkId,'aria-hidden':!isActive,'role':'tabpanel','id':subId});});var initPanes=this.$element.find('.is-active');if(initPanes.length){var _this=this;initPanes.each(function(){_this.down($(this));});}this._events();}/**
       * Adds event handlers for items within the menu.
       * @private
       */},{key:'_events',value:function _events(){var _this=this;this.$element.find('li').each(function(){var $submenu=$(this).children('[data-submenu]');if($submenu.length){$(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu',function(e){e.preventDefault();_this.toggle($submenu);});}}).on('keydown.zf.accordionmenu',function(e){var $element=$(this),$elements=$element.parent('ul').children('li'),$prevElement,$nextElement,$target=$element.children('[data-submenu]');$elements.each(function(i){if($(this).is($element)){$prevElement=$elements.eq(Math.max(0,i-1)).find('a').first();$nextElement=$elements.eq(Math.min(i+1,$elements.length-1)).find('a').first();if($(this).children('[data-submenu]:visible').length){// has open sub menu
$nextElement=$element.find('li:first-child').find('a').first();}if($(this).is(':first-child')){// is first element of sub menu
$prevElement=$element.parents('li').first().find('a').first();}else if($prevElement.children('[data-submenu]:visible').length){// if previous element has open sub menu
$prevElement=$prevElement.find('li:last-child').find('a').first();}if($(this).is(':last-child')){// is last element of sub menu
$nextElement=$element.parents('li').first().next('li').find('a').first();}return;}});Foundation.Keyboard.handleKey(e,'AccordionMenu',{open:function open(){if($target.is(':hidden')){_this.down($target);$target.find('li').first().find('a').first().focus();}},close:function close(){if($target.length&&!$target.is(':hidden')){// close active sub of this item
_this.up($target);}else if($element.parent('[data-submenu]').length){// close currently open sub
_this.up($element.parent('[data-submenu]'));$element.parents('li').first().find('a').first().focus();}},up:function up(){$prevElement.attr('tabindex',-1).focus();return true;},down:function down(){$nextElement.attr('tabindex',-1).focus();return true;},toggle:function toggle(){if($element.children('[data-submenu]').length){_this.toggle($element.children('[data-submenu]'));}},closeAll:function closeAll(){_this.hideAll();},handled:function handled(preventDefault){if(preventDefault){e.preventDefault();}e.stopImmediatePropagation();}});});//.attr('tabindex', 0);
}/**
       * Closes all panes of the menu.
       * @function
       */},{key:'hideAll',value:function hideAll(){this.$element.find('[data-submenu]').slideUp(this.options.slideSpeed);}/**
       * Toggles the open/close state of a submenu.
       * @function
       * @param {jQuery} $target - the submenu to toggle
       */},{key:'toggle',value:function toggle($target){if(!$target.is(':animated')){if(!$target.is(':hidden')){this.up($target);}else{this.down($target);}}}/**
       * Opens the sub-menu defined by `$target`.
       * @param {jQuery} $target - Sub-menu to open.
       * @fires AccordionMenu#down
       */},{key:'down',value:function down($target){var _this=this;if(!this.options.multiOpen){this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));}$target.addClass('is-active').attr({'aria-hidden':false}).parent('.is-accordion-submenu-parent').attr({'aria-expanded':true});//Foundation.Move(this.options.slideSpeed, $target, function() {
$target.slideDown(_this.options.slideSpeed,function(){/**
           * Fires when the menu is done opening.
           * @event AccordionMenu#down
           */_this.$element.trigger('down.zf.accordionMenu',[$target]);});//});
}/**
       * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
       * @param {jQuery} $target - Sub-menu to close.
       * @fires AccordionMenu#up
       */},{key:'up',value:function up($target){var _this=this;//Foundation.Move(this.options.slideSpeed, $target, function(){
$target.slideUp(_this.options.slideSpeed,function(){/**
           * Fires when the menu is done collapsing up.
           * @event AccordionMenu#up
           */_this.$element.trigger('up.zf.accordionMenu',[$target]);});//});
var $menus=$target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden',true);$menus.parent('.is-accordion-submenu-parent').attr('aria-expanded',false);}/**
       * Destroys an instance of accordion menu.
       * @fires AccordionMenu#destroyed
       */},{key:'destroy',value:function destroy(){this.$element.find('[data-submenu]').slideDown(0).css('display','');this.$element.find('a').off('click.zf.accordionMenu');Foundation.Nest.Burn(this.$element,'accordion');Foundation.unregisterPlugin(this);}}]);return AccordionMenu;}();AccordionMenu.defaults={/**
     * Amount of time to animate the opening of a submenu in ms.
     * @option
     * @example 250
     */slideSpeed:250,/**
     * Allow the menu to have multiple open panes.
     * @option
     * @example true
     */multiOpen:true};// Window exports
Foundation.plugin(AccordionMenu,'AccordionMenu');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Drilldown module.
   * @module foundation.drilldown
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.nest
   */var Drilldown=function(){/**
     * Creates a new instance of a drilldown menu.
     * @class
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Drilldown(element,options){_classCallCheck(this,Drilldown);this.$element=element;this.options=$.extend({},Drilldown.defaults,this.$element.data(),options);Foundation.Nest.Feather(this.$element,'drilldown');this._init();Foundation.registerPlugin(this,'Drilldown');Foundation.Keyboard.register('Drilldown',{'ENTER':'open','SPACE':'open','ARROW_RIGHT':'next','ARROW_UP':'up','ARROW_DOWN':'down','ARROW_LEFT':'previous','ESCAPE':'close','TAB':'down','SHIFT_TAB':'up'});}/**
     * Initializes the drilldown by creating jQuery collections of elements
     * @private
     */_createClass(Drilldown,[{key:'_init',value:function _init(){this.$submenuAnchors=this.$element.find('li.is-drilldown-submenu-parent').children('a');this.$submenus=this.$submenuAnchors.parent('li').children('[data-submenu]');this.$menuItems=this.$element.find('li').not('.js-drilldown-back').attr('role','menuitem').find('a');this._prepareMenu();this._keyboardEvents();}/**
       * prepares drilldown menu by setting attributes to links and elements
       * sets a min height to prevent content jumping
       * wraps the element if not already wrapped
       * @private
       * @function
       */},{key:'_prepareMenu',value:function _prepareMenu(){var _this=this;// if(!this.options.holdOpen){
//   this._menuLinkEvents();
// }
this.$submenuAnchors.each(function(){var $link=$(this);var $sub=$link.parent();if(_this.options.parentLink){$link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="menu-item"></li>');}$link.data('savedHref',$link.attr('href')).removeAttr('href');$link.children('[data-submenu]').attr({'aria-hidden':true,'tabindex':0,'role':'menu'});_this._events($link);});this.$submenus.each(function(){var $menu=$(this),$back=$menu.find('.js-drilldown-back');if(!$back.length){$menu.prepend(_this.options.backButton);}_this._back($menu);});if(!this.$element.parent().hasClass('is-drilldown')){this.$wrapper=$(this.options.wrapper).addClass('is-drilldown');this.$wrapper=this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims());}}/**
       * Adds event handlers to elements in the menu.
       * @function
       * @private
       * @param {jQuery} $elem - the current menu item to add handlers to.
       */},{key:'_events',value:function _events($elem){var _this=this;$elem.off('click.zf.drilldown').on('click.zf.drilldown',function(e){if($(e.target).parentsUntil('ul','li').hasClass('is-drilldown-submenu-parent')){e.stopImmediatePropagation();e.preventDefault();}// if(e.target !== e.currentTarget.firstElementChild){
//   return false;
// }
_this._show($elem.parent('li'));if(_this.options.closeOnClick){var $body=$('body');$body.off('.zf.drilldown').on('click.zf.drilldown',function(e){if(e.target===_this.$element[0]||$.contains(_this.$element[0],e.target)){return;}e.preventDefault();_this._hideAll();$body.off('.zf.drilldown');});}});}/**
       * Adds keydown event listener to `li`'s in the menu.
       * @private
       */},{key:'_keyboardEvents',value:function _keyboardEvents(){var _this=this;this.$menuItems.add(this.$element.find('.js-drilldown-back > a')).on('keydown.zf.drilldown',function(e){var $element=$(this),$elements=$element.parent('li').parent('ul').children('li').children('a'),$prevElement,$nextElement;$elements.each(function(i){if($(this).is($element)){$prevElement=$elements.eq(Math.max(0,i-1));$nextElement=$elements.eq(Math.min(i+1,$elements.length-1));return;}});Foundation.Keyboard.handleKey(e,'Drilldown',{next:function next(){if($element.is(_this.$submenuAnchors)){_this._show($element.parent('li'));$element.parent('li').one(Foundation.transitionend($element),function(){$element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();});return true;}},previous:function previous(){_this._hide($element.parent('li').parent('ul'));$element.parent('li').parent('ul').one(Foundation.transitionend($element),function(){setTimeout(function(){$element.parent('li').parent('ul').parent('li').children('a').first().focus();},1);});return true;},up:function up(){$prevElement.focus();return true;},down:function down(){$nextElement.focus();return true;},close:function close(){_this._back();//_this.$menuItems.first().focus(); // focus to first element
},open:function open(){if(!$element.is(_this.$menuItems)){// not menu item means back button
_this._hide($element.parent('li').parent('ul'));$element.parent('li').parent('ul').one(Foundation.transitionend($element),function(){setTimeout(function(){$element.parent('li').parent('ul').parent('li').children('a').first().focus();},1);});}else if($element.is(_this.$submenuAnchors)){_this._show($element.parent('li'));$element.parent('li').one(Foundation.transitionend($element),function(){$element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();});}return true;},handled:function handled(preventDefault){if(preventDefault){e.preventDefault();}e.stopImmediatePropagation();}});});// end keyboardAccess
}/**
       * Closes all open elements, and returns to root menu.
       * @function
       * @fires Drilldown#closed
       */},{key:'_hideAll',value:function _hideAll(){var $elem=this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');$elem.one(Foundation.transitionend($elem),function(e){$elem.removeClass('is-active is-closing');});/**
         * Fires when the menu is fully closed.
         * @event Drilldown#closed
         */this.$element.trigger('closed.zf.drilldown');}/**
       * Adds event listener for each `back` button, and closes open menus.
       * @function
       * @fires Drilldown#back
       * @param {jQuery} $elem - the current sub-menu to add `back` event.
       */},{key:'_back',value:function _back($elem){var _this=this;$elem.off('click.zf.drilldown');$elem.children('.js-drilldown-back').on('click.zf.drilldown',function(e){e.stopImmediatePropagation();// console.log('mouseup on back');
_this._hide($elem);});}/**
       * Adds event listener to menu items w/o submenus to close open menus on click.
       * @function
       * @private
       */},{key:'_menuLinkEvents',value:function _menuLinkEvents(){var _this=this;this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown',function(e){// e.stopImmediatePropagation();
setTimeout(function(){_this._hideAll();},0);});}/**
       * Opens a submenu.
       * @function
       * @fires Drilldown#open
       * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.
       */},{key:'_show',value:function _show($elem){$elem.children('[data-submenu]').addClass('is-active');/**
         * Fires when the submenu has opened.
         * @event Drilldown#open
         */this.$element.trigger('open.zf.drilldown',[$elem]);}},{key:'_hide',/**
       * Hides a submenu
       * @function
       * @fires Drilldown#hide
       * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.
       */value:function _hide($elem){var _this=this;$elem.addClass('is-closing').one(Foundation.transitionend($elem),function(){$elem.removeClass('is-active is-closing');$elem.blur();});/**
         * Fires when the submenu has closed.
         * @event Drilldown#hide
         */$elem.trigger('hide.zf.drilldown',[$elem]);}/**
       * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
       * Prevents content jumping.
       * @function
       * @private
       */},{key:'_getMaxDims',value:function _getMaxDims(){var max=0,result={};this.$submenus.add(this.$element).each(function(){var numOfElems=$(this).children('li').length;max=numOfElems>max?numOfElems:max;});result['min-height']=max*this.$menuItems[0].getBoundingClientRect().height+'px';result['max-width']=this.$element[0].getBoundingClientRect().width+'px';return result;}/**
       * Destroys the Drilldown Menu
       * @function
       */},{key:'destroy',value:function destroy(){this._hideAll();Foundation.Nest.Burn(this.$element,'drilldown');this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');this.$submenuAnchors.each(function(){$(this).off('.zf.drilldown');});this.$element.find('a').each(function(){var $link=$(this);if($link.data('savedHref')){$link.attr('href',$link.data('savedHref')).removeData('savedHref');}else{return;}});Foundation.unregisterPlugin(this);}}]);return Drilldown;}();Drilldown.defaults={/**
     * Markup used for JS generated back button. Prepended to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\`) if copy and pasting.
     * @option
     * @example '<\li><\a>Back<\/a><\/li>'
     */backButton:'<li class="js-drilldown-back"><a tabindex="0">Back</a></li>',/**
     * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\`) if copy and pasting.
     * @option
     * @example '<\div class="is-drilldown"><\/div>'
     */wrapper:'<div></div>',/**
     * Adds the parent link to the submenu.
     * @option
     * @example false
     */parentLink:false,/**
     * Allow the menu to return to root list on body click.
     * @option
     * @example false
     */closeOnClick:false// holdOpen: false
};// Window exports
Foundation.plugin(Drilldown,'Drilldown');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Dropdown module.
   * @module foundation.dropdown
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   */var Dropdown=function(){/**
     * Creates a new instance of a dropdown.
     * @class
     * @param {jQuery} element - jQuery object to make into a dropdown.
     *        Object should be of the dropdown panel, rather than its anchor.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Dropdown(element,options){_classCallCheck(this,Dropdown);this.$element=element;this.options=$.extend({},Dropdown.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Dropdown');Foundation.Keyboard.register('Dropdown',{'ENTER':'open','SPACE':'open','ESCAPE':'close','TAB':'tab_forward','SHIFT_TAB':'tab_backward'});}/**
     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.
     * @function
     * @private
     */_createClass(Dropdown,[{key:'_init',value:function _init(){var $id=this.$element.attr('id');this.$anchor=$('[data-toggle="'+$id+'"]')||$('[data-open="'+$id+'"]');this.$anchor.attr({'aria-controls':$id,'data-is-focus':false,'data-yeti-box':$id,'aria-haspopup':true,'aria-expanded':false});this.options.positionClass=this.getPositionClass();this.counter=4;this.usedPositions=[];this.$element.attr({'aria-hidden':'true','data-yeti-box':$id,'data-resize':$id,'aria-labelledby':this.$anchor[0].id||Foundation.GetYoDigits(6,'dd-anchor')});this._events();}/**
       * Helper function to determine current orientation of dropdown pane.
       * @function
       * @returns {String} position - string value of a position class.
       */},{key:'getPositionClass',value:function getPositionClass(){var verticalPosition=this.$element[0].className.match(/(top|left|right|bottom)/g);verticalPosition=verticalPosition?verticalPosition[0]:'';var horizontalPosition=/float-(\S+)\s/.exec(this.$anchor[0].className);horizontalPosition=horizontalPosition?horizontalPosition[1]:'';var position=horizontalPosition?horizontalPosition+' '+verticalPosition:verticalPosition;return position;}/**
       * Adjusts the dropdown panes orientation by adding/removing positioning classes.
       * @function
       * @private
       * @param {String} position - position class to remove.
       */},{key:'_reposition',value:function _reposition(position){this.usedPositions.push(position?position:'bottom');//default, try switching to opposite side
if(!position&&this.usedPositions.indexOf('top')<0){this.$element.addClass('top');}else if(position==='top'&&this.usedPositions.indexOf('bottom')<0){this.$element.removeClass(position);}else if(position==='left'&&this.usedPositions.indexOf('right')<0){this.$element.removeClass(position).addClass('right');}else if(position==='right'&&this.usedPositions.indexOf('left')<0){this.$element.removeClass(position).addClass('left');}//if default change didn't work, try bottom or left first
else if(!position&&this.usedPositions.indexOf('top')>-1&&this.usedPositions.indexOf('left')<0){this.$element.addClass('left');}else if(position==='top'&&this.usedPositions.indexOf('bottom')>-1&&this.usedPositions.indexOf('left')<0){this.$element.removeClass(position).addClass('left');}else if(position==='left'&&this.usedPositions.indexOf('right')>-1&&this.usedPositions.indexOf('bottom')<0){this.$element.removeClass(position);}else if(position==='right'&&this.usedPositions.indexOf('left')>-1&&this.usedPositions.indexOf('bottom')<0){this.$element.removeClass(position);}//if nothing cleared, set to bottom
else{this.$element.removeClass(position);}this.classChanged=true;this.counter--;}/**
       * Sets the position and orientation of the dropdown pane, checks for collisions.
       * Recursively calls itself if a collision is detected, with a new position class.
       * @function
       * @private
       */},{key:'_setPosition',value:function _setPosition(){if(this.$anchor.attr('aria-expanded')==='false'){return false;}var position=this.getPositionClass(),$eleDims=Foundation.Box.GetDimensions(this.$element),$anchorDims=Foundation.Box.GetDimensions(this.$anchor),_this=this,direction=position==='left'?'left':position==='right'?'left':'top',param=direction==='top'?'height':'width',offset=param==='height'?this.options.vOffset:this.options.hOffset;if($eleDims.width>=$eleDims.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.$element)){this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,'center bottom',this.options.vOffset,this.options.hOffset,true)).css({'width':$eleDims.windowDims.width-this.options.hOffset*2,'height':'auto'});this.classChanged=true;return false;}this.$element.offset(Foundation.Box.GetOffsets(this.$element,this.$anchor,position,this.options.vOffset,this.options.hOffset));while(!Foundation.Box.ImNotTouchingYou(this.$element,false,true)&&this.counter){this._reposition(position);this._setPosition();}}/**
       * Adds event listeners to the element utilizing the triggers utility library.
       * @function
       * @private
       */},{key:'_events',value:function _events(){var _this=this;this.$element.on({'open.zf.trigger':this.open.bind(this),'close.zf.trigger':this.close.bind(this),'toggle.zf.trigger':this.toggle.bind(this),'resizeme.zf.trigger':this._setPosition.bind(this)});if(this.options.hover){this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown',function(){clearTimeout(_this.timeout);_this.timeout=setTimeout(function(){_this.open();_this.$anchor.data('hover',true);},_this.options.hoverDelay);}).on('mouseleave.zf.dropdown',function(){clearTimeout(_this.timeout);_this.timeout=setTimeout(function(){_this.close();_this.$anchor.data('hover',false);},_this.options.hoverDelay);});if(this.options.hoverPane){this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown',function(){clearTimeout(_this.timeout);}).on('mouseleave.zf.dropdown',function(){clearTimeout(_this.timeout);_this.timeout=setTimeout(function(){_this.close();_this.$anchor.data('hover',false);},_this.options.hoverDelay);});}}this.$anchor.add(this.$element).on('keydown.zf.dropdown',function(e){var $target=$(this),visibleFocusableElements=Foundation.Keyboard.findFocusable(_this.$element);Foundation.Keyboard.handleKey(e,'Dropdown',{tab_forward:function tab_forward(){if(_this.$element.find(':focus').is(visibleFocusableElements.eq(-1))){// left modal downwards, setting focus to first element
if(_this.options.trapFocus){// if focus shall be trapped
visibleFocusableElements.eq(0).focus();e.preventDefault();}else{// if focus is not trapped, close dropdown on focus out
_this.close();}}},tab_backward:function tab_backward(){if(_this.$element.find(':focus').is(visibleFocusableElements.eq(0))||_this.$element.is(':focus')){// left modal upwards, setting focus to last element
if(_this.options.trapFocus){// if focus shall be trapped
visibleFocusableElements.eq(-1).focus();e.preventDefault();}else{// if focus is not trapped, close dropdown on focus out
_this.close();}}},open:function open(){if($target.is(_this.$anchor)){_this.open();_this.$element.attr('tabindex',-1).focus();e.preventDefault();}},close:function close(){_this.close();_this.$anchor.focus();}});});}/**
       * Adds an event handler to the body to close any dropdowns on a click.
       * @function
       * @private
       */},{key:'_addBodyHandler',value:function _addBodyHandler(){var $body=$(document.body).not(this.$element),_this=this;$body.off('click.zf.dropdown').on('click.zf.dropdown',function(e){if(_this.$anchor.is(e.target)||_this.$anchor.find(e.target).length){return;}if(_this.$element.find(e.target).length){return;}_this.close();$body.off('click.zf.dropdown');});}/**
       * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.
       * @function
       * @fires Dropdown#closeme
       * @fires Dropdown#show
       */},{key:'open',value:function open(){// var _this = this;
/**
         * Fires to close other open dropdowns
         * @event Dropdown#closeme
         */this.$element.trigger('closeme.zf.dropdown',this.$element.attr('id'));this.$anchor.addClass('hover').attr({'aria-expanded':true});// this.$element/*.show()*/;
this._setPosition();this.$element.addClass('is-open').attr({'aria-hidden':false});if(this.options.autoFocus){var $focusable=Foundation.Keyboard.findFocusable(this.$element);if($focusable.length){$focusable.eq(0).focus();}}if(this.options.closeOnClick){this._addBodyHandler();}/**
         * Fires once the dropdown is visible.
         * @event Dropdown#show
         */this.$element.trigger('show.zf.dropdown',[this.$element]);}/**
       * Closes the open dropdown pane.
       * @function
       * @fires Dropdown#hide
       */},{key:'close',value:function close(){if(!this.$element.hasClass('is-open')){return false;}this.$element.removeClass('is-open').attr({'aria-hidden':true});this.$anchor.removeClass('hover').attr('aria-expanded',false);if(this.classChanged){var curPositionClass=this.getPositionClass();if(curPositionClass){this.$element.removeClass(curPositionClass);}this.$element.addClass(this.options.positionClass)/*.hide()*/.css({height:'',width:''});this.classChanged=false;this.counter=4;this.usedPositions.length=0;}this.$element.trigger('hide.zf.dropdown',[this.$element]);}/**
       * Toggles the dropdown pane's visibility.
       * @function
       */},{key:'toggle',value:function toggle(){if(this.$element.hasClass('is-open')){if(this.$anchor.data('hover'))return;this.close();}else{this.open();}}/**
       * Destroys the dropdown.
       * @function
       */},{key:'destroy',value:function destroy(){this.$element.off('.zf.trigger').hide();this.$anchor.off('.zf.dropdown');Foundation.unregisterPlugin(this);}}]);return Dropdown;}();Dropdown.defaults={/**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 250
     */hoverDelay:250,/**
     * Allow submenus to open on hover events
     * @option
     * @example false
     */hover:false,/**
     * Don't close dropdown when hovering over dropdown pane
     * @option
     * @example true
     */hoverPane:false,/**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */vOffset:1,/**
     * Number of pixels between the dropdown pane and the triggering element on open.
     * @option
     * @example 1
     */hOffset:1,/**
     * Class applied to adjust open position. JS will test and fill this in.
     * @option
     * @example 'top'
     */positionClass:'',/**
     * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.
     * @option
     * @example false
     */trapFocus:false,/**
     * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.
     * @option
     * @example true
     */autoFocus:false,/**
     * Allows a click on the body to close the dropdown.
     * @option
     * @example false
     */closeOnClick:false};// Window exports
Foundation.plugin(Dropdown,'Dropdown');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * DropdownMenu module.
   * @module foundation.dropdown-menu
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.nest
   */var DropdownMenu=function(){/**
     * Creates a new instance of DropdownMenu.
     * @class
     * @fires DropdownMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */function DropdownMenu(element,options){_classCallCheck(this,DropdownMenu);this.$element=element;this.options=$.extend({},DropdownMenu.defaults,this.$element.data(),options);Foundation.Nest.Feather(this.$element,'dropdown');this._init();Foundation.registerPlugin(this,'DropdownMenu');Foundation.Keyboard.register('DropdownMenu',{'ENTER':'open','SPACE':'open','ARROW_RIGHT':'next','ARROW_UP':'up','ARROW_DOWN':'down','ARROW_LEFT':'previous','ESCAPE':'close'});}/**
     * Initializes the plugin, and calls _prepareMenu
     * @private
     * @function
     */_createClass(DropdownMenu,[{key:'_init',value:function _init(){var subs=this.$element.find('li.is-dropdown-submenu-parent');this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');this.$menuItems=this.$element.find('[role="menuitem"]');this.$tabs=this.$element.children('[role="menuitem"]');this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);if(this.$element.hasClass(this.options.rightClass)||this.options.alignment==='right'||Foundation.rtl()||this.$element.parents('.top-bar-right').is('*')){this.options.alignment='right';subs.addClass('opens-left');}else{subs.addClass('opens-right');}this.changed=false;this._events();}},{key:'_events',/**
       * Adds event listeners to elements within the menu
       * @private
       * @function
       */value:function _events(){var _this=this,hasTouch='ontouchstart'in window||typeof window.ontouchstart!=='undefined',parClass='is-dropdown-submenu-parent';// used for onClick and in the keyboard handlers
var handleClickFn=function handleClickFn(e){var $elem=$(e.target).parentsUntil('ul','.'+parClass),hasSub=$elem.hasClass(parClass),hasClicked=$elem.attr('data-is-click')==='true',$sub=$elem.children('.is-dropdown-submenu');if(hasSub){if(hasClicked){if(!_this.options.closeOnClick||!_this.options.clickOpen&&!hasTouch||_this.options.forceFollow&&hasTouch){return;}else{e.stopImmediatePropagation();e.preventDefault();_this._hide($elem);}}else{e.preventDefault();e.stopImmediatePropagation();_this._show($elem.children('.is-dropdown-submenu'));$elem.add($elem.parentsUntil(_this.$element,'.'+parClass)).attr('data-is-click',true);}}else{return;}};if(this.options.clickOpen||hasTouch){this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu',handleClickFn);}if(!this.options.disableHover){this.$menuItems.on('mouseenter.zf.dropdownmenu',function(e){var $elem=$(this),hasSub=$elem.hasClass(parClass);if(hasSub){clearTimeout(_this.delay);_this.delay=setTimeout(function(){_this._show($elem.children('.is-dropdown-submenu'));},_this.options.hoverDelay);}}).on('mouseleave.zf.dropdownmenu',function(e){var $elem=$(this),hasSub=$elem.hasClass(parClass);if(hasSub&&_this.options.autoclose){if($elem.attr('data-is-click')==='true'&&_this.options.clickOpen){return false;}clearTimeout(_this.delay);_this.delay=setTimeout(function(){_this._hide($elem);},_this.options.closingTime);}});}this.$menuItems.on('keydown.zf.dropdownmenu',function(e){var $element=$(e.target).parentsUntil('ul','[role="menuitem"]'),isTab=_this.$tabs.index($element)>-1,$elements=isTab?_this.$tabs:$element.siblings('li').add($element),$prevElement,$nextElement;$elements.each(function(i){if($(this).is($element)){$prevElement=$elements.eq(i-1);$nextElement=$elements.eq(i+1);return;}});var nextSibling=function nextSibling(){if(!$element.is(':last-child')){$nextElement.children('a:first').focus();e.preventDefault();}},prevSibling=function prevSibling(){$prevElement.children('a:first').focus();e.preventDefault();},openSub=function openSub(){var $sub=$element.children('ul.is-dropdown-submenu');if($sub.length){_this._show($sub);$element.find('li > a:first').focus();e.preventDefault();}else{return;}},closeSub=function closeSub(){//if ($element.is(':first-child')) {
var close=$element.parent('ul').parent('li');close.children('a:first').focus();_this._hide(close);e.preventDefault();//}
};var functions={open:openSub,close:function close(){_this._hide(_this.$element);_this.$menuItems.find('a:first').focus();// focus to first element
e.preventDefault();},handled:function handled(){e.stopImmediatePropagation();}};if(isTab){if(_this.$element.hasClass(_this.options.verticalClass)){// vertical menu
if(_this.options.alignment==='left'){// left aligned
$.extend(functions,{down:nextSibling,up:prevSibling,next:openSub,previous:closeSub});}else{// right aligned
$.extend(functions,{down:nextSibling,up:prevSibling,next:closeSub,previous:openSub});}}else{// horizontal menu
$.extend(functions,{next:nextSibling,previous:prevSibling,down:openSub,up:closeSub});}}else{// not tabs -> one sub
if(_this.options.alignment==='left'){// left aligned
$.extend(functions,{next:openSub,previous:closeSub,down:nextSibling,up:prevSibling});}else{// right aligned
$.extend(functions,{next:closeSub,previous:openSub,down:nextSibling,up:prevSibling});}}Foundation.Keyboard.handleKey(e,'DropdownMenu',functions);});}/**
       * Adds an event handler to the body to close any dropdowns on a click.
       * @function
       * @private
       */},{key:'_addBodyHandler',value:function _addBodyHandler(){var $body=$(document.body),_this=this;$body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu',function(e){var $link=_this.$element.find(e.target);if($link.length){return;}_this._hide();$body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');});}/**
       * Opens a dropdown pane, and checks for collisions first.
       * @param {jQuery} $sub - ul element that is a submenu to show
       * @function
       * @private
       * @fires DropdownMenu#show
       */},{key:'_show',value:function _show($sub){var idx=this.$tabs.index(this.$tabs.filter(function(i,el){return $(el).find($sub).length>0;}));var $sibs=$sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');this._hide($sibs,idx);$sub.css('visibility','hidden').addClass('js-dropdown-active').attr({'aria-hidden':false}).parent('li.is-dropdown-submenu-parent').addClass('is-active').attr({'aria-expanded':true});var clear=Foundation.Box.ImNotTouchingYou($sub,null,true);if(!clear){var oldClass=this.options.alignment==='left'?'-right':'-left',$parentLi=$sub.parent('.is-dropdown-submenu-parent');$parentLi.removeClass('opens'+oldClass).addClass('opens-'+this.options.alignment);clear=Foundation.Box.ImNotTouchingYou($sub,null,true);if(!clear){$parentLi.removeClass('opens-'+this.options.alignment).addClass('opens-inner');}this.changed=true;}$sub.css('visibility','');if(this.options.closeOnClick){this._addBodyHandler();}/**
         * Fires when the new dropdown pane is visible.
         * @event DropdownMenu#show
         */this.$element.trigger('show.zf.dropdownmenu',[$sub]);}/**
       * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.
       * @function
       * @param {jQuery} $elem - element with a submenu to hide
       * @param {Number} idx - index of the $tabs collection to hide
       * @private
       */},{key:'_hide',value:function _hide($elem,idx){var $toClose;if($elem&&$elem.length){$toClose=$elem;}else if(idx!==undefined){$toClose=this.$tabs.not(function(i,el){return i===idx;});}else{$toClose=this.$element;}var somethingToClose=$toClose.hasClass('is-active')||$toClose.find('.is-active').length>0;if(somethingToClose){$toClose.find('li.is-active').add($toClose).attr({'aria-expanded':false,'data-is-click':false}).removeClass('is-active');$toClose.find('ul.js-dropdown-active').attr({'aria-hidden':true}).removeClass('js-dropdown-active');if(this.changed||$toClose.find('opens-inner').length){var oldClass=this.options.alignment==='left'?'right':'left';$toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-'+this.options.alignment).addClass('opens-'+oldClass);this.changed=false;}/**
           * Fires when the open menus are closed.
           * @event DropdownMenu#hide
           */this.$element.trigger('hide.zf.dropdownmenu',[$toClose]);}}/**
       * Destroys the plugin.
       * @function
       */},{key:'destroy',value:function destroy(){this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');$(document.body).off('.zf.dropdownmenu');Foundation.Nest.Burn(this.$element,'dropdown');Foundation.unregisterPlugin(this);}}]);return DropdownMenu;}();/**
   * Default settings for plugin
   */DropdownMenu.defaults={/**
     * Disallows hover events from opening submenus
     * @option
     * @example false
     */disableHover:false,/**
     * Allow a submenu to automatically close on a mouseleave event, if not clicked open.
     * @option
     * @example true
     */autoclose:true,/**
     * Amount of time to delay opening a submenu on hover event.
     * @option
     * @example 50
     */hoverDelay:50,/**
     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.
     * @option
     * @example true
     */clickOpen:false,/**
     * Amount of time to delay closing a submenu on a mouseleave event.
     * @option
     * @example 500
     */closingTime:500,/**
     * Position of the menu relative to what direction the submenus should open. Handled by JS.
     * @option
     * @example 'left'
     */alignment:'left',/**
     * Allow clicks on the body to close any open submenus.
     * @option
     * @example true
     */closeOnClick:true,/**
     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.
     * @option
     * @example 'vertical'
     */verticalClass:'vertical',/**
     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.
     * @option
     * @example 'align-right'
     */rightClass:'align-right',/**
     * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.
     * @option
     * @example false
     */forceFollow:true};// Window exports
Foundation.plugin(DropdownMenu,'DropdownMenu');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Equalizer module.
   * @module foundation.equalizer
   */var Equalizer=function(){/**
     * Creates a new instance of Equalizer.
     * @class
     * @fires Equalizer#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Equalizer(element,options){_classCallCheck(this,Equalizer);this.$element=element;this.options=$.extend({},Equalizer.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Equalizer');}/**
     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.
     * @private
     */_createClass(Equalizer,[{key:'_init',value:function _init(){var eqId=this.$element.attr('data-equalizer')||'';var $watched=this.$element.find('[data-equalizer-watch="'+eqId+'"]');this.$watched=$watched.length?$watched:this.$element.find('[data-equalizer-watch]');this.$element.attr('data-resize',eqId||Foundation.GetYoDigits(6,'eq'));this.hasNested=this.$element.find('[data-equalizer]').length>0;this.isNested=this.$element.parentsUntil(document.body,'[data-equalizer]').length>0;this.isOn=false;this._bindHandler={onResizeMeBound:this._onResizeMe.bind(this),onPostEqualizedBound:this._onPostEqualized.bind(this)};var imgs=this.$element.find('img');var tooSmall;if(this.options.equalizeOn){tooSmall=this._checkMQ();$(window).on('changed.zf.mediaquery',this._checkMQ.bind(this));}else{this._events();}if(tooSmall!==undefined&&tooSmall===false||tooSmall===undefined){if(imgs.length){Foundation.onImagesLoaded(imgs,this._reflow.bind(this));}else{this._reflow();}}}/**
       * Removes event listeners if the breakpoint is too small.
       * @private
       */},{key:'_pauseEvents',value:function _pauseEvents(){this.isOn=false;this.$element.off({'.zf.equalizer':this._bindHandler.onPostEqualizedBound,'resizeme.zf.trigger':this._bindHandler.onResizeMeBound});}/**
       * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound
       * @private
       */},{key:'_onResizeMe',value:function _onResizeMe(e){this._reflow();}/**
       * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound
       * @private
       */},{key:'_onPostEqualized',value:function _onPostEqualized(e){if(e.target!==this.$element[0]){this._reflow();}}/**
       * Initializes events for Equalizer.
       * @private
       */},{key:'_events',value:function _events(){var _this=this;this._pauseEvents();if(this.hasNested){this.$element.on('postequalized.zf.equalizer',this._bindHandler.onPostEqualizedBound);}else{this.$element.on('resizeme.zf.trigger',this._bindHandler.onResizeMeBound);}this.isOn=true;}/**
       * Checks the current breakpoint to the minimum required size.
       * @private
       */},{key:'_checkMQ',value:function _checkMQ(){var tooSmall=!Foundation.MediaQuery.atLeast(this.options.equalizeOn);if(tooSmall){if(this.isOn){this._pauseEvents();this.$watched.css('height','auto');}}else{if(!this.isOn){this._events();}}return tooSmall;}/**
       * A noop version for the plugin
       * @private
       */},{key:'_killswitch',value:function _killswitch(){return;}/**
       * Calls necessary functions to update Equalizer upon DOM change
       * @private
       */},{key:'_reflow',value:function _reflow(){if(!this.options.equalizeOnStack){if(this._isStacked()){this.$watched.css('height','auto');return false;}}if(this.options.equalizeByRow){this.getHeightsByRow(this.applyHeightByRow.bind(this));}else{this.getHeights(this.applyHeight.bind(this));}}/**
       * Manually determines if the first 2 elements are *NOT* stacked.
       * @private
       */},{key:'_isStacked',value:function _isStacked(){return this.$watched[0].getBoundingClientRect().top!==this.$watched[1].getBoundingClientRect().top;}/**
       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
       * @param {Function} cb - A non-optional callback to return the heights array to.
       * @returns {Array} heights - An array of heights of children within Equalizer container
       */},{key:'getHeights',value:function getHeights(cb){var heights=[];for(var i=0,len=this.$watched.length;i<len;i++){this.$watched[i].style.height='auto';heights.push(this.$watched[i].offsetHeight);}cb(heights);}/**
       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array
       * @param {Function} cb - A non-optional callback to return the heights array to.
       * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
       */},{key:'getHeightsByRow',value:function getHeightsByRow(cb){var lastElTopOffset=this.$watched.length?this.$watched.first().offset().top:0,groups=[],group=0;//group by Row
groups[group]=[];for(var i=0,len=this.$watched.length;i<len;i++){this.$watched[i].style.height='auto';//maybe could use this.$watched[i].offsetTop
var elOffsetTop=$(this.$watched[i]).offset().top;if(elOffsetTop!=lastElTopOffset){group++;groups[group]=[];lastElTopOffset=elOffsetTop;}groups[group].push([this.$watched[i],this.$watched[i].offsetHeight]);}for(var j=0,ln=groups.length;j<ln;j++){var heights=$(groups[j]).map(function(){return this[1];}).get();var max=Math.max.apply(null,heights);groups[j].push(max);}cb(groups);}/**
       * Changes the CSS height property of each child in an Equalizer parent to match the tallest
       * @param {array} heights - An array of heights of children within Equalizer container
       * @fires Equalizer#preequalized
       * @fires Equalizer#postequalized
       */},{key:'applyHeight',value:function applyHeight(heights){var max=Math.max.apply(null,heights);/**
         * Fires before the heights are applied
         * @event Equalizer#preequalized
         */this.$element.trigger('preequalized.zf.equalizer');this.$watched.css('height',max);/**
         * Fires when the heights have been applied
         * @event Equalizer#postequalized
         */this.$element.trigger('postequalized.zf.equalizer');}/**
       * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row
       * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child
       * @fires Equalizer#preequalized
       * @fires Equalizer#preequalizedRow
       * @fires Equalizer#postequalizedRow
       * @fires Equalizer#postequalized
       */},{key:'applyHeightByRow',value:function applyHeightByRow(groups){/**
         * Fires before the heights are applied
         */this.$element.trigger('preequalized.zf.equalizer');for(var i=0,len=groups.length;i<len;i++){var groupsILength=groups[i].length,max=groups[i][groupsILength-1];if(groupsILength<=2){$(groups[i][0][0]).css({'height':'auto'});continue;}/**
            * Fires before the heights per row are applied
            * @event Equalizer#preequalizedRow
            */this.$element.trigger('preequalizedrow.zf.equalizer');for(var j=0,lenJ=groupsILength-1;j<lenJ;j++){$(groups[i][j][0]).css({'height':max});}/**
            * Fires when the heights per row have been applied
            * @event Equalizer#postequalizedRow
            */this.$element.trigger('postequalizedrow.zf.equalizer');}/**
         * Fires when the heights have been applied
         */this.$element.trigger('postequalized.zf.equalizer');}/**
       * Destroys an instance of Equalizer.
       * @function
       */},{key:'destroy',value:function destroy(){this._pauseEvents();this.$watched.css('height','auto');Foundation.unregisterPlugin(this);}}]);return Equalizer;}();/**
   * Default settings for plugin
   */Equalizer.defaults={/**
     * Enable height equalization when stacked on smaller screens.
     * @option
     * @example true
     */equalizeOnStack:true,/**
     * Enable height equalization row by row.
     * @option
     * @example false
     */equalizeByRow:false,/**
     * String representing the minimum breakpoint size the plugin should equalize heights on.
     * @option
     * @example 'medium'
     */equalizeOn:''};// Window exports
Foundation.plugin(Equalizer,'Equalizer');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Interchange module.
   * @module foundation.interchange
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.timerAndImageLoader
   */var Interchange=function(){/**
     * Creates a new instance of Interchange.
     * @class
     * @fires Interchange#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Interchange(element,options){_classCallCheck(this,Interchange);this.$element=element;this.options=$.extend({},Interchange.defaults,options);this.rules=[];this.currentPath='';this._init();this._events();Foundation.registerPlugin(this,'Interchange');}/**
     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.
     * @function
     * @private
     */_createClass(Interchange,[{key:'_init',value:function _init(){this._addBreakpoints();this._generateRules();this._reflow();}/**
       * Initializes events for Interchange.
       * @function
       * @private
       */},{key:'_events',value:function _events(){$(window).on('resize.zf.interchange',Foundation.util.throttle(this._reflow.bind(this),50));}/**
       * Calls necessary functions to update Interchange upon DOM change
       * @function
       * @private
       */},{key:'_reflow',value:function _reflow(){var match;// Iterate through each rule, but only save the last match
for(var i in this.rules){if(this.rules.hasOwnProperty(i)){var rule=this.rules[i];if(window.matchMedia(rule.query).matches){match=rule;}}}if(match){this.replace(match.path);}}/**
       * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.
       * @function
       * @private
       */},{key:'_addBreakpoints',value:function _addBreakpoints(){for(var i in Foundation.MediaQuery.queries){if(Foundation.MediaQuery.queries.hasOwnProperty(i)){var query=Foundation.MediaQuery.queries[i];Interchange.SPECIAL_QUERIES[query.name]=query.value;}}}/**
       * Checks the Interchange element for the provided media query + content pairings
       * @function
       * @private
       * @param {Object} element - jQuery object that is an Interchange instance
       * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys
       */},{key:'_generateRules',value:function _generateRules(element){var rulesList=[];var rules;if(this.options.rules){rules=this.options.rules;}else{rules=this.$element.data('interchange').match(/\[.*?\]/g);}for(var i in rules){if(rules.hasOwnProperty(i)){var rule=rules[i].slice(1,-1).split(', ');var path=rule.slice(0,-1).join('');var query=rule[rule.length-1];if(Interchange.SPECIAL_QUERIES[query]){query=Interchange.SPECIAL_QUERIES[query];}rulesList.push({path:path,query:query});}}this.rules=rulesList;}/**
       * Update the `src` property of an image, or change the HTML of a container, to the specified path.
       * @function
       * @param {String} path - Path to the image or HTML partial.
       * @fires Interchange#replaced
       */},{key:'replace',value:function replace(path){if(this.currentPath===path)return;var _this=this,trigger='replaced.zf.interchange';// Replacing images
if(this.$element[0].nodeName==='IMG'){this.$element.attr('src',path).load(function(){_this.currentPath=path;}).trigger(trigger);}// Replacing background images
else if(path.match(/\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)){this.$element.css({'background-image':'url('+path+')'}).trigger(trigger);}// Replacing HTML
else{$.get(path,function(response){_this.$element.html(response).trigger(trigger);$(response).foundation();_this.currentPath=path;});}/**
         * Fires when content in an Interchange element is done being loaded.
         * @event Interchange#replaced
         */// this.$element.trigger('replaced.zf.interchange');
}/**
       * Destroys an instance of interchange.
       * @function
       */},{key:'destroy',value:function destroy(){//TODO this.
}}]);return Interchange;}();/**
   * Default settings for plugin
   */Interchange.defaults={/**
     * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.
     * @option
     */rules:null};Interchange.SPECIAL_QUERIES={'landscape':'screen and (orientation: landscape)','portrait':'screen and (orientation: portrait)','retina':'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'};// Window exports
Foundation.plugin(Interchange,'Interchange');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Magellan module.
   * @module foundation.magellan
   */var Magellan=function(){/**
     * Creates a new instance of Magellan.
     * @class
     * @fires Magellan#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Magellan(element,options){_classCallCheck(this,Magellan);this.$element=element;this.options=$.extend({},Magellan.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Magellan');}/**
     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.
     * @private
     */_createClass(Magellan,[{key:'_init',value:function _init(){var id=this.$element[0].id||Foundation.GetYoDigits(6,'magellan');var _this=this;this.$targets=$('[data-magellan-target]');this.$links=this.$element.find('a');this.$element.attr({'data-resize':id,'data-scroll':id,'id':id});this.$active=$();this.scrollPos=parseInt(window.pageYOffset,10);this._events();}/**
       * Calculates an array of pixel values that are the demarcation lines between locations on the page.
       * Can be invoked if new elements are added or the size of a location changes.
       * @function
       */},{key:'calcPoints',value:function calcPoints(){var _this=this,body=document.body,html=document.documentElement;this.points=[];this.winHeight=Math.round(Math.max(window.innerHeight,html.clientHeight));this.docHeight=Math.round(Math.max(body.scrollHeight,body.offsetHeight,html.clientHeight,html.scrollHeight,html.offsetHeight));this.$targets.each(function(){var $tar=$(this),pt=Math.round($tar.offset().top-_this.options.threshold);$tar.targetPoint=pt;_this.points.push(pt);});}/**
       * Initializes events for Magellan.
       * @private
       */},{key:'_events',value:function _events(){var _this=this,$body=$('html, body'),opts={duration:_this.options.animationDuration,easing:_this.options.animationEasing};$(window).one('load',function(){if(_this.options.deepLinking){if(location.hash){_this.scrollToLoc(location.hash);}}_this.calcPoints();_this._updateActive();});this.$element.on({'resizeme.zf.trigger':this.reflow.bind(this),'scrollme.zf.trigger':this._updateActive.bind(this)}).on('click.zf.magellan','a[href^="#"]',function(e){e.preventDefault();var arrival=this.getAttribute('href');_this.scrollToLoc(arrival);});}/**
       * Function to scroll to a given location on the page.
       * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'
       * @function
       */},{key:'scrollToLoc',value:function scrollToLoc(loc){var scrollPos=Math.round($(loc).offset().top-this.options.threshold/2-this.options.barOffset);$('html, body').stop(true).animate({scrollTop:scrollPos},this.options.animationDuration,this.options.animationEasing);}/**
       * Calls necessary functions to update Magellan upon DOM change
       * @function
       */},{key:'reflow',value:function reflow(){this.calcPoints();this._updateActive();}/**
       * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.
       * @private
       * @function
       * @fires Magellan#update
       */},{key:'_updateActive',value:function _updateActive()/*evt, elem, scrollPos*/{var winPos=/*scrollPos ||*/parseInt(window.pageYOffset,10),curIdx;if(winPos+this.winHeight===this.docHeight){curIdx=this.points.length-1;}else if(winPos<this.points[0]){curIdx=0;}else{var isDown=this.scrollPos<winPos,_this=this,curVisible=this.points.filter(function(p,i){return isDown?p-_this.options.barOffset<=winPos:p-_this.options.barOffset-_this.options.threshold<=winPos;});curIdx=curVisible.length?curVisible.length-1:0;}this.$active.removeClass(this.options.activeClass);this.$active=this.$links.eq(curIdx).addClass(this.options.activeClass);if(this.options.deepLinking){var hash=this.$active[0].getAttribute('href');if(window.history.pushState){window.history.pushState(null,null,hash);}else{window.location.hash=hash;}}this.scrollPos=winPos;/**
         * Fires when magellan is finished updating to the new active element.
         * @event Magellan#update
         */this.$element.trigger('update.zf.magellan',[this.$active]);}/**
       * Destroys an instance of Magellan and resets the url of the window.
       * @function
       */},{key:'destroy',value:function destroy(){this.$element.off('.zf.trigger .zf.magellan').find('.'+this.options.activeClass).removeClass(this.options.activeClass);if(this.options.deepLinking){var hash=this.$active[0].getAttribute('href');window.location.hash.replace(hash,'');}Foundation.unregisterPlugin(this);}}]);return Magellan;}();/**
   * Default settings for plugin
   */Magellan.defaults={/**
     * Amount of time, in ms, the animated scrolling should take between locations.
     * @option
     * @example 500
     */animationDuration:500,/**
     * Animation style to use when scrolling between locations.
     * @option
     * @example 'ease-in-out'
     */animationEasing:'linear',/**
     * Number of pixels to use as a marker for location changes.
     * @option
     * @example 50
     */threshold:50,/**
     * Class applied to the active locations link on the magellan container.
     * @option
     * @example 'active'
     */activeClass:'active',/**
     * Allows the script to manipulate the url of the current page, and if supported, alter the history.
     * @option
     * @example true
     */deepLinking:false,/**
     * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.
     * @option
     * @example 25
     */barOffset:0};// Window exports
Foundation.plugin(Magellan,'Magellan');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * OffCanvas module.
   * @module foundation.offcanvas
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.triggers
   * @requires foundation.util.motion
   */var OffCanvas=function(){/**
     * Creates a new instance of an off-canvas wrapper.
     * @class
     * @fires OffCanvas#init
     * @param {Object} element - jQuery object to initialize.
     * @param {Object} options - Overrides to the default plugin settings.
     */function OffCanvas(element,options){_classCallCheck(this,OffCanvas);this.$element=element;this.options=$.extend({},OffCanvas.defaults,this.$element.data(),options);this.$lastTrigger=$();this.$triggers=$();this._init();this._events();Foundation.registerPlugin(this,'OffCanvas');}/**
     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).
     * @function
     * @private
     */_createClass(OffCanvas,[{key:'_init',value:function _init(){var id=this.$element.attr('id');this.$element.attr('aria-hidden','true');// Find triggers that affect this element and add aria-expanded to them
this.$triggers=$(document).find('[data-open="'+id+'"], [data-close="'+id+'"], [data-toggle="'+id+'"]').attr('aria-expanded','false').attr('aria-controls',id);// Add a close trigger over the body if necessary
if(this.options.closeOnClick){if($('.js-off-canvas-exit').length){this.$exiter=$('.js-off-canvas-exit');}else{var exiter=document.createElement('div');exiter.setAttribute('class','js-off-canvas-exit');$('[data-off-canvas-content]').append(exiter);this.$exiter=$(exiter);}}this.options.isRevealed=this.options.isRevealed||new RegExp(this.options.revealClass,'g').test(this.$element[0].className);if(this.options.isRevealed){this.options.revealOn=this.options.revealOn||this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];this._setMQChecker();}if(!this.options.transitionTime){this.options.transitionTime=parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration)*1000;}}/**
       * Adds event handlers to the off-canvas wrapper and the exit overlay.
       * @function
       * @private
       */},{key:'_events',value:function _events(){this.$element.off('.zf.trigger .zf.offcanvas').on({'open.zf.trigger':this.open.bind(this),'close.zf.trigger':this.close.bind(this),'toggle.zf.trigger':this.toggle.bind(this),'keydown.zf.offcanvas':this._handleKeyboard.bind(this)});if(this.options.closeOnClick&&this.$exiter.length){this.$exiter.on({'click.zf.offcanvas':this.close.bind(this)});}}/**
       * Applies event listener for elements that will reveal at certain breakpoints.
       * @private
       */},{key:'_setMQChecker',value:function _setMQChecker(){var _this=this;$(window).on('changed.zf.mediaquery',function(){if(Foundation.MediaQuery.atLeast(_this.options.revealOn)){_this.reveal(true);}else{_this.reveal(false);}}).one('load.zf.offcanvas',function(){if(Foundation.MediaQuery.atLeast(_this.options.revealOn)){_this.reveal(true);}});}/**
       * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.
       * @param {Boolean} isRevealed - true if element should be revealed.
       * @function
       */},{key:'reveal',value:function reveal(isRevealed){var $closer=this.$element.find('[data-close]');if(isRevealed){this.close();this.isRevealed=true;// if (!this.options.forceTop) {
//   var scrollPos = parseInt(window.pageYOffset);
//   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
// }
// if (this.options.isSticky) { this._stick(); }
this.$element.off('open.zf.trigger toggle.zf.trigger');if($closer.length){$closer.hide();}}else{this.isRevealed=false;// if (this.options.isSticky || !this.options.forceTop) {
//   this.$element[0].style.transform = '';
//   $(window).off('scroll.zf.offcanvas');
// }
this.$element.on({'open.zf.trigger':this.open.bind(this),'toggle.zf.trigger':this.toggle.bind(this)});if($closer.length){$closer.show();}}}/**
       * Opens the off-canvas menu.
       * @function
       * @param {Object} event - Event object passed from listener.
       * @param {jQuery} trigger - element that triggered the off-canvas to open.
       * @fires OffCanvas#opened
       */},{key:'open',value:function open(event,trigger){if(this.$element.hasClass('is-open')||this.isRevealed){return;}var _this=this,$body=$(document.body);if(this.options.forceTop){$('body').scrollTop(0);}// window.pageYOffset = 0;
// if (!this.options.forceTop) {
//   var scrollPos = parseInt(window.pageYOffset);
//   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';
//   if (this.$exiter.length) {
//     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';
//   }
// }
/**
         * Fires when the off-canvas menu opens.
         * @event OffCanvas#opened
         */Foundation.Move(this.options.transitionTime,this.$element,function(){$('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-'+_this.options.position);_this.$element.addClass('is-open');// if (_this.options.isSticky) {
//   _this._stick();
// }
});this.$triggers.attr('aria-expanded','true');this.$element.attr('aria-hidden','false').trigger('opened.zf.offcanvas');if(this.options.closeOnClick){this.$exiter.addClass('is-visible');}if(trigger){this.$lastTrigger=trigger;}if(this.options.autoFocus){this.$element.one(Foundation.transitionend(this.$element),function(){_this.$element.find('a, button').eq(0).focus();});}if(this.options.trapFocus){$('[data-off-canvas-content]').attr('tabindex','-1');this._trapFocus();}}/**
       * Traps focus within the offcanvas on open.
       * @private
       */},{key:'_trapFocus',value:function _trapFocus(){var focusable=Foundation.Keyboard.findFocusable(this.$element),first=focusable.eq(0),last=focusable.eq(-1);focusable.off('.zf.offcanvas').on('keydown.zf.offcanvas',function(e){if(e.which===9||e.keycode===9){if(e.target===last[0]&&!e.shiftKey){e.preventDefault();first.focus();}if(e.target===first[0]&&e.shiftKey){e.preventDefault();last.focus();}}});}/**
       * Allows the offcanvas to appear sticky utilizing translate properties.
       * @private
       */// OffCanvas.prototype._stick = function() {
//   var elStyle = this.$element[0].style;
//
//   if (this.options.closeOnClick) {
//     var exitStyle = this.$exiter[0].style;
//   }
//
//   $(window).on('scroll.zf.offcanvas', function(e) {
//     console.log(e);
//     var pageY = window.pageYOffset;
//     elStyle.transform = 'translate(0,' + pageY + 'px)';
//     if (exitStyle !== undefined) { exitStyle.transform = 'translate(0,' + pageY + 'px)'; }
//   });
//   // this.$element.trigger('stuck.zf.offcanvas');
// };
/**
       * Closes the off-canvas menu.
       * @function
       * @param {Function} cb - optional cb to fire after closure.
       * @fires OffCanvas#closed
       */},{key:'close',value:function close(cb){if(!this.$element.hasClass('is-open')||this.isRevealed){return;}var _this=this;//  Foundation.Move(this.options.transitionTime, this.$element, function() {
$('[data-off-canvas-wrapper]').removeClass('is-off-canvas-open is-open-'+_this.options.position);_this.$element.removeClass('is-open');// Foundation._reflow();
// });
this.$element.attr('aria-hidden','true')/**
         * Fires when the off-canvas menu opens.
         * @event OffCanvas#closed
         */.trigger('closed.zf.offcanvas');// if (_this.options.isSticky || !_this.options.forceTop) {
//   setTimeout(function() {
//     _this.$element[0].style.transform = '';
//     $(window).off('scroll.zf.offcanvas');
//   }, this.options.transitionTime);
// }
if(this.options.closeOnClick){this.$exiter.removeClass('is-visible');}this.$triggers.attr('aria-expanded','false');if(this.options.trapFocus){$('[data-off-canvas-content]').removeAttr('tabindex');}}/**
       * Toggles the off-canvas menu open or closed.
       * @function
       * @param {Object} event - Event object passed from listener.
       * @param {jQuery} trigger - element that triggered the off-canvas to open.
       */},{key:'toggle',value:function toggle(event,trigger){if(this.$element.hasClass('is-open')){this.close(event,trigger);}else{this.open(event,trigger);}}/**
       * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.
       * @function
       * @private
       */},{key:'_handleKeyboard',value:function _handleKeyboard(event){if(event.which!==27)return;event.stopPropagation();event.preventDefault();this.close();this.$lastTrigger.focus();}/**
       * Destroys the offcanvas plugin.
       * @function
       */},{key:'destroy',value:function destroy(){this.close();this.$element.off('.zf.trigger .zf.offcanvas');this.$exiter.off('.zf.offcanvas');Foundation.unregisterPlugin(this);}}]);return OffCanvas;}();OffCanvas.defaults={/**
     * Allow the user to click outside of the menu to close it.
     * @option
     * @example true
     */closeOnClick:true,/**
     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.
     * @option
     * @example 500
     */transitionTime:0,/**
     * Direction the offcanvas opens from. Determines class applied to body.
     * @option
     * @example left
     */position:'left',/**
     * Force the page to scroll to top on open.
     * @option
     * @example true
     */forceTop:true,/**
     * Allow the offcanvas to remain open for certain breakpoints.
     * @option
     * @example false
     */isRevealed:false,/**
     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.
     * @option
     * @example reveal-for-large
     */revealOn:null,/**
     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.
     * @option
     * @example true
     */autoFocus:true,/**
     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.
     * @option
     * TODO improve the regex testing for this.
     * @example reveal-for-large
     */revealClass:'reveal-for-',/**
     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.
     * @option
     * @example true
     */trapFocus:false};// Window exports
Foundation.plugin(OffCanvas,'OffCanvas');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Orbit module.
   * @module foundation.orbit
   * @requires foundation.util.keyboard
   * @requires foundation.util.motion
   * @requires foundation.util.timerAndImageLoader
   * @requires foundation.util.touch
   */var Orbit=function(){/**
    * Creates a new instance of an orbit carousel.
    * @class
    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.
    * @param {Object} options - Overrides to the default plugin settings.
    */function Orbit(element,options){_classCallCheck(this,Orbit);this.$element=element;this.options=$.extend({},Orbit.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Orbit');Foundation.Keyboard.register('Orbit',{'ltr':{'ARROW_RIGHT':'next','ARROW_LEFT':'previous'},'rtl':{'ARROW_LEFT':'next','ARROW_RIGHT':'previous'}});}/**
    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.
    * @function
    * @private
    */_createClass(Orbit,[{key:'_init',value:function _init(){this.$wrapper=this.$element.find('.'+this.options.containerClass);this.$slides=this.$element.find('.'+this.options.slideClass);var $images=this.$element.find('img'),initActive=this.$slides.filter('.is-active');if(!initActive.length){this.$slides.eq(0).addClass('is-active');}if(!this.options.useMUI){this.$slides.addClass('no-motionui');}if($images.length){Foundation.onImagesLoaded($images,this._prepareForOrbit.bind(this));}else{this._prepareForOrbit();//hehe
}if(this.options.bullets){this._loadBullets();}this._events();if(this.options.autoPlay&&this.$slides.length>1){this.geoSync();}if(this.options.accessible){// allow wrapper to be focusable to enable arrow navigation
this.$wrapper.attr('tabindex',0);}}/**
      * Creates a jQuery collection of bullets, if they are being used.
      * @function
      * @private
      */},{key:'_loadBullets',value:function _loadBullets(){this.$bullets=this.$element.find('.'+this.options.boxOfBullets).find('button');}/**
      * Sets a `timer` object on the orbit, and starts the counter for the next slide.
      * @function
      */},{key:'geoSync',value:function geoSync(){var _this=this;this.timer=new Foundation.Timer(this.$element,{duration:this.options.timerDelay,infinite:false},function(){_this.changeSlide(true);});this.timer.start();}/**
      * Sets wrapper and slide heights for the orbit.
      * @function
      * @private
      */},{key:'_prepareForOrbit',value:function _prepareForOrbit(){var _this=this;this._setWrapperHeight(function(max){_this._setSlideHeight(max);});}/**
      * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.
      * @function
      * @private
      * @param {Function} cb - a callback function to fire when complete.
      */},{key:'_setWrapperHeight',value:function _setWrapperHeight(cb){//rewrite this to `for` loop
var max=0,temp,counter=0;this.$slides.each(function(){temp=this.getBoundingClientRect().height;$(this).attr('data-slide',counter);if(counter){//if not the first slide, set css position and display property
$(this).css({'position':'relative','display':'none'});}max=temp>max?temp:max;counter++;});if(counter===this.$slides.length){this.$wrapper.css({'height':max});//only change the wrapper height property once.
cb(max);//fire callback with max height dimension.
}}/**
      * Sets the max-height of each slide.
      * @function
      * @private
      */},{key:'_setSlideHeight',value:function _setSlideHeight(height){this.$slides.each(function(){$(this).css('max-height',height);});}/**
      * Adds event listeners to basically everything within the element.
      * @function
      * @private
      */},{key:'_events',value:function _events(){var _this=this;//***************************************
//**Now using custom event - thanks to:**
//**      Yohai Ararat of Toronto      **
//***************************************
if(this.$slides.length>1){if(this.options.swipe){this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit',function(e){e.preventDefault();_this.changeSlide(true);}).on('swiperight.zf.orbit',function(e){e.preventDefault();_this.changeSlide(false);});}//***************************************
if(this.options.autoPlay){this.$slides.on('click.zf.orbit',function(){_this.$element.data('clickedOn',_this.$element.data('clickedOn')?false:true);_this.timer[_this.$element.data('clickedOn')?'pause':'start']();});if(this.options.pauseOnHover){this.$element.on('mouseenter.zf.orbit',function(){_this.timer.pause();}).on('mouseleave.zf.orbit',function(){if(!_this.$element.data('clickedOn')){_this.timer.start();}});}}if(this.options.navButtons){var $controls=this.$element.find('.'+this.options.nextClass+', .'+this.options.prevClass);$controls.attr('tabindex',0)//also need to handle enter/return and spacebar key presses
.on('click.zf.orbit touchend.zf.orbit',function(e){e.preventDefault();_this.changeSlide($(this).hasClass(_this.options.nextClass));});}if(this.options.bullets){this.$bullets.on('click.zf.orbit touchend.zf.orbit',function(){if(/is-active/g.test(this.className)){return false;}//if this is active, kick out of function.
var idx=$(this).data('slide'),ltr=idx>_this.$slides.filter('.is-active').data('slide'),$slide=_this.$slides.eq(idx);_this.changeSlide(ltr,$slide,idx);});}this.$wrapper.add(this.$bullets).on('keydown.zf.orbit',function(e){// handle keyboard event with keyboard util
Foundation.Keyboard.handleKey(e,'Orbit',{next:function next(){_this.changeSlide(true);},previous:function previous(){_this.changeSlide(false);},handled:function handled(){// if bullet is focused, make sure focus moves
if($(e.target).is(_this.$bullets)){_this.$bullets.filter('.is-active').focus();}}});});}}/**
      * Changes the current slide to a new one.
      * @function
      * @param {Boolean} isLTR - flag if the slide should move left to right.
      * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.
      * @param {Number} idx - the index of the new slide in its collection, if one chosen.
      * @fires Orbit#slidechange
      */},{key:'changeSlide',value:function changeSlide(isLTR,chosenSlide,idx){var $curSlide=this.$slides.filter('.is-active').eq(0);if(/mui/g.test($curSlide[0].className)){return false;}//if the slide is currently animating, kick out of the function
var $firstSlide=this.$slides.first(),$lastSlide=this.$slides.last(),dirIn=isLTR?'Right':'Left',dirOut=isLTR?'Left':'Right',_this=this,$newSlide;if(!chosenSlide){//most of the time, this will be auto played or clicked from the navButtons.
$newSlide=isLTR?//if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!
this.options.infiniteWrap?$curSlide.next('.'+this.options.slideClass).length?$curSlide.next('.'+this.options.slideClass):$firstSlide:$curSlide.next('.'+this.options.slideClass)://pick next slide if moving left to right
this.options.infiniteWrap?$curSlide.prev('.'+this.options.slideClass).length?$curSlide.prev('.'+this.options.slideClass):$lastSlide:$curSlide.prev('.'+this.options.slideClass);//pick prev slide if moving right to left
}else{$newSlide=chosenSlide;}if($newSlide.length){if(this.options.bullets){idx=idx||this.$slides.index($newSlide);//grab index to update bullets
this._updateBullets(idx);}if(this.options.useMUI){Foundation.Motion.animateIn($newSlide.addClass('is-active').css({'position':'absolute','top':0}),this.options['animInFrom'+dirIn],function(){$newSlide.css({'position':'relative','display':'block'}).attr('aria-live','polite');});Foundation.Motion.animateOut($curSlide.removeClass('is-active'),this.options['animOutTo'+dirOut],function(){$curSlide.removeAttr('aria-live');if(_this.options.autoPlay&&!_this.timer.isPaused){_this.timer.restart();}//do stuff?
});}else{$curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();$newSlide.addClass('is-active is-in').attr('aria-live','polite').show();if(this.options.autoPlay&&!this.timer.isPaused){this.timer.restart();}}/**
          * Triggers when the slide has finished animating in.
          * @event Orbit#slidechange
          */this.$element.trigger('slidechange.zf.orbit',[$newSlide]);}}/**
      * Updates the active state of the bullets, if displayed.
      * @function
      * @private
      * @param {Number} idx - the index of the current slide.
      */},{key:'_updateBullets',value:function _updateBullets(idx){var $oldBullet=this.$element.find('.'+this.options.boxOfBullets).find('.is-active').removeClass('is-active').blur(),span=$oldBullet.find('span:last').detach(),$newBullet=this.$bullets.eq(idx).addClass('is-active').append(span);}/**
      * Destroys the carousel and hides the element.
      * @function
      */},{key:'destroy',value:function destroy(){this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();Foundation.unregisterPlugin(this);}}]);return Orbit;}();Orbit.defaults={/**
    * Tells the JS to look for and loadBullets.
    * @option
    * @example true
    */bullets:true,/**
    * Tells the JS to apply event listeners to nav buttons
    * @option
    * @example true
    */navButtons:true,/**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-in-right'
    */animInFromRight:'slide-in-right',/**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-out-right'
    */animOutToRight:'slide-out-right',/**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-in-left'
    *
    */animInFromLeft:'slide-in-left',/**
    * motion-ui animation class to apply
    * @option
    * @example 'slide-out-left'
    */animOutToLeft:'slide-out-left',/**
    * Allows Orbit to automatically animate on page load.
    * @option
    * @example true
    */autoPlay:true,/**
    * Amount of time, in ms, between slide transitions
    * @option
    * @example 5000
    */timerDelay:5000,/**
    * Allows Orbit to infinitely loop through the slides
    * @option
    * @example true
    */infiniteWrap:true,/**
    * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library
    * @option
    * @example true
    */swipe:true,/**
    * Allows the timing function to pause animation on hover.
    * @option
    * @example true
    */pauseOnHover:true,/**
    * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys
    * @option
    * @example true
    */accessible:true,/**
    * Class applied to the container of Orbit
    * @option
    * @example 'orbit-container'
    */containerClass:'orbit-container',/**
    * Class applied to individual slides.
    * @option
    * @example 'orbit-slide'
    */slideClass:'orbit-slide',/**
    * Class applied to the bullet container. You're welcome.
    * @option
    * @example 'orbit-bullets'
    */boxOfBullets:'orbit-bullets',/**
    * Class applied to the `next` navigation button.
    * @option
    * @example 'orbit-next'
    */nextClass:'orbit-next',/**
    * Class applied to the `previous` navigation button.
    * @option
    * @example 'orbit-previous'
    */prevClass:'orbit-previous',/**
    * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatability.
    * @option
    * @example true
    */useMUI:true};// Window exports
Foundation.plugin(Orbit,'Orbit');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * ResponsiveMenu module.
   * @module foundation.responsiveMenu
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.accordionMenu
   * @requires foundation.util.drilldown
   * @requires foundation.util.dropdown-menu
   */var ResponsiveMenu=function(){/**
     * Creates a new instance of a responsive menu.
     * @class
     * @fires ResponsiveMenu#init
     * @param {jQuery} element - jQuery object to make into a dropdown menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */function ResponsiveMenu(element,options){_classCallCheck(this,ResponsiveMenu);this.$element=$(element);this.rules=this.$element.data('responsive-menu');this.currentMq=null;this.currentPlugin=null;this._init();this._events();Foundation.registerPlugin(this,'ResponsiveMenu');}/**
     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.
     * @function
     * @private
     */_createClass(ResponsiveMenu,[{key:'_init',value:function _init(){// The first time an Interchange plugin is initialized, this.rules is converted from a string of "classes" to an object of rules
if(typeof this.rules==='string'){var rulesTree={};// Parse rules from "classes" pulled from data attribute
var rules=this.rules.split(' ');// Iterate through every rule found
for(var i=0;i<rules.length;i++){var rule=rules[i].split('-');var ruleSize=rule.length>1?rule[0]:'small';var rulePlugin=rule.length>1?rule[1]:rule[0];if(MenuPlugins[rulePlugin]!==null){rulesTree[ruleSize]=MenuPlugins[rulePlugin];}}this.rules=rulesTree;}if(!$.isEmptyObject(this.rules)){this._checkMediaQueries();}}/**
       * Initializes events for the Menu.
       * @function
       * @private
       */},{key:'_events',value:function _events(){var _this=this;$(window).on('changed.zf.mediaquery',function(){_this._checkMediaQueries();});// $(window).on('resize.zf.ResponsiveMenu', function() {
//   _this._checkMediaQueries();
// });
}/**
       * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.
       * @function
       * @private
       */},{key:'_checkMediaQueries',value:function _checkMediaQueries(){var matchedMq,_this=this;// Iterate through each rule and find the last matching rule
$.each(this.rules,function(key){if(Foundation.MediaQuery.atLeast(key)){matchedMq=key;}});// No match? No dice
if(!matchedMq)return;// Plugin already initialized? We good
if(this.currentPlugin instanceof this.rules[matchedMq].plugin)return;// Remove existing plugin-specific CSS classes
$.each(MenuPlugins,function(key,value){_this.$element.removeClass(value.cssClass);});// Add the CSS class for the new plugin
this.$element.addClass(this.rules[matchedMq].cssClass);// Create an instance of the new plugin
if(this.currentPlugin)this.currentPlugin.destroy();this.currentPlugin=new this.rules[matchedMq].plugin(this.$element,{});}/**
       * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.
       * @function
       */},{key:'destroy',value:function destroy(){this.currentPlugin.destroy();$(window).off('.zf.ResponsiveMenu');Foundation.unregisterPlugin(this);}}]);return ResponsiveMenu;}();ResponsiveMenu.defaults={};// The plugin matches the plugin classes with these plugin instances.
var MenuPlugins={dropdown:{cssClass:'dropdown',plugin:Foundation._plugins['dropdown-menu']||null},drilldown:{cssClass:'drilldown',plugin:Foundation._plugins['drilldown']||null},accordion:{cssClass:'accordion-menu',plugin:Foundation._plugins['accordion-menu']||null}};// Window exports
Foundation.plugin(ResponsiveMenu,'ResponsiveMenu');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * ResponsiveToggle module.
   * @module foundation.responsiveToggle
   * @requires foundation.util.mediaQuery
   */var ResponsiveToggle=function(){/**
     * Creates a new instance of Tab Bar.
     * @class
     * @fires ResponsiveToggle#init
     * @param {jQuery} element - jQuery object to attach tab bar functionality to.
     * @param {Object} options - Overrides to the default plugin settings.
     */function ResponsiveToggle(element,options){_classCallCheck(this,ResponsiveToggle);this.$element=$(element);this.options=$.extend({},ResponsiveToggle.defaults,this.$element.data(),options);this._init();this._events();Foundation.registerPlugin(this,'ResponsiveToggle');}/**
     * Initializes the tab bar by finding the target element, toggling element, and running update().
     * @function
     * @private
     */_createClass(ResponsiveToggle,[{key:'_init',value:function _init(){var targetID=this.$element.data('responsive-toggle');if(!targetID){console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');}this.$targetMenu=$('#'+targetID);this.$toggler=this.$element.find('[data-toggle]');this._update();}/**
       * Adds necessary event handlers for the tab bar to work.
       * @function
       * @private
       */},{key:'_events',value:function _events(){var _this=this;this._updateMqHandler=this._update.bind(this);$(window).on('changed.zf.mediaquery',this._updateMqHandler);this.$toggler.on('click.zf.responsiveToggle',this.toggleMenu.bind(this));}/**
       * Checks the current media query to determine if the tab bar should be visible or hidden.
       * @function
       * @private
       */},{key:'_update',value:function _update(){// Mobile
if(!Foundation.MediaQuery.atLeast(this.options.hideFor)){this.$element.show();this.$targetMenu.hide();}// Desktop
else{this.$element.hide();this.$targetMenu.show();}}/**
       * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.
       * @function
       * @fires ResponsiveToggle#toggled
       */},{key:'toggleMenu',value:function toggleMenu(){if(!Foundation.MediaQuery.atLeast(this.options.hideFor)){this.$targetMenu.toggle(0);/**
           * Fires when the element attached to the tab bar toggles.
           * @event ResponsiveToggle#toggled
           */this.$element.trigger('toggled.zf.responsiveToggle');}}},{key:'destroy',value:function destroy(){this.$element.off('.zf.responsiveToggle');this.$toggler.off('.zf.responsiveToggle');$(window).off('changed.zf.mediaquery',this._updateMqHandler);Foundation.unregisterPlugin(this);}}]);return ResponsiveToggle;}();ResponsiveToggle.defaults={/**
     * The breakpoint after which the menu is always shown, and the tab bar is hidden.
     * @option
     * @example 'medium'
     */hideFor:'medium'};// Window exports
Foundation.plugin(ResponsiveToggle,'ResponsiveToggle');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Reveal module.
   * @module foundation.reveal
   * @requires foundation.util.keyboard
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   * @requires foundation.util.motion if using animations
   */var Reveal=function(){/**
     * Creates a new instance of Reveal.
     * @class
     * @param {jQuery} element - jQuery object to use for the modal.
     * @param {Object} options - optional parameters.
     */function Reveal(element,options){_classCallCheck(this,Reveal);this.$element=element;this.options=$.extend({},Reveal.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Reveal');Foundation.Keyboard.register('Reveal',{'ENTER':'open','SPACE':'open','ESCAPE':'close','TAB':'tab_forward','SHIFT_TAB':'tab_backward'});}/**
     * Initializes the modal by adding the overlay and close buttons, (if selected).
     * @private
     */_createClass(Reveal,[{key:'_init',value:function _init(){this.id=this.$element.attr('id');this.isActive=false;this.cached={mq:Foundation.MediaQuery.current};this.isMobile=mobileSniff();this.$anchor=$('[data-open="'+this.id+'"]').length?$('[data-open="'+this.id+'"]'):$('[data-toggle="'+this.id+'"]');this.$anchor.attr({'aria-controls':this.id,'aria-haspopup':true,'tabindex':0});if(this.options.fullScreen||this.$element.hasClass('full')){this.options.fullScreen=true;this.options.overlay=false;}if(this.options.overlay&&!this.$overlay){this.$overlay=this._makeOverlay(this.id);}this.$element.attr({'role':'dialog','aria-hidden':true,'data-yeti-box':this.id,'data-resize':this.id});if(this.$overlay){this.$element.detach().appendTo(this.$overlay);}else{this.$element.detach().appendTo($('body'));this.$element.addClass('without-overlay');}this._events();if(this.options.deepLink&&window.location.hash==='#'+this.id){$(window).one('load.zf.reveal',this.open.bind(this));}}/**
       * Creates an overlay div to display behind the modal.
       * @private
       */},{key:'_makeOverlay',value:function _makeOverlay(id){var $overlay=$('<div></div>').addClass('reveal-overlay').appendTo('body');return $overlay;}/**
       * Updates position of modal
       * TODO:  Figure out if we actually need to cache these values or if it doesn't matter
       * @private
       */},{key:'_updatePosition',value:function _updatePosition(){var width=this.$element.outerWidth();var outerWidth=$(window).width();var height=this.$element.outerHeight();var outerHeight=$(window).height();var left,top;if(this.options.hOffset==='auto'){left=parseInt((outerWidth-width)/2,10);}else{left=parseInt(this.options.hOffset,10);}if(this.options.vOffset==='auto'){if(height>outerHeight){top=parseInt(Math.min(100,outerHeight/10),10);}else{top=parseInt((outerHeight-height)/4,10);}}else{top=parseInt(this.options.vOffset,10);}this.$element.css({top:top+'px'});// only worry about left if we don't have an overlay or we havea  horizontal offset,
// otherwise we're perfectly in the middle
if(!this.$overlay||this.options.hOffset!=='auto'){this.$element.css({left:left+'px'});this.$element.css({margin:'0px'});}}/**
       * Adds event handlers for the modal.
       * @private
       */},{key:'_events',value:function _events(){var _this2=this;var _this=this;this.$element.on({'open.zf.trigger':this.open.bind(this),'close.zf.trigger':function closeZfTrigger(event,$element){if(event.target===_this.$element[0]||$(event.target).parents('[data-closable]')[0]===$element){// only close reveal when it's explicitly called
return _this2.close.apply(_this2);}},'toggle.zf.trigger':this.toggle.bind(this),'resizeme.zf.trigger':function resizemeZfTrigger(){_this._updatePosition();}});if(this.$anchor.length){this.$anchor.on('keydown.zf.reveal',function(e){if(e.which===13||e.which===32){e.stopPropagation();e.preventDefault();_this.open();}});}if(this.options.closeOnClick&&this.options.overlay){this.$overlay.off('.zf.reveal').on('click.zf.reveal',function(e){if(e.target===_this.$element[0]||$.contains(_this.$element[0],e.target)){return;}_this.close();});}if(this.options.deepLink){$(window).on('popstate.zf.reveal:'+this.id,this._handleState.bind(this));}}/**
       * Handles modal methods on back/forward button clicks or any other event that triggers popstate.
       * @private
       */},{key:'_handleState',value:function _handleState(e){if(window.location.hash==='#'+this.id&&!this.isActive){this.open();}else{this.close();}}/**
       * Opens the modal controlled by `this.$anchor`, and closes all others by default.
       * @function
       * @fires Reveal#closeme
       * @fires Reveal#open
       */},{key:'open',value:function open(){var _this3=this;if(this.options.deepLink){var hash='#'+this.id;if(window.history.pushState){window.history.pushState(null,null,hash);}else{window.location.hash=hash;}}this.isActive=true;// Make elements invisible, but remove display: none so we can get size and positioning
this.$element.css({'visibility':'hidden'}).show().scrollTop(0);if(this.options.overlay){this.$overlay.css({'visibility':'hidden'}).show();}this._updatePosition();this.$element.hide().css({'visibility':''});if(this.$overlay){this.$overlay.css({'visibility':''}).hide();if(this.$element.hasClass('fast')){this.$overlay.addClass('fast');}else if(this.$element.hasClass('slow')){this.$overlay.addClass('slow');}}if(!this.options.multipleOpened){/**
           * Fires immediately before the modal opens.
           * Closes any other modals that are currently open
           * @event Reveal#closeme
           */this.$element.trigger('closeme.zf.reveal',this.id);}// Motion UI method of reveal
if(this.options.animationIn){var _this;(function(){var afterAnimationFocus=function afterAnimationFocus(){_this.$element.attr({'aria-hidden':false,'tabindex':-1}).focus();console.log('focus');};_this=_this3;if(_this3.options.overlay){Foundation.Motion.animateIn(_this3.$overlay,'fade-in');}Foundation.Motion.animateIn(_this3.$element,_this3.options.animationIn,function(){_this3.focusableElements=Foundation.Keyboard.findFocusable(_this3.$element);afterAnimationFocus();});})();}// jQuery method of reveal
else{if(this.options.overlay){this.$overlay.show(0);}this.$element.show(this.options.showDelay);}// handle accessibility
this.$element.attr({'aria-hidden':false,'tabindex':-1}).focus();/**
         * Fires when the modal has successfully opened.
         * @event Reveal#open
         */this.$element.trigger('open.zf.reveal');if(this.isMobile){this.originalScrollPos=window.pageYOffset;$('html, body').addClass('is-reveal-open');}else{$('body').addClass('is-reveal-open');}setTimeout(function(){_this3._extraHandlers();},0);}/**
       * Adds extra event handlers for the body and window if necessary.
       * @private
       */},{key:'_extraHandlers',value:function _extraHandlers(){var _this=this;this.focusableElements=Foundation.Keyboard.findFocusable(this.$element);if(!this.options.overlay&&this.options.closeOnClick&&!this.options.fullScreen){$('body').on('click.zf.reveal',function(e){if(e.target===_this.$element[0]||$.contains(_this.$element[0],e.target)){return;}_this.close();});}if(this.options.closeOnEsc){$(window).on('keydown.zf.reveal',function(e){Foundation.Keyboard.handleKey(e,'Reveal',{close:function close(){if(_this.options.closeOnEsc){_this.close();_this.$anchor.focus();}}});});}// lock focus within modal while tabbing
this.$element.on('keydown.zf.reveal',function(e){var $target=$(this);// handle keyboard event with keyboard util
Foundation.Keyboard.handleKey(e,'Reveal',{tab_forward:function tab_forward(){if(_this.$element.find(':focus').is(_this.focusableElements.eq(-1))){// left modal downwards, setting focus to first element
_this.focusableElements.eq(0).focus();return true;}if(_this.focusableElements.length===0){// no focusable elements inside the modal at all, prevent tabbing in general
return true;}},tab_backward:function tab_backward(){if(_this.$element.find(':focus').is(_this.focusableElements.eq(0))||_this.$element.is(':focus')){// left modal upwards, setting focus to last element
_this.focusableElements.eq(-1).focus();return true;}if(_this.focusableElements.length===0){// no focusable elements inside the modal at all, prevent tabbing in general
return true;}},open:function open(){if(_this.$element.find(':focus').is(_this.$element.find('[data-close]'))){setTimeout(function(){// set focus back to anchor if close button has been activated
_this.$anchor.focus();},1);}else if($target.is(_this.focusableElements)){// dont't trigger if acual element has focus (i.e. inputs, links, ...)
_this.open();}},close:function close(){if(_this.options.closeOnEsc){_this.close();_this.$anchor.focus();}},handled:function handled(preventDefault){if(preventDefault){e.preventDefault();}}});});}/**
       * Closes the modal.
       * @function
       * @fires Reveal#closed
       */},{key:'close',value:function close(){if(!this.isActive||!this.$element.is(':visible')){return false;}var _this=this;// Motion UI method of hiding
if(this.options.animationOut){if(this.options.overlay){Foundation.Motion.animateOut(this.$overlay,'fade-out',finishUp);}else{finishUp();}Foundation.Motion.animateOut(this.$element,this.options.animationOut);}// jQuery method of hiding
else{if(this.options.overlay){this.$overlay.hide(0,finishUp);}else{finishUp();}this.$element.hide(this.options.hideDelay);}// Conditionals to remove extra event listeners added on open
if(this.options.closeOnEsc){$(window).off('keydown.zf.reveal');}if(!this.options.overlay&&this.options.closeOnClick){$('body').off('click.zf.reveal');}this.$element.off('keydown.zf.reveal');function finishUp(){if(_this.isMobile){$('html, body').removeClass('is-reveal-open');if(_this.originalScrollPos){$('body').scrollTop(_this.originalScrollPos);_this.originalScrollPos=null;}}else{$('body').removeClass('is-reveal-open');}_this.$element.attr('aria-hidden',true);/**
          * Fires when the modal is done closing.
          * @event Reveal#closed
          */_this.$element.trigger('closed.zf.reveal');}/**
        * Resets the modal content
        * This prevents a running video to keep going in the background
        */if(this.options.resetOnClose){this.$element.html(this.$element.html());}this.isActive=false;if(_this.options.deepLink){if(window.history.replaceState){window.history.replaceState("",document.title,window.location.pathname);}else{window.location.hash='';}}}/**
       * Toggles the open/closed state of a modal.
       * @function
       */},{key:'toggle',value:function toggle(){if(this.isActive){this.close();}else{this.open();}}},{key:'destroy',/**
       * Destroys an instance of a modal.
       * @function
       */value:function destroy(){if(this.options.overlay){this.$element.appendTo($('body'));// move $element outside of $overlay to prevent error unregisterPlugin()
this.$overlay.hide().off().remove();}this.$element.hide().off();this.$anchor.off('.zf');$(window).off('.zf.reveal:'+this.id);Foundation.unregisterPlugin(this);}}]);return Reveal;}();Reveal.defaults={/**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-in-left'
     */animationIn:'',/**
     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
     * @option
     * @example 'slide-out-right'
     */animationOut:'',/**
     * Time, in ms, to delay the opening of a modal after a click if no animation used.
     * @option
     * @example 10
     */showDelay:0,/**
     * Time, in ms, to delay the closing of a modal after a click if no animation used.
     * @option
     * @example 10
     */hideDelay:0,/**
     * Allows a click on the body/overlay to close the modal.
     * @option
     * @example true
     */closeOnClick:true,/**
     * Allows the modal to close if the user presses the `ESCAPE` key.
     * @option
     * @example true
     */closeOnEsc:true,/**
     * If true, allows multiple modals to be displayed at once.
     * @option
     * @example false
     */multipleOpened:false,/**
     * Distance, in pixels, the modal should push down from the top of the screen.
     * @option
     * @example auto
     */vOffset:'auto',/**
     * Distance, in pixels, the modal should push in from the side of the screen.
     * @option
     * @example auto
     */hOffset:'auto',/**
     * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
     * @option
     * @example false
     */fullScreen:false,/**
     * Percentage of screen height the modal should push up from the bottom of the view.
     * @option
     * @example 10
     */btmOffsetPct:10,/**
     * Allows the modal to generate an overlay div, which will cover the view when modal opens.
     * @option
     * @example true
     */overlay:true,/**
     * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.
     * @option
     * @example false
     */resetOnClose:false,/**
     * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.
     * @option
     * @example false
     */deepLink:false};// Window exports
Foundation.plugin(Reveal,'Reveal');function iPhoneSniff(){return /iP(ad|hone|od).*OS/.test(window.navigator.userAgent);}function androidSniff(){return /Android/.test(window.navigator.userAgent);}function mobileSniff(){return iPhoneSniff()||androidSniff();}}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Slider module.
   * @module foundation.slider
   * @requires foundation.util.motion
   * @requires foundation.util.triggers
   * @requires foundation.util.keyboard
   * @requires foundation.util.touch
   */var Slider=function(){/**
     * Creates a new instance of a drilldown menu.
     * @class
     * @param {jQuery} element - jQuery object to make into an accordion menu.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Slider(element,options){_classCallCheck(this,Slider);this.$element=element;this.options=$.extend({},Slider.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Slider');Foundation.Keyboard.register('Slider',{'ltr':{'ARROW_RIGHT':'increase','ARROW_UP':'increase','ARROW_DOWN':'decrease','ARROW_LEFT':'decrease','SHIFT_ARROW_RIGHT':'increase_fast','SHIFT_ARROW_UP':'increase_fast','SHIFT_ARROW_DOWN':'decrease_fast','SHIFT_ARROW_LEFT':'decrease_fast'},'rtl':{'ARROW_LEFT':'increase','ARROW_RIGHT':'decrease','SHIFT_ARROW_LEFT':'increase_fast','SHIFT_ARROW_RIGHT':'decrease_fast'}});}/**
     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).
     * @function
     * @private
     */_createClass(Slider,[{key:'_init',value:function _init(){this.inputs=this.$element.find('input');this.handles=this.$element.find('[data-slider-handle]');this.$handle=this.handles.eq(0);this.$input=this.inputs.length?this.inputs.eq(0):$('#'+this.$handle.attr('aria-controls'));this.$fill=this.$element.find('[data-slider-fill]').css(this.options.vertical?'height':'width',0);var isDbl=false,_this=this;if(this.options.disabled||this.$element.hasClass(this.options.disabledClass)){this.options.disabled=true;this.$element.addClass(this.options.disabledClass);}if(!this.inputs.length){this.inputs=$().add(this.$input);this.options.binding=true;}this._setInitAttr(0);this._events(this.$handle);if(this.handles[1]){this.options.doubleSided=true;this.$handle2=this.handles.eq(1);this.$input2=this.inputs.length>1?this.inputs.eq(1):$('#'+this.$handle2.attr('aria-controls'));if(!this.inputs[1]){this.inputs=this.inputs.add(this.$input2);}isDbl=true;this._setHandlePos(this.$handle,this.options.initialStart,true,function(){_this._setHandlePos(_this.$handle2,_this.options.initialEnd,true);});// this.$handle.triggerHandler('click.zf.slider');
this._setInitAttr(1);this._events(this.$handle2);}if(!isDbl){this._setHandlePos(this.$handle,this.options.initialStart,true);}}/**
       * Sets the position of the selected handle and fill bar.
       * @function
       * @private
       * @param {jQuery} $hndl - the selected handle to move.
       * @param {Number} location - floating point between the start and end values of the slider bar.
       * @param {Function} cb - callback function to fire on completion.
       * @fires Slider#moved
       * @fires Slider#changed
       */},{key:'_setHandlePos',value:function _setHandlePos($hndl,location,noInvert,cb){// don't move if the slider has been disabled since its initialization
if(this.$element.hasClass(this.options.disabledClass)){return;}//might need to alter that slightly for bars that will have odd number selections.
location=parseFloat(location);//on input change events, convert string to number...grumble.
// prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max
if(location<this.options.start){location=this.options.start;}else if(location>this.options.end){location=this.options.end;}var isDbl=this.options.doubleSided;if(isDbl){//this block is to prevent 2 handles from crossing eachother. Could/should be improved.
if(this.handles.index($hndl)===0){var h2Val=parseFloat(this.$handle2.attr('aria-valuenow'));location=location>=h2Val?h2Val-this.options.step:location;}else{var h1Val=parseFloat(this.$handle.attr('aria-valuenow'));location=location<=h1Val?h1Val+this.options.step:location;}}//this is for single-handled vertical sliders, it adjusts the value to account for the slider being "upside-down"
//for click and drag events, it's weird due to the scale(-1, 1) css property
if(this.options.vertical&&!noInvert){location=this.options.end-location;}var _this=this,vert=this.options.vertical,hOrW=vert?'height':'width',lOrT=vert?'top':'left',handleDim=$hndl[0].getBoundingClientRect()[hOrW],elemDim=this.$element[0].getBoundingClientRect()[hOrW],//percentage of bar min/max value based on click or drag point
pctOfBar=percent(location-this.options.start,this.options.end-this.options.start).toFixed(2),//number of actual pixels to shift the handle, based on the percentage obtained above
pxToMove=(elemDim-handleDim)*pctOfBar,//percentage of bar to shift the handle
movement=(percent(pxToMove,elemDim)*100).toFixed(this.options.decimal);//fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value
location=parseFloat(location.toFixed(this.options.decimal));// declare empty object for css adjustments, only used with 2 handled-sliders
var css={};this._setValues($hndl,location);// TODO update to calculate based on values set to respective inputs??
if(isDbl){var isLeftHndl=this.handles.index($hndl)===0,//empty variable, will be used for min-height/width for fill bar
dim,//percentage w/h of the handle compared to the slider bar
handlePct=~~(percent(handleDim,elemDim)*100);//if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar
if(isLeftHndl){//left or top percentage value to apply to the fill bar.
css[lOrT]=movement+'%';//calculate the new min-height/width for the fill bar.
dim=parseFloat(this.$handle2[0].style[lOrT])-movement+handlePct;//this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider
//plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.
if(cb&&typeof cb==='function'){cb();}//this is only needed for the initialization of 2 handled sliders
}else{//just caching the value of the left/bottom handle's left/top property
var handlePos=parseFloat(this.$handle[0].style[lOrT]);//calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0
//based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself
dim=movement-(isNaN(handlePos)?this.options.initialStart/((this.options.end-this.options.start)/100):handlePos)+handlePct;}// assign the min-height/width to our css object
css['min-'+hOrW]=dim+'%';}this.$element.one('finished.zf.animate',function(){/**
           * Fires when the handle is done moving.
           * @event Slider#moved
           */_this.$element.trigger('moved.zf.slider',[$hndl]);});//because we don't know exactly how the handle will be moved, check the amount of time it should take to move.
var moveTime=this.$element.data('dragging')?1000/60:this.options.moveTime;Foundation.Move(moveTime,$hndl,function(){//adjusting the left/top property of the handle, based on the percentage calculated above
$hndl.css(lOrT,movement+'%');if(!_this.options.doubleSided){//if single-handled, a simple method to expand the fill bar
_this.$fill.css(hOrW,pctOfBar*100+'%');}else{//otherwise, use the css object we created above
_this.$fill.css(css);}});/**
         * Fires when the value has not been change for a given time.
         * @event Slider#changed
         */clearTimeout(_this.timeout);_this.timeout=setTimeout(function(){_this.$element.trigger('changed.zf.slider',[$hndl]);},_this.options.changedDelay);}/**
       * Sets the initial attribute for the slider element.
       * @function
       * @private
       * @param {Number} idx - index of the current handle/input to use.
       */},{key:'_setInitAttr',value:function _setInitAttr(idx){var id=this.inputs.eq(idx).attr('id')||Foundation.GetYoDigits(6,'slider');this.inputs.eq(idx).attr({'id':id,'max':this.options.end,'min':this.options.start,'step':this.options.step});this.handles.eq(idx).attr({'role':'slider','aria-controls':id,'aria-valuemax':this.options.end,'aria-valuemin':this.options.start,'aria-valuenow':idx===0?this.options.initialStart:this.options.initialEnd,'aria-orientation':this.options.vertical?'vertical':'horizontal','tabindex':0});}/**
       * Sets the input and `aria-valuenow` values for the slider element.
       * @function
       * @private
       * @param {jQuery} $handle - the currently selected handle.
       * @param {Number} val - floating point of the new value.
       */},{key:'_setValues',value:function _setValues($handle,val){var idx=this.options.doubleSided?this.handles.index($handle):0;this.inputs.eq(idx).val(val);$handle.attr('aria-valuenow',val);}/**
       * Handles events on the slider element.
       * Calculates the new location of the current handle.
       * If there are two handles and the bar was clicked, it determines which handle to move.
       * @function
       * @private
       * @param {Object} e - the `event` object passed from the listener.
       * @param {jQuery} $handle - the current handle to calculate for, if selected.
       * @param {Number} val - floating point number for the new value of the slider.
       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.
       */},{key:'_handleEvent',value:function _handleEvent(e,$handle,val){var value,hasVal;if(!val){//click or drag events
e.preventDefault();var _this=this,vertical=this.options.vertical,param=vertical?'height':'width',direction=vertical?'top':'left',eventOffset=vertical?e.pageY:e.pageX,halfOfHandle=this.$handle[0].getBoundingClientRect()[param]/2,barDim=this.$element[0].getBoundingClientRect()[param],windowScroll=vertical?$(window).scrollTop():$(window).scrollLeft();var elemOffset=this.$element.offset()[direction];// touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...
// best way to guess this is simulated is if clientY == pageY
if(e.clientY===e.pageY){eventOffset=eventOffset+windowScroll;}var eventFromBar=eventOffset-elemOffset;var barXY;if(eventFromBar<0){barXY=0;}else if(eventFromBar>barDim){barXY=barDim;}else{barXY=eventFromBar;}offsetPct=percent(barXY,barDim);value=(this.options.end-this.options.start)*offsetPct+this.options.start;// turn everything around for RTL, yay math!
if(Foundation.rtl()&&!this.options.vertical){value=this.options.end-value;}value=_this._adjustValue(null,value);//boolean flag for the setHandlePos fn, specifically for vertical sliders
hasVal=false;if(!$handle){//figure out which handle it is, pass it to the next function.
var firstHndlPos=absPosition(this.$handle,direction,barXY,param),secndHndlPos=absPosition(this.$handle2,direction,barXY,param);$handle=firstHndlPos<=secndHndlPos?this.$handle:this.$handle2;}}else{//change event on input
value=this._adjustValue(null,val);hasVal=true;}this._setHandlePos($handle,value,hasVal);}/**
       * Adjustes value for handle in regard to step value. returns adjusted value
       * @function
       * @private
       * @param {jQuery} $handle - the selected handle.
       * @param {Number} value - value to adjust. used if $handle is falsy
       */},{key:'_adjustValue',value:function _adjustValue($handle,value){var val,step=this.options.step,div=parseFloat(step/2),left,prev_val,next_val;if(!!$handle){val=parseFloat($handle.attr('aria-valuenow'));}else{val=value;}left=val%step;prev_val=val-left;next_val=prev_val+step;if(left===0){return val;}val=val>=prev_val+div?next_val:prev_val;return val;}/**
       * Adds event listeners to the slider elements.
       * @function
       * @private
       * @param {jQuery} $handle - the current handle to apply listeners to.
       */},{key:'_events',value:function _events($handle){var _this=this,curHandle,timer;this.inputs.off('change.zf.slider').on('change.zf.slider',function(e){var idx=_this.inputs.index($(this));_this._handleEvent(e,_this.handles.eq(idx),$(this).val());});if(this.options.clickSelect){this.$element.off('click.zf.slider').on('click.zf.slider',function(e){if(_this.$element.data('dragging')){return false;}if(!$(e.target).is('[data-slider-handle]')){if(_this.options.doubleSided){_this._handleEvent(e);}else{_this._handleEvent(e,_this.$handle);}}});}if(this.options.draggable){this.handles.addTouch();var $body=$('body');$handle.off('mousedown.zf.slider').on('mousedown.zf.slider',function(e){$handle.addClass('is-dragging');_this.$fill.addClass('is-dragging');//
_this.$element.data('dragging',true);curHandle=$(e.currentTarget);$body.on('mousemove.zf.slider',function(e){e.preventDefault();_this._handleEvent(e,curHandle);}).on('mouseup.zf.slider',function(e){_this._handleEvent(e,curHandle);$handle.removeClass('is-dragging');_this.$fill.removeClass('is-dragging');_this.$element.data('dragging',false);$body.off('mousemove.zf.slider mouseup.zf.slider');});})// prevent events triggered by touch
.on('selectstart.zf.slider touchmove.zf.slider',function(e){e.preventDefault();});}$handle.off('keydown.zf.slider').on('keydown.zf.slider',function(e){var _$handle=$(this),idx=_this.options.doubleSided?_this.handles.index(_$handle):0,oldValue=parseFloat(_this.inputs.eq(idx).val()),newValue;// handle keyboard event with keyboard util
Foundation.Keyboard.handleKey(e,'Slider',{decrease:function decrease(){newValue=oldValue-_this.options.step;},increase:function increase(){newValue=oldValue+_this.options.step;},decrease_fast:function decrease_fast(){newValue=oldValue-_this.options.step*10;},increase_fast:function increase_fast(){newValue=oldValue+_this.options.step*10;},handled:function handled(){// only set handle pos when event was handled specially
e.preventDefault();_this._setHandlePos(_$handle,newValue,true);}});/*if (newValue) { // if pressed key has special function, update value
            e.preventDefault();
            _this._setHandlePos(_$handle, newValue);
          }*/});}/**
       * Destroys the slider plugin.
       */},{key:'destroy',value:function destroy(){this.handles.off('.zf.slider');this.inputs.off('.zf.slider');this.$element.off('.zf.slider');Foundation.unregisterPlugin(this);}}]);return Slider;}();Slider.defaults={/**
     * Minimum value for the slider scale.
     * @option
     * @example 0
     */start:0,/**
     * Maximum value for the slider scale.
     * @option
     * @example 100
     */end:100,/**
     * Minimum value change per change event.
     * @option
     * @example 1
     */step:1,/**
     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.
     * @option
     * @example 0
     */initialStart:0,/**
     * Value at which the right handle/second input should be set to on initialization.
     * @option
     * @example 100
     */initialEnd:100,/**
     * Allows the input to be located outside the container and visible. Set to by the JS
     * @option
     * @example false
     */binding:false,/**
     * Allows the user to click/tap on the slider bar to select a value.
     * @option
     * @example true
     */clickSelect:true,/**
     * Set to true and use the `vertical` class to change alignment to vertical.
     * @option
     * @example false
     */vertical:false,/**
     * Allows the user to drag the slider handle(s) to select a value.
     * @option
     * @example true
     */draggable:true,/**
     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.
     * @option
     * @example false
     */disabled:false,/**
     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.
     * @option
     * @example false
     */doubleSided:false,/**
     * Potential future feature.
     */// steps: 100,
/**
     * Number of decimal places the plugin should go to for floating point precision.
     * @option
     * @example 2
     */decimal:2,/**
     * Time delay for dragged elements.
     */// dragDelay: 0,
/**
     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.
     * @option
     * @example 200
     */moveTime:200,//update this if changing the transition time in the sass
/**
     * Class applied to disabled sliders.
     * @option
     * @example 'disabled'
     */disabledClass:'disabled',/**
     * Will invert the default layout for a vertical<span data-tooltip title="who would do this???"> </span>slider.
     * @option
     * @example false
     */invertVertical:false,/**
     * Milliseconds before the `changed.zf-slider` event is triggered after value change.
     * @option
     * @example 500
     */changedDelay:500};function percent(frac,num){return frac/num;}function absPosition($handle,dir,clickPos,param){return Math.abs($handle.position()[dir]+$handle[param]()/2-clickPos);}// Window exports
Foundation.plugin(Slider,'Slider');}(jQuery);//*********this is in case we go to static, absolute positions instead of dynamic positioning********
var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Sticky module.
   * @module foundation.sticky
   * @requires foundation.util.triggers
   * @requires foundation.util.mediaQuery
   */var Sticky=function(){/**
     * Creates a new instance of a sticky thing.
     * @class
     * @param {jQuery} element - jQuery object to make sticky.
     * @param {Object} options - options object passed when creating the element programmatically.
     */function Sticky(element,options){_classCallCheck(this,Sticky);this.$element=element;this.options=$.extend({},Sticky.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Sticky');}/**
     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes
     * @function
     * @private
     */_createClass(Sticky,[{key:'_init',value:function _init(){var $parent=this.$element.parent('[data-sticky-container]'),id=this.$element[0].id||Foundation.GetYoDigits(6,'sticky'),_this=this;if(!$parent.length){this.wasWrapped=true;}this.$container=$parent.length?$parent:$(this.options.container).wrapInner(this.$element);this.$container.addClass(this.options.containerClass);this.$element.addClass(this.options.stickyClass).attr({'data-resize':id});this.scrollCount=this.options.checkEvery;this.isStuck=false;$(window).one('load.zf.sticky',function(){if(_this.options.anchor!==''){_this.$anchor=$('#'+_this.options.anchor);}else{_this._parsePoints();}_this._setSizes(function(){_this._calc(false);});_this._events(id.split('-').reverse().join('-'));});}/**
       * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.
       * @function
       * @private
       */},{key:'_parsePoints',value:function _parsePoints(){var top=this.options.topAnchor==""?1:this.options.topAnchor,btm=this.options.btmAnchor==""?document.documentElement.scrollHeight:this.options.btmAnchor,pts=[top,btm],breaks={};for(var i=0,len=pts.length;i<len&&pts[i];i++){var pt;if(typeof pts[i]==='number'){pt=pts[i];}else{var place=pts[i].split(':'),anchor=$('#'+place[0]);pt=anchor.offset().top;if(place[1]&&place[1].toLowerCase()==='bottom'){pt+=anchor[0].getBoundingClientRect().height;}}breaks[i]=pt;}this.points=breaks;return;}/**
       * Adds event handlers for the scrolling element.
       * @private
       * @param {String} id - psuedo-random id for unique scroll event listener.
       */},{key:'_events',value:function _events(id){var _this=this,scrollListener=this.scrollListener='scroll.zf.'+id;if(this.isOn){return;}if(this.canStick){this.isOn=true;$(window).off(scrollListener).on(scrollListener,function(e){if(_this.scrollCount===0){_this.scrollCount=_this.options.checkEvery;_this._setSizes(function(){_this._calc(false,window.pageYOffset);});}else{_this.scrollCount--;_this._calc(false,window.pageYOffset);}});}this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger',function(e,el){_this._setSizes(function(){_this._calc(false);if(_this.canStick){if(!_this.isOn){_this._events(id);}}else if(_this.isOn){_this._pauseListeners(scrollListener);}});});}/**
       * Removes event handlers for scroll and change events on anchor.
       * @fires Sticky#pause
       * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`
       */},{key:'_pauseListeners',value:function _pauseListeners(scrollListener){this.isOn=false;$(window).off(scrollListener);/**
         * Fires when the plugin is paused due to resize event shrinking the view.
         * @event Sticky#pause
         * @private
         */this.$element.trigger('pause.zf.sticky');}/**
       * Called on every `scroll` event and on `_init`
       * fires functions based on booleans and cached values
       * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.
       * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.
       */},{key:'_calc',value:function _calc(checkSizes,scroll){if(checkSizes){this._setSizes();}if(!this.canStick){if(this.isStuck){this._removeSticky(true);}return false;}if(!scroll){scroll=window.pageYOffset;}if(scroll>=this.topPoint){if(scroll<=this.bottomPoint){if(!this.isStuck){this._setSticky();}}else{if(this.isStuck){this._removeSticky(false);}}}else{if(this.isStuck){this._removeSticky(true);}}}/**
       * Causes the $element to become stuck.
       * Adds `position: fixed;`, and helper classes.
       * @fires Sticky#stuckto
       * @function
       * @private
       */},{key:'_setSticky',value:function _setSticky(){var _this=this,stickTo=this.options.stickTo,mrgn=stickTo==='top'?'marginTop':'marginBottom',notStuckTo=stickTo==='top'?'bottom':'top',css={};css[mrgn]=this.options[mrgn]+'em';css[stickTo]=0;css[notStuckTo]='auto';css['left']=this.$container.offset().left+parseInt(window.getComputedStyle(this.$container[0])["padding-left"],10);this.isStuck=true;this.$element.removeClass('is-anchored is-at-'+notStuckTo).addClass('is-stuck is-at-'+stickTo).css(css)/**
         * Fires when the $element has become `position: fixed;`
         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`
         * @event Sticky#stuckto
         */.trigger('sticky.zf.stuckto:'+stickTo);this.$element.on("transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd",function(){_this._setSizes();});}/**
       * Causes the $element to become unstuck.
       * Removes `position: fixed;`, and helper classes.
       * Adds other helper classes.
       * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.
       * @fires Sticky#unstuckfrom
       * @private
       */},{key:'_removeSticky',value:function _removeSticky(isTop){var stickTo=this.options.stickTo,stickToTop=stickTo==='top',css={},anchorPt=(this.points?this.points[1]-this.points[0]:this.anchorHeight)-this.elemHeight,mrgn=stickToTop?'marginTop':'marginBottom',notStuckTo=stickToTop?'bottom':'top',topOrBottom=isTop?'top':'bottom';css[mrgn]=0;css['bottom']='auto';if(isTop){css['top']=0;}else{css['top']=anchorPt;}css['left']='';this.isStuck=false;this.$element.removeClass('is-stuck is-at-'+stickTo).addClass('is-anchored is-at-'+topOrBottom).css(css)/**
         * Fires when the $element has become anchored.
         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`
         * @event Sticky#unstuckfrom
         */.trigger('sticky.zf.unstuckfrom:'+topOrBottom);}/**
       * Sets the $element and $container sizes for plugin.
       * Calls `_setBreakPoints`.
       * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.
       * @private
       */},{key:'_setSizes',value:function _setSizes(cb){this.canStick=Foundation.MediaQuery.atLeast(this.options.stickyOn);if(!this.canStick){cb();}var _this=this,newElemWidth=this.$container[0].getBoundingClientRect().width,comp=window.getComputedStyle(this.$container[0]),pdng=parseInt(comp['padding-right'],10);if(this.$anchor&&this.$anchor.length){this.anchorHeight=this.$anchor[0].getBoundingClientRect().height;}else{this._parsePoints();}this.$element.css({'max-width':newElemWidth-pdng+'px'});var newContainerHeight=this.$element[0].getBoundingClientRect().height||this.containerHeight;if(this.$element.css("display")=="none"){newContainerHeight=0;}this.containerHeight=newContainerHeight;this.$container.css({height:newContainerHeight});this.elemHeight=newContainerHeight;if(this.isStuck){this.$element.css({"left":this.$container.offset().left+parseInt(comp['padding-left'],10)});}this._setBreakPoints(newContainerHeight,function(){if(cb){cb();}});}/**
       * Sets the upper and lower breakpoints for the element to become sticky/unsticky.
       * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.
       * @param {Function} cb - optional callback function to be called on completion.
       * @private
       */},{key:'_setBreakPoints',value:function _setBreakPoints(elemHeight,cb){if(!this.canStick){if(cb){cb();}else{return false;}}var mTop=emCalc(this.options.marginTop),mBtm=emCalc(this.options.marginBottom),topPoint=this.points?this.points[0]:this.$anchor.offset().top,bottomPoint=this.points?this.points[1]:topPoint+this.anchorHeight,// topPoint = this.$anchor.offset().top || this.points[0],
// bottomPoint = topPoint + this.anchorHeight || this.points[1],
winHeight=window.innerHeight;if(this.options.stickTo==='top'){topPoint-=mTop;bottomPoint-=elemHeight+mTop;}else if(this.options.stickTo==='bottom'){topPoint-=winHeight-(elemHeight+mBtm);bottomPoint-=winHeight-mBtm;}else{//this would be the stickTo: both option... tricky
}this.topPoint=topPoint;this.bottomPoint=bottomPoint;if(cb){cb();}}/**
       * Destroys the current sticky element.
       * Resets the element to the top position first.
       * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.
       * @function
       */},{key:'destroy',value:function destroy(){this._removeSticky(true);this.$element.removeClass(this.options.stickyClass+' is-anchored is-at-top').css({height:'',top:'',bottom:'','max-width':''}).off('resizeme.zf.trigger');if(this.$anchor&&this.$anchor.length){this.$anchor.off('change.zf.sticky');}$(window).off(this.scrollListener);if(this.wasWrapped){this.$element.unwrap();}else{this.$container.removeClass(this.options.containerClass).css({height:''});}Foundation.unregisterPlugin(this);}}]);return Sticky;}();Sticky.defaults={/**
     * Customizable container template. Add your own classes for styling and sizing.
     * @option
     * @example '&lt;div data-sticky-container class="small-6 columns"&gt;&lt;/div&gt;'
     */container:'<div data-sticky-container></div>',/**
     * Location in the view the element sticks to.
     * @option
     * @example 'top'
     */stickTo:'top',/**
     * If anchored to a single element, the id of that element.
     * @option
     * @example 'exampleId'
     */anchor:'',/**
     * If using more than one element as anchor points, the id of the top anchor.
     * @option
     * @example 'exampleId:top'
     */topAnchor:'',/**
     * If using more than one element as anchor points, the id of the bottom anchor.
     * @option
     * @example 'exampleId:bottom'
     */btmAnchor:'',/**
     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.
     * @option
     * @example 1
     */marginTop:1,/**
     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.
     * @option
     * @example 1
     */marginBottom:1,/**
     * Breakpoint string that is the minimum screen size an element should become sticky.
     * @option
     * @example 'medium'
     */stickyOn:'medium',/**
     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.
     * @option
     * @example 'sticky'
     */stickyClass:'sticky',/**
     * Class applied to sticky container. Foundation defaults to `sticky-container`.
     * @option
     * @example 'sticky-container'
     */containerClass:'sticky-container',/**
     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.
     * @option
     * @example 50
     */checkEvery:-1};/**
   * Helper function to calculate em values
   * @param Number {em} - number of em's to calculate into pixels
   */function emCalc(em){return parseInt(window.getComputedStyle(document.body,null).fontSize,10)*em;}// Window exports
Foundation.plugin(Sticky,'Sticky');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Tabs module.
   * @module foundation.tabs
   * @requires foundation.util.keyboard
   * @requires foundation.util.timerAndImageLoader if tabs contain images
   */var Tabs=function(){/**
     * Creates a new instance of tabs.
     * @class
     * @fires Tabs#init
     * @param {jQuery} element - jQuery object to make into tabs.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Tabs(element,options){_classCallCheck(this,Tabs);this.$element=element;this.options=$.extend({},Tabs.defaults,this.$element.data(),options);this._init();Foundation.registerPlugin(this,'Tabs');Foundation.Keyboard.register('Tabs',{'ENTER':'open','SPACE':'open','ARROW_RIGHT':'next','ARROW_UP':'previous','ARROW_DOWN':'next','ARROW_LEFT':'previous'// 'TAB': 'next',
// 'SHIFT_TAB': 'previous'
});}/**
     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.
     * @private
     */_createClass(Tabs,[{key:'_init',value:function _init(){var _this=this;this.$tabTitles=this.$element.find('.'+this.options.linkClass);this.$tabContent=$('[data-tabs-content="'+this.$element[0].id+'"]');this.$tabTitles.each(function(){var $elem=$(this),$link=$elem.find('a'),isActive=$elem.hasClass('is-active'),hash=$link[0].hash.slice(1),linkId=$link[0].id?$link[0].id:hash+'-label',$tabContent=$('#'+hash);$elem.attr({'role':'presentation'});$link.attr({'role':'tab','aria-controls':hash,'aria-selected':isActive,'id':linkId});$tabContent.attr({'role':'tabpanel','aria-hidden':!isActive,'aria-labelledby':linkId});if(isActive&&_this.options.autoFocus){$link.focus();}});if(this.options.matchHeight){var $images=this.$tabContent.find('img');if($images.length){Foundation.onImagesLoaded($images,this._setHeight.bind(this));}else{this._setHeight();}}this._events();}/**
       * Adds event handlers for items within the tabs.
       * @private
       */},{key:'_events',value:function _events(){this._addKeyHandler();this._addClickHandler();this._setHeightMqHandler=null;if(this.options.matchHeight){this._setHeightMqHandler=this._setHeight.bind(this);$(window).on('changed.zf.mediaquery',this._setHeightMqHandler);}}/**
       * Adds click handlers for items within the tabs.
       * @private
       */},{key:'_addClickHandler',value:function _addClickHandler(){var _this=this;this.$element.off('click.zf.tabs').on('click.zf.tabs','.'+this.options.linkClass,function(e){e.preventDefault();e.stopPropagation();if($(this).hasClass('is-active')){return;}_this._handleTabChange($(this));});}/**
       * Adds keyboard event handlers for items within the tabs.
       * @private
       */},{key:'_addKeyHandler',value:function _addKeyHandler(){var _this=this;var $firstTab=_this.$element.find('li:first-of-type');var $lastTab=_this.$element.find('li:last-of-type');this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs',function(e){if(e.which===9)return;var $element=$(this),$elements=$element.parent('ul').children('li'),$prevElement,$nextElement;$elements.each(function(i){if($(this).is($element)){if(_this.options.wrapOnKeys){$prevElement=i===0?$elements.last():$elements.eq(i-1);$nextElement=i===$elements.length-1?$elements.first():$elements.eq(i+1);}else{$prevElement=$elements.eq(Math.max(0,i-1));$nextElement=$elements.eq(Math.min(i+1,$elements.length-1));}return;}});// handle keyboard event with keyboard util
Foundation.Keyboard.handleKey(e,'Tabs',{open:function open(){$element.find('[role="tab"]').focus();_this._handleTabChange($element);},previous:function previous(){$prevElement.find('[role="tab"]').focus();_this._handleTabChange($prevElement);},next:function next(){$nextElement.find('[role="tab"]').focus();_this._handleTabChange($nextElement);},handled:function handled(){e.stopPropagation();e.preventDefault();}});});}/**
       * Opens the tab `$targetContent` defined by `$target`.
       * @param {jQuery} $target - Tab to open.
       * @fires Tabs#change
       * @function
       */},{key:'_handleTabChange',value:function _handleTabChange($target){var $tabLink=$target.find('[role="tab"]'),hash=$tabLink[0].hash,$targetContent=this.$tabContent.find(hash),$oldTab=this.$element.find('.'+this.options.linkClass+'.is-active').removeClass('is-active').find('[role="tab"]').attr({'aria-selected':'false'});$('#'+$oldTab.attr('aria-controls')).removeClass('is-active').attr({'aria-hidden':'true'});$target.addClass('is-active');$tabLink.attr({'aria-selected':'true'});$targetContent.addClass('is-active').attr({'aria-hidden':'false'});/**
         * Fires when the plugin has successfully changed tabs.
         * @event Tabs#change
         */this.$element.trigger('change.zf.tabs',[$target]);}/**
       * Public method for selecting a content pane to display.
       * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.
       * @function
       */},{key:'selectTab',value:function selectTab(elem){var idStr;if((typeof elem==='undefined'?'undefined':_typeof(elem))==='object'){idStr=elem[0].id;}else{idStr=elem;}if(idStr.indexOf('#')<0){idStr='#'+idStr;}var $target=this.$tabTitles.find('[href="'+idStr+'"]').parent('.'+this.options.linkClass);this._handleTabChange($target);}},{key:'_setHeight',/**
       * Sets the height of each panel to the height of the tallest panel.
       * If enabled in options, gets called on media query change.
       * If loading content via external source, can be called directly or with _reflow.
       * @function
       * @private
       */value:function _setHeight(){var max=0;this.$tabContent.find('.'+this.options.panelClass).css('height','').each(function(){var panel=$(this),isActive=panel.hasClass('is-active');if(!isActive){panel.css({'visibility':'hidden','display':'block'});}var temp=this.getBoundingClientRect().height;if(!isActive){panel.css({'visibility':'','display':''});}max=temp>max?temp:max;}).css('height',max+'px');}/**
       * Destroys an instance of an tabs.
       * @fires Tabs#destroyed
       */},{key:'destroy',value:function destroy(){this.$element.find('.'+this.options.linkClass).off('.zf.tabs').hide().end().find('.'+this.options.panelClass).hide();if(this.options.matchHeight){if(this._setHeightMqHandler!=null){$(window).off('changed.zf.mediaquery',this._setHeightMqHandler);}}Foundation.unregisterPlugin(this);}}]);return Tabs;}();Tabs.defaults={/**
     * Allows the window to scroll to content of active pane on load if set to true.
     * @option
     * @example false
     */autoFocus:false,/**
     * Allows keyboard input to 'wrap' around the tab links.
     * @option
     * @example true
     */wrapOnKeys:true,/**
     * Allows the tab content panes to match heights if set to true.
     * @option
     * @example false
     */matchHeight:false,/**
     * Class applied to `li`'s in tab link list.
     * @option
     * @example 'tabs-title'
     */linkClass:'tabs-title',/**
     * Class applied to the content containers.
     * @option
     * @example 'tabs-panel'
     */panelClass:'tabs-panel'};function checkClass($elem){return $elem.hasClass('is-active');}// Window exports
Foundation.plugin(Tabs,'Tabs');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();!function($){/**
   * Toggler module.
   * @module foundation.toggler
   * @requires foundation.util.motion
   * @requires foundation.util.triggers
   */var Toggler=function(){/**
     * Creates a new instance of Toggler.
     * @class
     * @fires Toggler#init
     * @param {Object} element - jQuery object to add the trigger to.
     * @param {Object} options - Overrides to the default plugin settings.
     */function Toggler(element,options){_classCallCheck(this,Toggler);this.$element=element;this.options=$.extend({},Toggler.defaults,element.data(),options);this.className='';this._init();this._events();Foundation.registerPlugin(this,'Toggler');}/**
     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.
     * @function
     * @private
     */_createClass(Toggler,[{key:'_init',value:function _init(){var input;// Parse animation classes if they were set
if(this.options.animate){input=this.options.animate.split(' ');this.animationIn=input[0];this.animationOut=input[1]||null;}// Otherwise, parse toggle class
else{input=this.$element.data('toggler');// Allow for a . at the beginning of the string
this.className=input[0]==='.'?input.slice(1):input;}// Add ARIA attributes to triggers
var id=this.$element[0].id;$('[data-open="'+id+'"], [data-close="'+id+'"], [data-toggle="'+id+'"]').attr('aria-controls',id);// If the target is hidden, add aria-hidden
this.$element.attr('aria-expanded',this.$element.is(':hidden')?false:true);}/**
       * Initializes events for the toggle trigger.
       * @function
       * @private
       */},{key:'_events',value:function _events(){this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger',this.toggle.bind(this));}/**
       * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was "on" or "off".
       * @function
       * @fires Toggler#on
       * @fires Toggler#off
       */},{key:'toggle',value:function toggle(){this[this.options.animate?'_toggleAnimate':'_toggleClass']();}},{key:'_toggleClass',value:function _toggleClass(){this.$element.toggleClass(this.className);var isOn=this.$element.hasClass(this.className);if(isOn){/**
           * Fires if the target element has the class after a toggle.
           * @event Toggler#on
           */this.$element.trigger('on.zf.toggler');}else{/**
           * Fires if the target element does not have the class after a toggle.
           * @event Toggler#off
           */this.$element.trigger('off.zf.toggler');}this._updateARIA(isOn);}},{key:'_toggleAnimate',value:function _toggleAnimate(){var _this=this;if(this.$element.is(':hidden')){Foundation.Motion.animateIn(this.$element,this.animationIn,function(){_this._updateARIA(true);this.trigger('on.zf.toggler');});}else{Foundation.Motion.animateOut(this.$element,this.animationOut,function(){_this._updateARIA(false);this.trigger('off.zf.toggler');});}}},{key:'_updateARIA',value:function _updateARIA(isOn){this.$element.attr('aria-expanded',isOn?true:false);}/**
       * Destroys the instance of Toggler on the element.
       * @function
       */},{key:'destroy',value:function destroy(){this.$element.off('.zf.toggler');Foundation.unregisterPlugin(this);}}]);return Toggler;}();Toggler.defaults={/**
     * Tells the plugin if the element should animated when toggled.
     * @option
     * @example false
     */animate:false};// Window exports
Foundation.plugin(Toggler,'Toggler');}(jQuery);var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}!function($){/**
   * Tooltip module.
   * @module foundation.tooltip
   * @requires foundation.util.box
   * @requires foundation.util.triggers
   */var Tooltip=function(){/**
     * Creates a new instance of a Tooltip.
     * @class
     * @fires Tooltip#init
     * @param {jQuery} element - jQuery object to attach a tooltip to.
     * @param {Object} options - object to extend the default configuration.
     */function Tooltip(element,options){_classCallCheck(this,Tooltip);this.$element=element;this.options=$.extend({},Tooltip.defaults,this.$element.data(),options);this.isActive=false;this.isClick=false;this._init();Foundation.registerPlugin(this,'Tooltip');}/**
     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.
     * @private
     */_createClass(Tooltip,[{key:'_init',value:function _init(){var elemId=this.$element.attr('aria-describedby')||Foundation.GetYoDigits(6,'tooltip');this.options.positionClass=this.options.positionClass||this._getPositionClass(this.$element);this.options.tipText=this.options.tipText||this.$element.attr('title');this.template=this.options.template?$(this.options.template):this._buildTemplate(elemId);this.template.appendTo(document.body).text(this.options.tipText).hide();this.$element.attr({'title':'','aria-describedby':elemId,'data-yeti-box':elemId,'data-toggle':elemId,'data-resize':elemId}).addClass(this.triggerClass);//helper variables to track movement on collisions
this.usedPositions=[];this.counter=4;this.classChanged=false;this._events();}/**
       * Grabs the current positioning class, if present, and returns the value or an empty string.
       * @private
       */},{key:'_getPositionClass',value:function _getPositionClass(element){if(!element){return'';}// var position = element.attr('class').match(/top|left|right/g);
var position=element[0].className.match(/\b(top|left|right)\b/g);position=position?position[0]:'';return position;}},{key:'_buildTemplate',/**
       * builds the tooltip element, adds attributes, and returns the template.
       * @private
       */value:function _buildTemplate(id){var templateClasses=(this.options.tooltipClass+' '+this.options.positionClass+' '+this.options.templateClasses).trim();var $template=$('<div></div>').addClass(templateClasses).attr({'role':'tooltip','aria-hidden':true,'data-is-active':false,'data-is-focus':false,'id':id});return $template;}/**
       * Function that gets called if a collision event is detected.
       * @param {String} position - positioning class to try
       * @private
       */},{key:'_reposition',value:function _reposition(position){this.usedPositions.push(position?position:'bottom');//default, try switching to opposite side
if(!position&&this.usedPositions.indexOf('top')<0){this.template.addClass('top');}else if(position==='top'&&this.usedPositions.indexOf('bottom')<0){this.template.removeClass(position);}else if(position==='left'&&this.usedPositions.indexOf('right')<0){this.template.removeClass(position).addClass('right');}else if(position==='right'&&this.usedPositions.indexOf('left')<0){this.template.removeClass(position).addClass('left');}//if default change didn't work, try bottom or left first
else if(!position&&this.usedPositions.indexOf('top')>-1&&this.usedPositions.indexOf('left')<0){this.template.addClass('left');}else if(position==='top'&&this.usedPositions.indexOf('bottom')>-1&&this.usedPositions.indexOf('left')<0){this.template.removeClass(position).addClass('left');}else if(position==='left'&&this.usedPositions.indexOf('right')>-1&&this.usedPositions.indexOf('bottom')<0){this.template.removeClass(position);}else if(position==='right'&&this.usedPositions.indexOf('left')>-1&&this.usedPositions.indexOf('bottom')<0){this.template.removeClass(position);}//if nothing cleared, set to bottom
else{this.template.removeClass(position);}this.classChanged=true;this.counter--;}/**
       * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.
       * if the tooltip is larger than the screen width, default to full width - any user selected margin
       * @private
       */},{key:'_setPosition',value:function _setPosition(){var position=this._getPositionClass(this.template),$tipDims=Foundation.Box.GetDimensions(this.template),$anchorDims=Foundation.Box.GetDimensions(this.$element),direction=position==='left'?'left':position==='right'?'left':'top',param=direction==='top'?'height':'width',offset=param==='height'?this.options.vOffset:this.options.hOffset,_this=this;if($tipDims.width>=$tipDims.windowDims.width||!this.counter&&!Foundation.Box.ImNotTouchingYou(this.template)){this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,'center bottom',this.options.vOffset,this.options.hOffset,true)).css({// this.$element.offset(Foundation.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({
'width':$anchorDims.windowDims.width-this.options.hOffset*2,'height':'auto'});return false;}this.template.offset(Foundation.Box.GetOffsets(this.template,this.$element,'center '+(position||'bottom'),this.options.vOffset,this.options.hOffset));while(!Foundation.Box.ImNotTouchingYou(this.template)&&this.counter){this._reposition(position);this._setPosition();}}/**
       * reveals the tooltip, and fires an event to close any other open tooltips on the page
       * @fires Tooltip#closeme
       * @fires Tooltip#show
       * @function
       */},{key:'show',value:function show(){if(this.options.showOn!=='all'&&!Foundation.MediaQuery.atLeast(this.options.showOn)){// console.error('The screen is too small to display this tooltip');
return false;}var _this=this;this.template.css('visibility','hidden').show();this._setPosition();/**
         * Fires to close all other open tooltips on the page
         * @event Closeme#tooltip
         */this.$element.trigger('closeme.zf.tooltip',this.template.attr('id'));this.template.attr({'data-is-active':true,'aria-hidden':false});_this.isActive=true;// console.log(this.template);
this.template.stop().hide().css('visibility','').fadeIn(this.options.fadeInDuration,function(){//maybe do stuff?
});/**
         * Fires when the tooltip is shown
         * @event Tooltip#show
         */this.$element.trigger('show.zf.tooltip');}/**
       * Hides the current tooltip, and resets the positioning class if it was changed due to collision
       * @fires Tooltip#hide
       * @function
       */},{key:'hide',value:function hide(){// console.log('hiding', this.$element.data('yeti-box'));
var _this=this;this.template.stop().attr({'aria-hidden':true,'data-is-active':false}).fadeOut(this.options.fadeOutDuration,function(){_this.isActive=false;_this.isClick=false;if(_this.classChanged){_this.template.removeClass(_this._getPositionClass(_this.template)).addClass(_this.options.positionClass);_this.usedPositions=[];_this.counter=4;_this.classChanged=false;}});/**
         * fires when the tooltip is hidden
         * @event Tooltip#hide
         */this.$element.trigger('hide.zf.tooltip');}/**
       * adds event listeners for the tooltip and its anchor
       * TODO combine some of the listeners like focus and mouseenter, etc.
       * @private
       */},{key:'_events',value:function _events(){var _this=this;var $template=this.template;var isFocus=false;if(!this.options.disableHover){this.$element.on('mouseenter.zf.tooltip',function(e){if(!_this.isActive){_this.timeout=setTimeout(function(){_this.show();},_this.options.hoverDelay);}}).on('mouseleave.zf.tooltip',function(e){clearTimeout(_this.timeout);if(!isFocus||_this.isClick&&!_this.options.clickOpen){_this.hide();}});}if(this.options.clickOpen){this.$element.on('mousedown.zf.tooltip',function(e){e.stopImmediatePropagation();if(_this.isClick){//_this.hide();
// _this.isClick = false;
}else{_this.isClick=true;if((_this.options.disableHover||!_this.$element.attr('tabindex'))&&!_this.isActive){_this.show();}}});}else{this.$element.on('mousedown.zf.tooltip',function(e){e.stopImmediatePropagation();_this.isClick=true;});}if(!this.options.disableForTouch){this.$element.on('tap.zf.tooltip touchend.zf.tooltip',function(e){_this.isActive?_this.hide():_this.show();});}this.$element.on({// 'toggle.zf.trigger': this.toggle.bind(this),
// 'close.zf.trigger': this.hide.bind(this)
'close.zf.trigger':this.hide.bind(this)});this.$element.on('focus.zf.tooltip',function(e){isFocus=true;if(_this.isClick){// If we're not showing open on clicks, we need to pretend a click-launched focus isn't
// a real focus, otherwise on hover and come back we get bad behavior
if(!_this.options.clickOpen){isFocus=false;}return false;}else{_this.show();}}).on('focusout.zf.tooltip',function(e){isFocus=false;_this.isClick=false;_this.hide();}).on('resizeme.zf.trigger',function(){if(_this.isActive){_this._setPosition();}});}/**
       * adds a toggle method, in addition to the static show() & hide() functions
       * @function
       */},{key:'toggle',value:function toggle(){if(this.isActive){this.hide();}else{this.show();}}/**
       * Destroys an instance of tooltip, removes template element from the view.
       * @function
       */},{key:'destroy',value:function destroy(){this.$element.attr('title',this.template.text()).off('.zf.trigger .zf.tootip')//  .removeClass('has-tip')
.removeAttr('aria-describedby').removeAttr('data-yeti-box').removeAttr('data-toggle').removeAttr('data-resize');this.template.remove();Foundation.unregisterPlugin(this);}}]);return Tooltip;}();Tooltip.defaults={disableForTouch:false,/**
     * Time, in ms, before a tooltip should open on hover.
     * @option
     * @example 200
     */hoverDelay:200,/**
     * Time, in ms, a tooltip should take to fade into view.
     * @option
     * @example 150
     */fadeInDuration:150,/**
     * Time, in ms, a tooltip should take to fade out of view.
     * @option
     * @example 150
     */fadeOutDuration:150,/**
     * Disables hover events from opening the tooltip if set to true
     * @option
     * @example false
     */disableHover:false,/**
     * Optional addtional classes to apply to the tooltip template on init.
     * @option
     * @example 'my-cool-tip-class'
     */templateClasses:'',/**
     * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.
     * @option
     * @example 'tooltip'
     */tooltipClass:'tooltip',/**
     * Class applied to the tooltip anchor element.
     * @option
     * @example 'has-tip'
     */triggerClass:'has-tip',/**
     * Minimum breakpoint size at which to open the tooltip.
     * @option
     * @example 'small'
     */showOn:'small',/**
     * Custom template to be used to generate markup for tooltip.
     * @option
     * @example '&lt;div class="tooltip"&gt;&lt;/div&gt;'
     */template:'',/**
     * Text displayed in the tooltip template on open.
     * @option
     * @example 'Some cool space fact here.'
     */tipText:'',touchCloseText:'Tap to close.',/**
     * Allows the tooltip to remain open if triggered with a click or touch event.
     * @option
     * @example true
     */clickOpen:true,/**
     * Additional positioning classes, set by the JS
     * @option
     * @example 'top'
     */positionClass:'',/**
     * Distance, in pixels, the template should push away from the anchor on the Y axis.
     * @option
     * @example 10
     */vOffset:10,/**
     * Distance, in pixels, the template should push away from the anchor on the X axis, if aligned to a side.
     * @option
     * @example 12
     */hOffset:12};/**
   * TODO utilize resize event trigger
   */// Window exports
Foundation.plugin(Tooltip,'Tooltip');}(jQuery);

// Import foundation from bower
// export as function
var foundation = function () {
	// initalize foundation
	jQuery(document).foundation();

	// notify css that foundation javascript is up and running
	jQuery('body').addClass('foundation-ready');
}

var Navigation = function () {
	function Navigation(body) {
		classCallCheck(this, Navigation);

		this.$body = body;
		this.$content = this.$body.find('div[role="document"]');
		this.$trigger = this.$body.find('[data-navigation-trigger]');
		this.$inner = this.$body.find('[data-navigation-container]');
		this.bodyActiveClass = 'nav-open';
		this.animationDelay = '500';
		this._bindEvents();
	}

	// Private Methods


	createClass(Navigation, [{
		key: '_bindEvents',
		value: function _bindEvents() {
			var _this = this;

			this.$trigger.on('click', function () {
				_this.toggle();
			});

			this.$inner.find('li a').last().on('keydown', function (e) {
				if (!e.shiftKey) {
					e.preventDefault();
					_this.close();
					_this.$content.find('a').first().focus();
				}
			});

			this.$inner.find('li a').first().on('focus', function (e) {
				if (!e.shiftKey) {
					e.preventDefault();
					_this.open();
				}
			});
		}
	}, {
		key: '_hasBodyClass',
		value: function _hasBodyClass() {
			return this.$body.hasClass(this.bodyActiveClass);
		}
	}, {
		key: '_addBodyClass',
		value: function _addBodyClass() {
			if (!this._hasBodyClass()) this.$body.addClass(this.bodyActiveClass);
			this.$body.trigger('navigation.class.added');
		}
	}, {
		key: '_removeBodyClass',
		value: function _removeBodyClass() {
			if (this._hasBodyClass()) this.$body.removeClass(this.bodyActiveClass);
			this.$body.trigger('navigation.class.removed');
		}

		// Public Methods

	}, {
		key: 'toggle',
		value: function toggle() {
			if (!this._hasBodyClass()) this.open();else this.close();
		}
	}, {
		key: 'open',
		value: function open() {
			var _this2 = this;

			this._addBodyClass();
			this.$trigger.addClass('is-active');
			setTimeout(function () {
				_this2.$body.trigger('navigation.opened');
			}, this.animationDelay);
		}
	}, {
		key: 'close',
		value: function close() {
			var _this3 = this;

			this._removeBodyClass();
			this.$trigger.removeClass('is-active');
			setTimeout(function () {
				_this3.$body.trigger('navigation.closed');
			}, this.animationDelay);
		}

		// methods

	}]);
	return Navigation;
}();

var common = function () {
	// Bind the navigation
	new Navigation(jQuery('body'));
}

var page = function () {}

var single = function () {}

// Export route functions


var routes = Object.freeze({
	common: common,
	page: page,
	single: single
});

// Load dependencies
// Load modules
jQuery(document).ready(function () {

	// Let CSS know that we're ready
	jQuery('body').addClass('theme-ready');

	// Load router
	new jQuery.DOMRouter.router(document, routes);

	// Initialize Foundation
	foundation();
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJhcHAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uICgkKSB7XG5cblx0XHRcdFx0aWYgKCEkLmZuLndhdGNoICYmICEkLmZuLnVud2F0Y2gpIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8qKlxuICAgICAgICAgKiBXYXRjaGVzIGFuIGVsZW1lbnQgZm9yIGEgY2hhbmdlIGluIGEgcHJvcGVydHlcbiAgICAgICAgICogQHBhcmFtICB7c3RyaW5nfSAgIGlkIFRoZSBwcm9wZXJ0eSB0byB3YXRjaFxuICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBzb21ldGhpbmcgaGFzIGNoYW5nZWRcbiAgICAgICAgICovXG5cdFx0XHRcdFx0XHRcdFx0JC5mbi53YXRjaCA9IGZ1bmN0aW9uIChpZCwgZm4pIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBvbGRWYWwgPSBzZWxmW2lkXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JChzZWxmKS5kYXRhKCd3YXRjaF90aW1lcicsIHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoc2VsZltpZF0gIT09IG9sZFZhbCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4uY2FsbChzZWxmLCBpZCwgb2xkVmFsLCBzZWxmW2lkXSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvbGRWYWwgPSBzZWxmW2lkXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sIDEwMCkpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdFx0XHRcdC8qKlxuICAgICAgICAgKiBVbndhdGNoZXMgYW4gZWxlbWVudFxuICAgICAgICAgKi9cblx0XHRcdFx0XHRcdFx0XHQkLmZuLnVud2F0Y2ggPSBmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRjbGVhckludGVydmFsKCQodGhpcykuZGF0YSgnd2F0Y2hfdGltZXInKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCEkLkRPTVJvdXRlcikge1xuXHRcdFx0XHRcdFx0XHRcdCQuRE9NUm91dGVyID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cm91dGVyOiBmdW5jdGlvbiByb3V0ZXIoZWwsIHJvdXRlcykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgYmFzZSA9IHRoaXM7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuJGVsID0gJChlbCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuZWwgPSBlbDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmFzZS4kZWwuZGF0YSgnRE9NUm91dGVyLnJvdXRlcicsIGJhc2UpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuZWxlbWVudCA9IGJhc2UuJGVsLmZpbmQoJC5ET01Sb3V0ZXIuZGVmYXVsdHMuZWxlbWVudCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmFzZS5lbGVtZW50LmFkZENsYXNzKCdkb20tcm91dGVyLXJlYWR5Jyk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyoqXG4gICAgICAgICAgICAgICAgICogSW5pdGFsaXplIHRoZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAgICAgICAgICAgICAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYXNlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmFzZS5yb3V0ZXMgPSByb3V0ZXM7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JChkb2N1bWVudCkucmVhZHkoYmFzZS5sb2FkKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuZXhlY3V0ZWQgPSBbXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuZWxlbWVudC53YXRjaCgnY2xhc3NOYW1lJywgZnVuY3Rpb24gKHByb3BlcnR5LCBvbGRDbGFzc2VzLCBuZXdDbGFzc2VzKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR2YXIgY2xhc3NlcyA9IG5ld0NsYXNzZXMucmVwbGFjZSgvLS9nLCAnXycpLnNwbGl0KC9cXHMrLyk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCQuZWFjaChjbGFzc2VzLCBmdW5jdGlvbiAoaSwgY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICghYmFzZS5yb3V0ZUV4ZWN1dGVkKGNsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYXNlLmZpcmUoY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYXNlLmV4ZWN1dGVkLnB1c2goY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlmIGEgcm91dGUgaGFzIGJlZW4gZXhlY3V0ZWQgYWxyZWFkeVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge3N0cmluZ30gXHRyb3V0ZSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2Uucm91dGVFeGVjdXRlZCA9IGZ1bmN0aW9uIChyb3V0ZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLmV4ZWN1dGVkLmluZGV4T2Yocm91dGUpID4gLTE7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyoqXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgY2xhc3NlcyBvbiB0aGUgYm9keSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuY2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5lbGVtZW50LmdldCgwKS5jbGFzc05hbWUucmVwbGFjZSgvLS9nLCAnXycpLnNwbGl0KC9cXHMrLyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0LyoqXG4gICAgICAgICAgICAgICAgICogTG9hZCBhbGwgZXZlbnRzIHRvIGJlIGZpcmVkXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgICAgICAgICAgICAgKi9cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YmFzZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuZmlyZSgnY29tbW9uJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JC5lYWNoKGJhc2UuY2xhc3NlcygpLCBmdW5jdGlvbiAoaSwgY2xhc3NOYW1lKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYXNlLmZpcmUoY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJhc2UuZXhlY3V0ZWQucHVzaChjbGFzc05hbWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8qKlxuICAgICAgICAgICAgICAgICAqIEZpcmUgYW4gZXZlbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmUgZmlyZWRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJncyBBcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtWb2lkfVxuICAgICAgICAgICAgICAgICAqL1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYXNlLmZpcmUgPSBmdW5jdGlvbiAoZnVuYywgYXJncykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHZhciBmaXJlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgICByb3V0ZXMgPSBiYXNlLnJvdXRlcztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZpcmUgPSBmdW5jICE9PSAnJztcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmaXJlID0gZmlyZSAmJiByb3V0ZXNbZnVuY107XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZmlyZSA9IGZpcmUgJiYgdHlwZW9mIHJvdXRlc1tmdW5jXSA9PT0gJ2Z1bmN0aW9uJztcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChmaXJlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyb3V0ZXNbZnVuY10oYXJncyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFJ1biBpbml0aWFsaXplclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRiYXNlLmluaXQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0czoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50OiAnYm9keSdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0JC5mbi5yb3V0ZXIgPSBmdW5jdGlvbiAocm91dGVzKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgJC5ET01Sb3V0ZXIucm91dGVyKHRoaXMsIHJvdXRlcyk7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0aWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kdWxlLmV4cG9ydHMgPSAkLkRPTVJvdXRlci5yb3V0ZXI7XG5cdFx0XHRcdH1cbn0pKGpRdWVyeSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG5cblxuXG5cbnZhciBhc3luY0dlbmVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXdhaXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGdlbikge1xuICAgIHZhciBmcm9udCwgYmFjaztcblxuICAgIGZ1bmN0aW9uIHNlbmQoa2V5LCBhcmcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgIGFyZzogYXJnLFxuICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChiYWNrKSB7XG4gICAgICAgICAgYmFjayA9IGJhY2submV4dCA9IHJlcXVlc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZnJvbnQgPSBiYWNrID0gcmVxdWVzdDtcbiAgICAgICAgICByZXN1bWUoa2V5LCBhcmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXN1bWUoa2V5LCBhcmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXdhaXRWYWx1ZSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZS52YWx1ZSkudGhlbihmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXN1bWUoXCJuZXh0XCIsIGFyZyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmVzdW1lKFwidGhyb3dcIiwgYXJnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0bGUocmVzdWx0LmRvbmUgPyBcInJldHVyblwiIDogXCJub3JtYWxcIiwgcmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldHRsZShcInRocm93XCIsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dGxlKHR5cGUsIHZhbHVlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInJldHVyblwiOlxuICAgICAgICAgIGZyb250LnJlc29sdmUoe1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0aHJvd1wiOlxuICAgICAgICAgIGZyb250LnJlamVjdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGZyb250ID0gZnJvbnQubmV4dDtcblxuICAgICAgaWYgKGZyb250KSB7XG4gICAgICAgIHJlc3VtZShmcm9udC5rZXksIGZyb250LmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbnZva2UgPSBzZW5kO1xuXG4gICAgaWYgKHR5cGVvZiBnZW4ucmV0dXJuICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMucmV0dXJuID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHtcbiAgICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJuZXh0XCIsIGFyZyk7XG4gIH07XG5cbiAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJ0aHJvd1wiLCBhcmcpO1xuICB9O1xuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ludm9rZShcInJldHVyblwiLCBhcmcpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgd3JhcDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEFzeW5jR2VuZXJhdG9yKGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGF3YWl0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiBuZXcgQXdhaXRWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxuXG5cbnZhciBnZXQkMSA9IGZ1bmN0aW9uIGdldCQxKG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0JDEocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBzZXQgPSBmdW5jdGlvbiBzZXQob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgc2V0KHBhcmVudCwgcHJvcGVydHksIHZhbHVlLCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjICYmIGRlc2Mud3JpdGFibGUpIHtcbiAgICBkZXNjLnZhbHVlID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNldHRlciA9IGRlc2Muc2V0O1xuXG4gICAgaWYgKHNldHRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXR0ZXIuY2FsbChyZWNlaXZlciwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbiFmdW5jdGlvbigkKXtcInVzZSBzdHJpY3RcIjt2YXIgRk9VTkRBVElPTl9WRVJTSU9OPSc2LjIuMyc7Ly8gR2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4vLyBUaGlzIGlzIGF0dGFjaGVkIHRvIHRoZSB3aW5kb3csIG9yIHVzZWQgYXMgYSBtb2R1bGUgZm9yIEFNRC9Ccm93c2VyaWZ5XG52YXIgRm91bmRhdGlvbj17dmVyc2lvbjpGT1VOREFUSU9OX1ZFUlNJT04sLyoqXG4gICAgICogU3RvcmVzIGluaXRpYWxpemVkIHBsdWdpbnMuXG4gICAgICovX3BsdWdpbnM6e30sLyoqXG4gICAgICogU3RvcmVzIGdlbmVyYXRlZCB1bmlxdWUgaWRzIGZvciBwbHVnaW4gaW5zdGFuY2VzXG4gICAgICovX3V1aWRzOltdLC8qKlxuICAgICAqIFJldHVybnMgYSBib29sZWFuIGZvciBSVEwgc3VwcG9ydFxuICAgICAqL3J0bDpmdW5jdGlvbiBydGwoKXtyZXR1cm4gJCgnaHRtbCcpLmF0dHIoJ2RpcicpPT09J3J0bCc7fSwvKipcbiAgICAgKiBEZWZpbmVzIGEgRm91bmRhdGlvbiBwbHVnaW4sIGFkZGluZyBpdCB0byB0aGUgYEZvdW5kYXRpb25gIG5hbWVzcGFjZSBhbmQgdGhlIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplIHdoZW4gcmVmbG93aW5nLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cbiAgICAgKi9wbHVnaW46ZnVuY3Rpb24gcGx1Z2luKF9wbHVnaW4sbmFtZSl7Ly8gT2JqZWN0IGtleSB0byB1c2Ugd2hlbiBhZGRpbmcgdG8gZ2xvYmFsIEZvdW5kYXRpb24gb2JqZWN0XG4vLyBFeGFtcGxlczogRm91bmRhdGlvbi5SZXZlYWwsIEZvdW5kYXRpb24uT2ZmQ2FudmFzXG52YXIgY2xhc3NOYW1lPW5hbWV8fGZ1bmN0aW9uTmFtZShfcGx1Z2luKTsvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cbi8vIEV4YW1wbGVzOiBkYXRhLXJldmVhbCwgZGF0YS1vZmYtY2FudmFzXG52YXIgYXR0ck5hbWU9aHlwaGVuYXRlKGNsYXNzTmFtZSk7Ly8gQWRkIHRvIHRoZSBGb3VuZGF0aW9uIG9iamVjdCBhbmQgdGhlIHBsdWdpbnMgbGlzdCAoZm9yIHJlZmxvd2luZylcbnRoaXMuX3BsdWdpbnNbYXR0ck5hbWVdPXRoaXNbY2xhc3NOYW1lXT1fcGx1Z2luO30sLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogUG9wdWxhdGVzIHRoZSBfdXVpZHMgYXJyYXkgd2l0aCBwb2ludGVycyB0byBlYWNoIGluZGl2aWR1YWwgcGx1Z2luIGluc3RhbmNlLlxuICAgICAqIEFkZHMgdGhlIGB6ZlBsdWdpbmAgZGF0YS1hdHRyaWJ1dGUgdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkIHBsdWdpbnMgdG8gYWxsb3cgdXNlIG9mICQoc2VsZWN0b3IpLmZvdW5kYXRpb24obWV0aG9kKSBjYWxscy5cbiAgICAgKiBBbHNvIGZpcmVzIHRoZSBpbml0aWFsaXphdGlvbiBldmVudCBmb3IgZWFjaCBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRoZSBuYW1lIG9mIHRoZSBwbHVnaW4sIHBhc3NlZCBhcyBhIGNhbWVsQ2FzZWQgc3RyaW5nLlxuICAgICAqIEBmaXJlcyBQbHVnaW4jaW5pdFxuICAgICAqL3JlZ2lzdGVyUGx1Z2luOmZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbixuYW1lKXt2YXIgcGx1Z2luTmFtZT1uYW1lP2h5cGhlbmF0ZShuYW1lKTpmdW5jdGlvbk5hbWUocGx1Z2luLmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO3BsdWdpbi51dWlkPXRoaXMuR2V0WW9EaWdpdHMoNixwbHVnaW5OYW1lKTtpZighcGx1Z2luLiRlbGVtZW50LmF0dHIoJ2RhdGEtJytwbHVnaW5OYW1lKSl7cGx1Z2luLiRlbGVtZW50LmF0dHIoJ2RhdGEtJytwbHVnaW5OYW1lLHBsdWdpbi51dWlkKTt9aWYoIXBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKXtwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLHBsdWdpbik7fS8qKlxuICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBpbml0aWFsaXplZC5cbiAgICAgICAqIEBldmVudCBQbHVnaW4jaW5pdFxuICAgICAgICovcGx1Z2luLiRlbGVtZW50LnRyaWdnZXIoJ2luaXQuemYuJytwbHVnaW5OYW1lKTt0aGlzLl91dWlkcy5wdXNoKHBsdWdpbi51dWlkKTtyZXR1cm47fSwvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBSZW1vdmVzIHRoZSBwbHVnaW5zIHV1aWQgZnJvbSB0aGUgX3V1aWRzIGFycmF5LlxuICAgICAqIFJlbW92ZXMgdGhlIHpmUGx1Z2luIGRhdGEgYXR0cmlidXRlLCBhcyB3ZWxsIGFzIHRoZSBkYXRhLXBsdWdpbi1uYW1lIGF0dHJpYnV0ZS5cbiAgICAgKiBBbHNvIGZpcmVzIHRoZSBkZXN0cm95ZWQgZXZlbnQgZm9yIHRoZSBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cbiAgICAgKiBAZmlyZXMgUGx1Z2luI2Rlc3Ryb3llZFxuICAgICAqL3VucmVnaXN0ZXJQbHVnaW46ZnVuY3Rpb24gdW5yZWdpc3RlclBsdWdpbihwbHVnaW4pe3ZhciBwbHVnaW5OYW1lPWh5cGhlbmF0ZShmdW5jdGlvbk5hbWUocGx1Z2luLiRlbGVtZW50LmRhdGEoJ3pmUGx1Z2luJykuY29uc3RydWN0b3IpKTt0aGlzLl91dWlkcy5zcGxpY2UodGhpcy5fdXVpZHMuaW5kZXhPZihwbHVnaW4udXVpZCksMSk7cGx1Z2luLiRlbGVtZW50LnJlbW92ZUF0dHIoJ2RhdGEtJytwbHVnaW5OYW1lKS5yZW1vdmVEYXRhKCd6ZlBsdWdpbicpLyoqXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGJlZW4gZGVzdHJveWVkLlxuICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcbiAgICAgICAqLy50cmlnZ2VyKCdkZXN0cm95ZWQuemYuJytwbHVnaW5OYW1lKTtmb3IodmFyIHByb3AgaW4gcGx1Z2luKXtwbHVnaW5bcHJvcF09bnVsbDsvL2NsZWFuIHVwIHNjcmlwdCB0byBwcmVwIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG59cmV0dXJuO30sLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQ2F1c2VzIG9uZSBvciBtb3JlIGFjdGl2ZSBwbHVnaW5zIHRvIHJlLWluaXRpYWxpemUsIHJlc2V0dGluZyBldmVudCBsaXN0ZW5lcnMsIHJlY2FsY3VsYXRpbmcgcG9zaXRpb25zLCBldGMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBsdWdpbnMgLSBvcHRpb25hbCBzdHJpbmcgb2YgYW4gaW5kaXZpZHVhbCBwbHVnaW4ga2V5LCBhdHRhaW5lZCBieSBjYWxsaW5nIGAkKGVsZW1lbnQpLmRhdGEoJ3BsdWdpbk5hbWUnKWAsIG9yIHN0cmluZyBvZiBhIHBsdWdpbiBjbGFzcyBpLmUuIGAnZHJvcGRvd24nYFxuICAgICAqIEBkZWZhdWx0IElmIG5vIGFyZ3VtZW50IGlzIHBhc3NlZCwgcmVmbG93IGFsbCBjdXJyZW50bHkgYWN0aXZlIHBsdWdpbnMuXG4gICAgICovcmVJbml0OmZ1bmN0aW9uIHJlSW5pdChwbHVnaW5zKXt2YXIgaXNKUT1wbHVnaW5zIGluc3RhbmNlb2YgJDt0cnl7aWYoaXNKUSl7cGx1Z2lucy5lYWNoKGZ1bmN0aW9uKCl7JCh0aGlzKS5kYXRhKCd6ZlBsdWdpbicpLl9pbml0KCk7fSk7fWVsc2V7dmFyIHR5cGU9dHlwZW9mIHBsdWdpbnM9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKHBsdWdpbnMpLF90aGlzPXRoaXMsZm5zPXsnb2JqZWN0JzpmdW5jdGlvbiBvYmplY3QocGxncyl7cGxncy5mb3JFYWNoKGZ1bmN0aW9uKHApe3A9aHlwaGVuYXRlKHApOyQoJ1tkYXRhLScrcCsnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7fSk7fSwnc3RyaW5nJzpmdW5jdGlvbiBzdHJpbmcoKXtwbHVnaW5zPWh5cGhlbmF0ZShwbHVnaW5zKTskKCdbZGF0YS0nK3BsdWdpbnMrJ10nKS5mb3VuZGF0aW9uKCdfaW5pdCcpO30sJ3VuZGVmaW5lZCc6ZnVuY3Rpb24gdW5kZWZpbmVkKCl7dGhpc1snb2JqZWN0J10oT2JqZWN0LmtleXMoX3RoaXMuX3BsdWdpbnMpKTt9fTtmbnNbdHlwZV0ocGx1Z2lucyk7fX1jYXRjaChlcnIpe2NvbnNvbGUuZXJyb3IoZXJyKTt9ZmluYWxseXtyZXR1cm4gcGx1Z2luczt9fSwvKipcbiAgICAgKiByZXR1cm5zIGEgcmFuZG9tIGJhc2UtMzYgdWlkIHdpdGggbmFtZXNwYWNpbmdcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gbnVtYmVyIG9mIHJhbmRvbSBiYXNlLTM2IGRpZ2l0cyBkZXNpcmVkLiBJbmNyZWFzZSBmb3IgbW9yZSByYW5kb20gc3RyaW5ncy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIC0gbmFtZSBvZiBwbHVnaW4gdG8gYmUgaW5jb3Jwb3JhdGVkIGluIHVpZCwgb3B0aW9uYWwuXG4gICAgICogQGRlZmF1bHQge1N0cmluZ30gJycgLSBpZiBubyBwbHVnaW4gbmFtZSBpcyBwcm92aWRlZCwgbm90aGluZyBpcyBhcHBlbmRlZCB0byB0aGUgdWlkLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5pcXVlIGlkXG4gICAgICovR2V0WW9EaWdpdHM6ZnVuY3Rpb24gR2V0WW9EaWdpdHMobGVuZ3RoLG5hbWVzcGFjZSl7bGVuZ3RoPWxlbmd0aHx8NjtyZXR1cm4gTWF0aC5yb3VuZChNYXRoLnBvdygzNixsZW5ndGgrMSktTWF0aC5yYW5kb20oKSpNYXRoLnBvdygzNixsZW5ndGgpKS50b1N0cmluZygzNikuc2xpY2UoMSkrKG5hbWVzcGFjZT8nLScrbmFtZXNwYWNlOicnKTt9LC8qKlxuICAgICAqIEluaXRpYWxpemUgcGx1Z2lucyBvbiBhbnkgZWxlbWVudHMgd2l0aGluIGBlbGVtYCAoYW5kIGBlbGVtYCBpdHNlbGYpIHRoYXQgYXJlbid0IGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcGx1Z2lucyAtIEEgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUuIExlYXZlIHRoaXMgb3V0IHRvIGluaXRpYWxpemUgZXZlcnl0aGluZy5cbiAgICAgKi9yZWZsb3c6ZnVuY3Rpb24gcmVmbG93KGVsZW0scGx1Z2lucyl7Ly8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXG5pZih0eXBlb2YgcGx1Z2lucz09PSd1bmRlZmluZWQnKXtwbHVnaW5zPU9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO30vLyBJZiBwbHVnaW5zIGlzIGEgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggb25lIGl0ZW1cbmVsc2UgaWYodHlwZW9mIHBsdWdpbnM9PT0nc3RyaW5nJyl7cGx1Z2lucz1bcGx1Z2luc107fXZhciBfdGhpcz10aGlzOy8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHBsdWdpblxuJC5lYWNoKHBsdWdpbnMsZnVuY3Rpb24oaSxuYW1lKXsvLyBHZXQgdGhlIGN1cnJlbnQgcGx1Z2luXG52YXIgcGx1Z2luPV90aGlzLl9wbHVnaW5zW25hbWVdOy8vIExvY2FsaXplIHRoZSBzZWFyY2ggdG8gYWxsIGVsZW1lbnRzIGluc2lkZSBlbGVtLCBhcyB3ZWxsIGFzIGVsZW0gaXRzZWxmLCB1bmxlc3MgZWxlbSA9PT0gZG9jdW1lbnRcbnZhciAkZWxlbT0kKGVsZW0pLmZpbmQoJ1tkYXRhLScrbmFtZSsnXScpLmFkZEJhY2soJ1tkYXRhLScrbmFtZSsnXScpOy8vIEZvciBlYWNoIHBsdWdpbiBmb3VuZCwgaW5pdGlhbGl6ZSBpdFxuJGVsZW0uZWFjaChmdW5jdGlvbigpe3ZhciAkZWw9JCh0aGlzKSxvcHRzPXt9Oy8vIERvbid0IGRvdWJsZS1kaXAgb24gcGx1Z2luc1xuaWYoJGVsLmRhdGEoJ3pmUGx1Z2luJykpe2NvbnNvbGUud2FybihcIlRyaWVkIHRvIGluaXRpYWxpemUgXCIrbmFtZStcIiBvbiBhbiBlbGVtZW50IHRoYXQgYWxyZWFkeSBoYXMgYSBGb3VuZGF0aW9uIHBsdWdpbi5cIik7cmV0dXJuO31pZigkZWwuYXR0cignZGF0YS1vcHRpb25zJykpe3ZhciB0aGluZz0kZWwuYXR0cignZGF0YS1vcHRpb25zJykuc3BsaXQoJzsnKS5mb3JFYWNoKGZ1bmN0aW9uKGUsaSl7dmFyIG9wdD1lLnNwbGl0KCc6JykubWFwKGZ1bmN0aW9uKGVsKXtyZXR1cm4gZWwudHJpbSgpO30pO2lmKG9wdFswXSlvcHRzW29wdFswXV09cGFyc2VWYWx1ZShvcHRbMV0pO30pO310cnl7JGVsLmRhdGEoJ3pmUGx1Z2luJyxuZXcgcGx1Z2luKCQodGhpcyksb3B0cykpO31jYXRjaChlcil7Y29uc29sZS5lcnJvcihlcik7fWZpbmFsbHl7cmV0dXJuO319KTt9KTt9LGdldEZuTmFtZTpmdW5jdGlvbk5hbWUsdHJhbnNpdGlvbmVuZDpmdW5jdGlvbiB0cmFuc2l0aW9uZW5kKCRlbGVtKXt2YXIgdHJhbnNpdGlvbnM9eyd0cmFuc2l0aW9uJzondHJhbnNpdGlvbmVuZCcsJ1dlYmtpdFRyYW5zaXRpb24nOid3ZWJraXRUcmFuc2l0aW9uRW5kJywnTW96VHJhbnNpdGlvbic6J3RyYW5zaXRpb25lbmQnLCdPVHJhbnNpdGlvbic6J290cmFuc2l0aW9uZW5kJ307dmFyIGVsZW09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksZW5kO2Zvcih2YXIgdCBpbiB0cmFuc2l0aW9ucyl7aWYodHlwZW9mIGVsZW0uc3R5bGVbdF0hPT0ndW5kZWZpbmVkJyl7ZW5kPXRyYW5zaXRpb25zW3RdO319aWYoZW5kKXtyZXR1cm4gZW5kO31lbHNle2VuZD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7JGVsZW0udHJpZ2dlckhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLFskZWxlbV0pO30sMSk7cmV0dXJuJ3RyYW5zaXRpb25lbmQnO319fTtGb3VuZGF0aW9uLnV0aWw9ey8qKlxuICAgICAqIEZ1bmN0aW9uIGZvciBhcHBseWluZyBhIGRlYm91bmNlIGVmZmVjdCB0byBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhdCBlbmQgb2YgdGltZW91dC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVsYXkgLSBUaW1lIGluIG1zIHRvIGRlbGF5IHRoZSBjYWxsIG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyBmdW5jdGlvblxuICAgICAqL3Rocm90dGxlOmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsZGVsYXkpe3ZhciB0aW1lcj1udWxsO3JldHVybiBmdW5jdGlvbigpe3ZhciBjb250ZXh0PXRoaXMsYXJncz1hcmd1bWVudHM7aWYodGltZXI9PT1udWxsKXt0aW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZnVuYy5hcHBseShjb250ZXh0LGFyZ3MpO3RpbWVyPW51bGw7fSxkZWxheSk7fX07fX07Ly8gVE9ETzogY29uc2lkZXIgbm90IG1ha2luZyB0aGlzIGEgalF1ZXJ5IGZ1bmN0aW9uXG4vLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcbi8qKlxuICAgKiBUaGUgRm91bmRhdGlvbiBqUXVlcnkgbWV0aG9kLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gbWV0aG9kIC0gQW4gYWN0aW9uIHRvIHBlcmZvcm0gb24gdGhlIGN1cnJlbnQgalF1ZXJ5IG9iamVjdC5cbiAgICovdmFyIGZvdW5kYXRpb249ZnVuY3Rpb24gZm91bmRhdGlvbihtZXRob2Qpe3ZhciB0eXBlPXR5cGVvZiBtZXRob2Q9PT0ndW5kZWZpbmVkJz8ndW5kZWZpbmVkJzpfdHlwZW9mKG1ldGhvZCksJG1ldGE9JCgnbWV0YS5mb3VuZGF0aW9uLW1xJyksJG5vSlM9JCgnLm5vLWpzJyk7aWYoISRtZXRhLmxlbmd0aCl7JCgnPG1ldGEgY2xhc3M9XCJmb3VuZGF0aW9uLW1xXCI+JykuYXBwZW5kVG8oZG9jdW1lbnQuaGVhZCk7fWlmKCRub0pTLmxlbmd0aCl7JG5vSlMucmVtb3ZlQ2xhc3MoJ25vLWpzJyk7fWlmKHR5cGU9PT0ndW5kZWZpbmVkJyl7Ly9uZWVkcyB0byBpbml0aWFsaXplIHRoZSBGb3VuZGF0aW9uIG9iamVjdCwgb3IgYW4gaW5kaXZpZHVhbCBwbHVnaW4uXG5Gb3VuZGF0aW9uLk1lZGlhUXVlcnkuX2luaXQoKTtGb3VuZGF0aW9uLnJlZmxvdyh0aGlzKTt9ZWxzZSBpZih0eXBlPT09J3N0cmluZycpey8vYW4gaW5kaXZpZHVhbCBtZXRob2QgdG8gaW52b2tlIG9uIGEgcGx1Z2luIG9yIGdyb3VwIG9mIHBsdWdpbnNcbnZhciBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTsvL2NvbGxlY3QgYWxsIHRoZSBhcmd1bWVudHMsIGlmIG5lY2Vzc2FyeVxudmFyIHBsdWdDbGFzcz10aGlzLmRhdGEoJ3pmUGx1Z2luJyk7Ly9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxuaWYocGx1Z0NsYXNzIT09dW5kZWZpbmVkJiZwbHVnQ2xhc3NbbWV0aG9kXSE9PXVuZGVmaW5lZCl7Ly9tYWtlIHN1cmUgYm90aCB0aGUgY2xhc3MgYW5kIG1ldGhvZCBleGlzdFxuaWYodGhpcy5sZW5ndGg9PT0xKXsvL2lmIHRoZXJlJ3Mgb25seSBvbmUsIGNhbGwgaXQgZGlyZWN0bHkuXG5wbHVnQ2xhc3NbbWV0aG9kXS5hcHBseShwbHVnQ2xhc3MsYXJncyk7fWVsc2V7dGhpcy5lYWNoKGZ1bmN0aW9uKGksZWwpey8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcbnBsdWdDbGFzc1ttZXRob2RdLmFwcGx5KCQoZWwpLmRhdGEoJ3pmUGx1Z2luJyksYXJncyk7fSk7fX1lbHNley8vZXJyb3IgZm9yIG5vIGNsYXNzIG9yIG5vIG1ldGhvZFxudGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwiV2UncmUgc29ycnksICdcIittZXRob2QrXCInIGlzIG5vdCBhbiBhdmFpbGFibGUgbWV0aG9kIGZvciBcIisocGx1Z0NsYXNzP2Z1bmN0aW9uTmFtZShwbHVnQ2xhc3MpOid0aGlzIGVsZW1lbnQnKSsnLicpO319ZWxzZXsvL2Vycm9yIGZvciBpbnZhbGlkIGFyZ3VtZW50IHR5cGVcbnRocm93IG5ldyBUeXBlRXJyb3IoJ1dlXFwncmUgc29ycnksICcrdHlwZSsnIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS4nKTt9cmV0dXJuIHRoaXM7fTt3aW5kb3cuRm91bmRhdGlvbj1Gb3VuZGF0aW9uOyQuZm4uZm91bmRhdGlvbj1mb3VuZGF0aW9uOy8vIFBvbHlmaWxsIGZvciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbihmdW5jdGlvbigpe2lmKCFEYXRlLm5vd3x8IXdpbmRvdy5EYXRlLm5vdyl3aW5kb3cuRGF0ZS5ub3c9RGF0ZS5ub3c9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7fTt2YXIgdmVuZG9ycz1bJ3dlYmtpdCcsJ21veiddO2Zvcih2YXIgaT0wO2k8dmVuZG9ycy5sZW5ndGgmJiF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOysraSl7dmFyIHZwPXZlbmRvcnNbaV07d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT13aW5kb3dbdnArJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT13aW5kb3dbdnArJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ118fHdpbmRvd1t2cCsnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107fWlmKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCl8fCF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lfHwhd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKXt2YXIgbGFzdFRpbWU9MDt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKGNhbGxiYWNrKXt2YXIgbm93PURhdGUubm93KCk7dmFyIG5leHRUaW1lPU1hdGgubWF4KGxhc3RUaW1lKzE2LG5vdyk7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtjYWxsYmFjayhsYXN0VGltZT1uZXh0VGltZSk7fSxuZXh0VGltZS1ub3cpO307d2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lPWNsZWFyVGltZW91dDt9LyoqXG4gICAgICogUG9seWZpbGwgZm9yIHBlcmZvcm1hbmNlLm5vdywgcmVxdWlyZWQgYnkgckFGXG4gICAgICovaWYoIXdpbmRvdy5wZXJmb3JtYW5jZXx8IXdpbmRvdy5wZXJmb3JtYW5jZS5ub3cpe3dpbmRvdy5wZXJmb3JtYW5jZT17c3RhcnQ6RGF0ZS5ub3coKSxub3c6ZnVuY3Rpb24gbm93KCl7cmV0dXJuIERhdGUubm93KCktdGhpcy5zdGFydDt9fTt9fSkoKTtpZighRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQpe0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKG9UaGlzKXtpZih0eXBlb2YgdGhpcyE9PSdmdW5jdGlvbicpey8vIGNsb3Nlc3QgdGhpbmcgcG9zc2libGUgdG8gdGhlIEVDTUFTY3JpcHQgNVxuLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxudGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTt9dmFyIGFBcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxmVG9CaW5kPXRoaXMsZk5PUD1mdW5jdGlvbiBmTk9QKCl7fSxmQm91bmQ9ZnVuY3Rpb24gZkJvdW5kKCl7cmV0dXJuIGZUb0JpbmQuYXBwbHkodGhpcyBpbnN0YW5jZW9mIGZOT1A/dGhpczpvVGhpcyxhQXJncy5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO307aWYodGhpcy5wcm90b3R5cGUpey8vIG5hdGl2ZSBmdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhIHByb3RvdHlwZVxuZk5PUC5wcm90b3R5cGU9dGhpcy5wcm90b3R5cGU7fWZCb3VuZC5wcm90b3R5cGU9bmV3IGZOT1AoKTtyZXR1cm4gZkJvdW5kO307fS8vIFBvbHlmaWxsIHRvIGdldCB0aGUgbmFtZSBvZiBhIGZ1bmN0aW9uIGluIElFOVxuZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGZuKXtpZihGdW5jdGlvbi5wcm90b3R5cGUubmFtZT09PXVuZGVmaW5lZCl7dmFyIGZ1bmNOYW1lUmVnZXg9L2Z1bmN0aW9uXFxzKFteKF17MSx9KVxcKC87dmFyIHJlc3VsdHM9ZnVuY05hbWVSZWdleC5leGVjKGZuLnRvU3RyaW5nKCkpO3JldHVybiByZXN1bHRzJiZyZXN1bHRzLmxlbmd0aD4xP3Jlc3VsdHNbMV0udHJpbSgpOlwiXCI7fWVsc2UgaWYoZm4ucHJvdG90eXBlPT09dW5kZWZpbmVkKXtyZXR1cm4gZm4uY29uc3RydWN0b3IubmFtZTt9ZWxzZXtyZXR1cm4gZm4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWU7fX1mdW5jdGlvbiBwYXJzZVZhbHVlKHN0cil7aWYoL3RydWUvLnRlc3Qoc3RyKSlyZXR1cm4gdHJ1ZTtlbHNlIGlmKC9mYWxzZS8udGVzdChzdHIpKXJldHVybiBmYWxzZTtlbHNlIGlmKCFpc05hTihzdHIqMSkpcmV0dXJuIHBhcnNlRmxvYXQoc3RyKTtyZXR1cm4gc3RyO30vLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxuLy8gVGhhbmsgeW91OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84OTU1NTgwXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyKXtyZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csJyQxLSQyJykudG9Mb3dlckNhc2UoKTt9fShqUXVlcnkpOyFmdW5jdGlvbigkKXtGb3VuZGF0aW9uLkJveD17SW1Ob3RUb3VjaGluZ1lvdTpJbU5vdFRvdWNoaW5nWW91LEdldERpbWVuc2lvbnM6R2V0RGltZW5zaW9ucyxHZXRPZmZzZXRzOkdldE9mZnNldHN9Oy8qKlxuICAgKiBDb21wYXJlcyB0aGUgZGltZW5zaW9ucyBvZiBhbiBlbGVtZW50IHRvIGEgY29udGFpbmVyIGFuZCBkZXRlcm1pbmVzIGNvbGxpc2lvbiBldmVudHMgd2l0aCBjb250YWluZXIuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdGVzdCBmb3IgY29sbGlzaW9ucy5cbiAgICogQHBhcmFtIHtqUXVlcnl9IHBhcmVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGFzIGJvdW5kaW5nIGNvbnRhaW5lci5cbiAgICogQHBhcmFtIHtCb29sZWFufSBsck9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayBsZWZ0IGFuZCByaWdodCB2YWx1ZXMgb25seS5cbiAgICogQHBhcmFtIHtCb29sZWFufSB0Yk9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayB0b3AgYW5kIGJvdHRvbSB2YWx1ZXMgb25seS5cbiAgICogQGRlZmF1bHQgaWYgbm8gcGFyZW50IG9iamVjdCBwYXNzZWQsIGRldGVjdHMgY29sbGlzaW9ucyB3aXRoIGB3aW5kb3dgLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGxpc2lvbiBmcmVlLCBmYWxzZSBpZiBhIGNvbGxpc2lvbiBpbiBhbnkgZGlyZWN0aW9uLlxuICAgKi9mdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQscGFyZW50LGxyT25seSx0Yk9ubHkpe3ZhciBlbGVEaW1zPUdldERpbWVuc2lvbnMoZWxlbWVudCksdG9wLGJvdHRvbSxsZWZ0LHJpZ2h0O2lmKHBhcmVudCl7dmFyIHBhckRpbXM9R2V0RGltZW5zaW9ucyhwYXJlbnQpO2JvdHRvbT1lbGVEaW1zLm9mZnNldC50b3ArZWxlRGltcy5oZWlnaHQ8PXBhckRpbXMuaGVpZ2h0K3BhckRpbXMub2Zmc2V0LnRvcDt0b3A9ZWxlRGltcy5vZmZzZXQudG9wPj1wYXJEaW1zLm9mZnNldC50b3A7bGVmdD1lbGVEaW1zLm9mZnNldC5sZWZ0Pj1wYXJEaW1zLm9mZnNldC5sZWZ0O3JpZ2h0PWVsZURpbXMub2Zmc2V0LmxlZnQrZWxlRGltcy53aWR0aDw9cGFyRGltcy53aWR0aCtwYXJEaW1zLm9mZnNldC5sZWZ0O31lbHNle2JvdHRvbT1lbGVEaW1zLm9mZnNldC50b3ArZWxlRGltcy5oZWlnaHQ8PWVsZURpbXMud2luZG93RGltcy5oZWlnaHQrZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3A7dG9wPWVsZURpbXMub2Zmc2V0LnRvcD49ZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3A7bGVmdD1lbGVEaW1zLm9mZnNldC5sZWZ0Pj1lbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQ7cmlnaHQ9ZWxlRGltcy5vZmZzZXQubGVmdCtlbGVEaW1zLndpZHRoPD1lbGVEaW1zLndpbmRvd0RpbXMud2lkdGg7fXZhciBhbGxEaXJzPVtib3R0b20sdG9wLGxlZnQscmlnaHRdO2lmKGxyT25seSl7cmV0dXJuIGxlZnQ9PT1yaWdodD09PXRydWU7fWlmKHRiT25seSl7cmV0dXJuIHRvcD09PWJvdHRvbT09PXRydWU7fXJldHVybiBhbGxEaXJzLmluZGV4T2YoZmFsc2UpPT09LTE7fS8qKlxuICAgKiBVc2VzIG5hdGl2ZSBtZXRob2RzIHRvIHJldHVybiBhbiBvYmplY3Qgb2YgZGltZW5zaW9uIHZhbHVlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7alF1ZXJ5IHx8IEhUTUx9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IG9yIERPTSBlbGVtZW50IGZvciB3aGljaCB0byBnZXQgdGhlIGRpbWVuc2lvbnMuIENhbiBiZSBhbnkgZWxlbWVudCBvdGhlciB0aGF0IGRvY3VtZW50IG9yIHdpbmRvdy5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBuZXN0ZWQgb2JqZWN0IG9mIGludGVnZXIgcGl4ZWwgdmFsdWVzXG4gICAqIFRPRE8gLSBpZiBlbGVtZW50IGlzIHdpbmRvdywgcmV0dXJuIG9ubHkgdGhvc2UgdmFsdWVzLlxuICAgKi9mdW5jdGlvbiBHZXREaW1lbnNpb25zKGVsZW0sdGVzdCl7ZWxlbT1lbGVtLmxlbmd0aD9lbGVtWzBdOmVsZW07aWYoZWxlbT09PXdpbmRvd3x8ZWxlbT09PWRvY3VtZW50KXt0aHJvdyBuZXcgRXJyb3IoXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlwiKTt9dmFyIHJlY3Q9ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxwYXJSZWN0PWVsZW0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSx3aW5SZWN0PWRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksd2luWT13aW5kb3cucGFnZVlPZmZzZXQsd2luWD13aW5kb3cucGFnZVhPZmZzZXQ7cmV0dXJue3dpZHRoOnJlY3Qud2lkdGgsaGVpZ2h0OnJlY3QuaGVpZ2h0LG9mZnNldDp7dG9wOnJlY3QudG9wK3dpblksbGVmdDpyZWN0LmxlZnQrd2luWH0scGFyZW50RGltczp7d2lkdGg6cGFyUmVjdC53aWR0aCxoZWlnaHQ6cGFyUmVjdC5oZWlnaHQsb2Zmc2V0Ont0b3A6cGFyUmVjdC50b3Ard2luWSxsZWZ0OnBhclJlY3QubGVmdCt3aW5YfX0sd2luZG93RGltczp7d2lkdGg6d2luUmVjdC53aWR0aCxoZWlnaHQ6d2luUmVjdC5oZWlnaHQsb2Zmc2V0Ont0b3A6d2luWSxsZWZ0Ondpblh9fX07fS8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0b3AgYW5kIGxlZnQgaW50ZWdlciBwaXhlbCB2YWx1ZXMgZm9yIGR5bmFtaWNhbGx5IHJlbmRlcmVkIGVsZW1lbnRzLFxuICAgKiBzdWNoIGFzOiBUb29sdGlwLCBSZXZlYWwsIGFuZCBEcm9wZG93blxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKiBAcGFyYW0ge2pRdWVyeX0gYW5jaG9yIC0galF1ZXJ5IG9iamVjdCBmb3IgdGhlIGVsZW1lbnQncyBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwb3NpdGlvbiAtIGEgc3RyaW5nIHJlbGF0aW5nIHRvIHRoZSBkZXNpcmVkIHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCByZWxhdGl2ZSB0byBpdCdzIGFuY2hvclxuICAgKiBAcGFyYW0ge051bWJlcn0gdk9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gaE9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCBob3Jpem9udGFsIHNlcGFyYXRpb24gYmV0d2VlbiBhbmNob3IgYW5kIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyZmxvdyAtIGlmIGEgY29sbGlzaW9uIGV2ZW50IGlzIGRldGVjdGVkLCBzZXRzIHRvIHRydWUgdG8gZGVmYXVsdCB0aGUgZWxlbWVudCB0byBmdWxsIHdpZHRoIC0gYW55IGRlc2lyZWQgb2Zmc2V0LlxuICAgKiBUT0RPIGFsdGVyL3Jld3JpdGUgdG8gd29yayB3aXRoIGBlbWAgdmFsdWVzIGFzIHdlbGwvaW5zdGVhZCBvZiBwaXhlbHNcbiAgICovZnVuY3Rpb24gR2V0T2Zmc2V0cyhlbGVtZW50LGFuY2hvcixwb3NpdGlvbix2T2Zmc2V0LGhPZmZzZXQsaXNPdmVyZmxvdyl7dmFyICRlbGVEaW1zPUdldERpbWVuc2lvbnMoZWxlbWVudCksJGFuY2hvckRpbXM9YW5jaG9yP0dldERpbWVuc2lvbnMoYW5jaG9yKTpudWxsO3N3aXRjaChwb3NpdGlvbil7Y2FzZSd0b3AnOnJldHVybntsZWZ0OkZvdW5kYXRpb24ucnRsKCk/JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQtJGVsZURpbXMud2lkdGgrJGFuY2hvckRpbXMud2lkdGg6JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQsdG9wOiRhbmNob3JEaW1zLm9mZnNldC50b3AtKCRlbGVEaW1zLmhlaWdodCt2T2Zmc2V0KX07YnJlYWs7Y2FzZSdsZWZ0JzpyZXR1cm57bGVmdDokYW5jaG9yRGltcy5vZmZzZXQubGVmdC0oJGVsZURpbXMud2lkdGgraE9mZnNldCksdG9wOiRhbmNob3JEaW1zLm9mZnNldC50b3B9O2JyZWFrO2Nhc2UncmlnaHQnOnJldHVybntsZWZ0OiRhbmNob3JEaW1zLm9mZnNldC5sZWZ0KyRhbmNob3JEaW1zLndpZHRoK2hPZmZzZXQsdG9wOiRhbmNob3JEaW1zLm9mZnNldC50b3B9O2JyZWFrO2Nhc2UnY2VudGVyIHRvcCc6cmV0dXJue2xlZnQ6JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQrJGFuY2hvckRpbXMud2lkdGgvMi0kZWxlRGltcy53aWR0aC8yLHRvcDokYW5jaG9yRGltcy5vZmZzZXQudG9wLSgkZWxlRGltcy5oZWlnaHQrdk9mZnNldCl9O2JyZWFrO2Nhc2UnY2VudGVyIGJvdHRvbSc6cmV0dXJue2xlZnQ6aXNPdmVyZmxvdz9oT2Zmc2V0OiRhbmNob3JEaW1zLm9mZnNldC5sZWZ0KyRhbmNob3JEaW1zLndpZHRoLzItJGVsZURpbXMud2lkdGgvMix0b3A6JGFuY2hvckRpbXMub2Zmc2V0LnRvcCskYW5jaG9yRGltcy5oZWlnaHQrdk9mZnNldH07YnJlYWs7Y2FzZSdjZW50ZXIgbGVmdCc6cmV0dXJue2xlZnQ6JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQtKCRlbGVEaW1zLndpZHRoK2hPZmZzZXQpLHRvcDokYW5jaG9yRGltcy5vZmZzZXQudG9wKyRhbmNob3JEaW1zLmhlaWdodC8yLSRlbGVEaW1zLmhlaWdodC8yfTticmVhaztjYXNlJ2NlbnRlciByaWdodCc6cmV0dXJue2xlZnQ6JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQrJGFuY2hvckRpbXMud2lkdGgraE9mZnNldCsxLHRvcDokYW5jaG9yRGltcy5vZmZzZXQudG9wKyRhbmNob3JEaW1zLmhlaWdodC8yLSRlbGVEaW1zLmhlaWdodC8yfTticmVhaztjYXNlJ2NlbnRlcic6cmV0dXJue2xlZnQ6JGVsZURpbXMud2luZG93RGltcy5vZmZzZXQubGVmdCskZWxlRGltcy53aW5kb3dEaW1zLndpZHRoLzItJGVsZURpbXMud2lkdGgvMix0b3A6JGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wKyRlbGVEaW1zLndpbmRvd0RpbXMuaGVpZ2h0LzItJGVsZURpbXMuaGVpZ2h0LzJ9O2JyZWFrO2Nhc2UncmV2ZWFsJzpyZXR1cm57bGVmdDooJGVsZURpbXMud2luZG93RGltcy53aWR0aC0kZWxlRGltcy53aWR0aCkvMix0b3A6JGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wK3ZPZmZzZXR9O2Nhc2UncmV2ZWFsIGZ1bGwnOnJldHVybntsZWZ0OiRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsdG9wOiRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcH07YnJlYWs7Y2FzZSdsZWZ0IGJvdHRvbSc6cmV0dXJue2xlZnQ6JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQtKCRlbGVEaW1zLndpZHRoK2hPZmZzZXQpLHRvcDokYW5jaG9yRGltcy5vZmZzZXQudG9wKyRhbmNob3JEaW1zLmhlaWdodH07YnJlYWs7Y2FzZSdyaWdodCBib3R0b20nOnJldHVybntsZWZ0OiRhbmNob3JEaW1zLm9mZnNldC5sZWZ0KyRhbmNob3JEaW1zLndpZHRoK2hPZmZzZXQtJGVsZURpbXMud2lkdGgsdG9wOiRhbmNob3JEaW1zLm9mZnNldC50b3ArJGFuY2hvckRpbXMuaGVpZ2h0fTticmVhaztkZWZhdWx0OnJldHVybntsZWZ0OkZvdW5kYXRpb24ucnRsKCk/JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQtJGVsZURpbXMud2lkdGgrJGFuY2hvckRpbXMud2lkdGg6JGFuY2hvckRpbXMub2Zmc2V0LmxlZnQsdG9wOiRhbmNob3JEaW1zLm9mZnNldC50b3ArJGFuY2hvckRpbXMuaGVpZ2h0K3ZPZmZzZXR9O319fShqUXVlcnkpOy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICogVGhpcyB1dGlsIHdhcyBjcmVhdGVkIGJ5IE1hcml1cyBPbGJlcnR6ICpcbiAqIFBsZWFzZSB0aGFuayBNYXJpdXMgb24gR2l0SHViIC9vd2xiZXJ0eiAqXG4gKiBvciB0aGUgd2ViIGh0dHA6Ly93d3cubWFyaXVzb2xiZXJ0ei5kZS8gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovIWZ1bmN0aW9uKCQpe3ZhciBrZXlDb2Rlcz17OTonVEFCJywxMzonRU5URVInLDI3OidFU0NBUEUnLDMyOidTUEFDRScsMzc6J0FSUk9XX0xFRlQnLDM4OidBUlJPV19VUCcsMzk6J0FSUk9XX1JJR0hUJyw0MDonQVJST1dfRE9XTid9O3ZhciBjb21tYW5kcz17fTt2YXIgS2V5Ym9hcmQ9e2tleXM6Z2V0S2V5Q29kZXMoa2V5Q29kZXMpLC8qKlxuICAgICAqIFBhcnNlcyB0aGUgKGtleWJvYXJkKSBldmVudCBhbmQgcmV0dXJucyBhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaXRzIGtleVxuICAgICAqIENhbiBiZSB1c2VkIGxpa2UgRm91bmRhdGlvbi5wYXJzZUtleShldmVudCkgPT09IEZvdW5kYXRpb24ua2V5cy5TUEFDRVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gdGhlIGV2ZW50IGdlbmVyYXRlZCBieSB0aGUgZXZlbnQgaGFuZGxlclxuICAgICAqIEByZXR1cm4gU3RyaW5nIGtleSAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGtleSBwcmVzc2VkXG4gICAgICovcGFyc2VLZXk6ZnVuY3Rpb24gcGFyc2VLZXkoZXZlbnQpe3ZhciBrZXk9a2V5Q29kZXNbZXZlbnQud2hpY2h8fGV2ZW50LmtleUNvZGVdfHxTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LndoaWNoKS50b1VwcGVyQ2FzZSgpO2lmKGV2ZW50LnNoaWZ0S2V5KWtleT0nU0hJRlRfJytrZXk7aWYoZXZlbnQuY3RybEtleSlrZXk9J0NUUkxfJytrZXk7aWYoZXZlbnQuYWx0S2V5KWtleT0nQUxUXycra2V5O3JldHVybiBrZXk7fSwvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBnaXZlbiAoa2V5Ym9hcmQpIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbXBvbmVudCAtIEZvdW5kYXRpb24gY29tcG9uZW50J3MgbmFtZSwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXG4gICAgICogQHBhcmFtIHtPYmplY3RzfSBmdW5jdGlvbnMgLSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0aGF0IGFyZSB0byBiZSBleGVjdXRlZFxuICAgICAqL2hhbmRsZUtleTpmdW5jdGlvbiBoYW5kbGVLZXkoZXZlbnQsY29tcG9uZW50LGZ1bmN0aW9ucyl7dmFyIGNvbW1hbmRMaXN0PWNvbW1hbmRzW2NvbXBvbmVudF0sa2V5Q29kZT10aGlzLnBhcnNlS2V5KGV2ZW50KSxjbWRzLGNvbW1hbmQsZm47aWYoIWNvbW1hbmRMaXN0KXJldHVybiBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCBub3QgZGVmaW5lZCEnKTtpZih0eXBlb2YgY29tbWFuZExpc3QubHRyPT09J3VuZGVmaW5lZCcpey8vIHRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsdHIgYW5kIHJ0bFxuY21kcz1jb21tYW5kTGlzdDsvLyB1c2UgcGxhaW4gbGlzdFxufWVsc2V7Ly8gbWVyZ2UgbHRyIGFuZCBydGw6IGlmIGRvY3VtZW50IGlzIHJ0bCwgcnRsIG92ZXJ3cml0ZXMgbHRyIGFuZCB2aWNlIHZlcnNhXG5pZihGb3VuZGF0aW9uLnJ0bCgpKWNtZHM9JC5leHRlbmQoe30sY29tbWFuZExpc3QubHRyLGNvbW1hbmRMaXN0LnJ0bCk7ZWxzZSBjbWRzPSQuZXh0ZW5kKHt9LGNvbW1hbmRMaXN0LnJ0bCxjb21tYW5kTGlzdC5sdHIpO31jb21tYW5kPWNtZHNba2V5Q29kZV07Zm49ZnVuY3Rpb25zW2NvbW1hbmRdO2lmKGZuJiZ0eXBlb2YgZm49PT0nZnVuY3Rpb24nKXsvLyBleGVjdXRlIGZ1bmN0aW9uICBpZiBleGlzdHNcbnZhciByZXR1cm5WYWx1ZT1mbi5hcHBseSgpO2lmKGZ1bmN0aW9ucy5oYW5kbGVkfHx0eXBlb2YgZnVuY3Rpb25zLmhhbmRsZWQ9PT0nZnVuY3Rpb24nKXsvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWRcbmZ1bmN0aW9ucy5oYW5kbGVkKHJldHVyblZhbHVlKTt9fWVsc2V7aWYoZnVuY3Rpb25zLnVuaGFuZGxlZHx8dHlwZW9mIGZ1bmN0aW9ucy51bmhhbmRsZWQ9PT0nZnVuY3Rpb24nKXsvLyBleGVjdXRlIGZ1bmN0aW9uIHdoZW4gZXZlbnQgd2FzIG5vdCBoYW5kbGVkXG5mdW5jdGlvbnMudW5oYW5kbGVkKCk7fX19LC8qKlxuICAgICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXG4gICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBzZWFyY2ggd2l0aGluXG4gICAgICogQHJldHVybiB7alF1ZXJ5fSAkZm9jdXNhYmxlIC0gYWxsIGZvY3VzYWJsZSBlbGVtZW50cyB3aXRoaW4gYCRlbGVtZW50YFxuICAgICAqL2ZpbmRGb2N1c2FibGU6ZnVuY3Rpb24gZmluZEZvY3VzYWJsZSgkZWxlbWVudCl7cmV0dXJuICRlbGVtZW50LmZpbmQoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsICpbdGFiaW5kZXhdLCAqW2NvbnRlbnRlZGl0YWJsZV0nKS5maWx0ZXIoZnVuY3Rpb24oKXtpZighJCh0aGlzKS5pcygnOnZpc2libGUnKXx8JCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpPDApe3JldHVybiBmYWxzZTt9Ly9vbmx5IGhhdmUgdmlzaWJsZSBlbGVtZW50cyBhbmQgdGhvc2UgdGhhdCBoYXZlIGEgdGFiaW5kZXggZ3JlYXRlciBvciBlcXVhbCAwXG5yZXR1cm4gdHJ1ZTt9KTt9LC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXBvbmVudCBuYW1lIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcG9uZW50IC0gRm91bmRhdGlvbiBjb21wb25lbnQsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxuICAgICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcbiAgICAgKi9yZWdpc3RlcjpmdW5jdGlvbiByZWdpc3Rlcihjb21wb25lbnROYW1lLGNtZHMpe2NvbW1hbmRzW2NvbXBvbmVudE5hbWVdPWNtZHM7fX07LypcbiAgICogQ29uc3RhbnRzIGZvciBlYXNpZXIgY29tcGFyaW5nLlxuICAgKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcbiAgICovZnVuY3Rpb24gZ2V0S2V5Q29kZXMoa2NzKXt2YXIgaz17fTtmb3IodmFyIGtjIGluIGtjcyl7a1trY3Nba2NdXT1rY3Nba2NdO31yZXR1cm4gazt9Rm91bmRhdGlvbi5LZXlib2FyZD1LZXlib2FyZDt9KGpRdWVyeSk7IWZ1bmN0aW9uKCQpey8vIERlZmF1bHQgc2V0IG9mIG1lZGlhIHF1ZXJpZXNcbnZhciBkZWZhdWx0UXVlcmllcz17J2RlZmF1bHQnOidvbmx5IHNjcmVlbicsbGFuZHNjYXBlOidvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyxwb3J0cmFpdDonb25seSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxyZXRpbmE6J29ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwnKydvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksJysnb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCcrJ29ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJysnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwnKydvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknfTt2YXIgTWVkaWFRdWVyeT17cXVlcmllczpbXSxjdXJyZW50OicnLC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtZWRpYSBxdWVyeSBoZWxwZXIsIGJ5IGV4dHJhY3RpbmcgdGhlIGJyZWFrcG9pbnQgbGlzdCBmcm9tIHRoZSBDU1MgYW5kIGFjdGl2YXRpbmcgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19pbml0OmZ1bmN0aW9uIF9pbml0KCl7dmFyIHNlbGY9dGhpczt2YXIgZXh0cmFjdGVkU3R5bGVzPSQoJy5mb3VuZGF0aW9uLW1xJykuY3NzKCdmb250LWZhbWlseScpO3ZhciBuYW1lZFF1ZXJpZXM7bmFtZWRRdWVyaWVzPXBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO2Zvcih2YXIga2V5IGluIG5hbWVkUXVlcmllcyl7aWYobmFtZWRRdWVyaWVzLmhhc093blByb3BlcnR5KGtleSkpe3NlbGYucXVlcmllcy5wdXNoKHtuYW1lOmtleSx2YWx1ZTonb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICcrbmFtZWRRdWVyaWVzW2tleV0rJyknfSk7fX10aGlzLmN1cnJlbnQ9dGhpcy5fZ2V0Q3VycmVudFNpemUoKTt0aGlzLl93YXRjaGVyKCk7fSwvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyBhdCBsZWFzdCBhcyB3aWRlIGFzIGEgYnJlYWtwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0J3Mgc21hbGxlci5cbiAgICAgKi9hdExlYXN0OmZ1bmN0aW9uIGF0TGVhc3Qoc2l6ZSl7dmFyIHF1ZXJ5PXRoaXMuZ2V0KHNpemUpO2lmKHF1ZXJ5KXtyZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7fXJldHVybiBmYWxzZTt9LC8qKlxuICAgICAqIEdldHMgdGhlIG1lZGlhIHF1ZXJ5IG9mIGEgYnJlYWtwb2ludC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSAtIE5hbWUgb2YgdGhlIGJyZWFrcG9pbnQgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gLSBUaGUgbWVkaWEgcXVlcnkgb2YgdGhlIGJyZWFrcG9pbnQsIG9yIGBudWxsYCBpZiB0aGUgYnJlYWtwb2ludCBkb2Vzbid0IGV4aXN0LlxuICAgICAqL2dldDpmdW5jdGlvbiBnZXQoc2l6ZSl7Zm9yKHZhciBpIGluIHRoaXMucXVlcmllcyl7aWYodGhpcy5xdWVyaWVzLmhhc093blByb3BlcnR5KGkpKXt2YXIgcXVlcnk9dGhpcy5xdWVyaWVzW2ldO2lmKHNpemU9PT1xdWVyeS5uYW1lKXJldHVybiBxdWVyeS52YWx1ZTt9fXJldHVybiBudWxsO30sLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBicmVha3BvaW50IG5hbWUgYnkgdGVzdGluZyBldmVyeSBicmVha3BvaW50IGFuZCByZXR1cm5pbmcgdGhlIGxhc3Qgb25lIHRvIG1hdGNoICh0aGUgYmlnZ2VzdCBvbmUpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1N0cmluZ30gTmFtZSBvZiB0aGUgY3VycmVudCBicmVha3BvaW50LlxuICAgICAqL19nZXRDdXJyZW50U2l6ZTpmdW5jdGlvbiBfZ2V0Q3VycmVudFNpemUoKXt2YXIgbWF0Y2hlZDtmb3IodmFyIGk9MDtpPHRoaXMucXVlcmllcy5sZW5ndGg7aSsrKXt2YXIgcXVlcnk9dGhpcy5xdWVyaWVzW2ldO2lmKHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5LnZhbHVlKS5tYXRjaGVzKXttYXRjaGVkPXF1ZXJ5O319aWYoKHR5cGVvZiBtYXRjaGVkPT09J3VuZGVmaW5lZCc/J3VuZGVmaW5lZCc6X3R5cGVvZihtYXRjaGVkKSk9PT0nb2JqZWN0Jyl7cmV0dXJuIG1hdGNoZWQubmFtZTt9ZWxzZXtyZXR1cm4gbWF0Y2hlZDt9fSwvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGJyZWFrcG9pbnQgd2F0Y2hlciwgd2hpY2ggZmlyZXMgYW4gZXZlbnQgb24gdGhlIHdpbmRvdyB3aGVuZXZlciB0aGUgYnJlYWtwb2ludCBjaGFuZ2VzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovX3dhdGNoZXI6ZnVuY3Rpb24gX3dhdGNoZXIoKXt2YXIgX3RoaXM9dGhpczskKHdpbmRvdykub24oJ3Jlc2l6ZS56Zi5tZWRpYXF1ZXJ5JyxmdW5jdGlvbigpe3ZhciBuZXdTaXplPV90aGlzLl9nZXRDdXJyZW50U2l6ZSgpLGN1cnJlbnRTaXplPV90aGlzLmN1cnJlbnQ7aWYobmV3U2l6ZSE9PWN1cnJlbnRTaXplKXsvLyBDaGFuZ2UgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnlcbl90aGlzLmN1cnJlbnQ9bmV3U2l6ZTsvLyBCcm9hZGNhc3QgdGhlIG1lZGlhIHF1ZXJ5IGNoYW5nZSBvbiB0aGUgd2luZG93XG4kKHdpbmRvdykudHJpZ2dlcignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JyxbbmV3U2l6ZSxjdXJyZW50U2l6ZV0pO319KTt9fTtGb3VuZGF0aW9uLk1lZGlhUXVlcnk9TWVkaWFRdWVyeTsvLyBtYXRjaE1lZGlhKCkgcG9seWZpbGwgLSBUZXN0IGEgQ1NTIG1lZGlhIHR5cGUvcXVlcnkgaW4gSlMuXG4vLyBBdXRob3JzICYgY29weXJpZ2h0IChjKSAyMDEyOiBTY290dCBKZWhsLCBQYXVsIElyaXNoLCBOaWNob2xhcyBaYWthcywgRGF2aWQgS25pZ2h0LiBEdWFsIE1JVC9CU0QgbGljZW5zZVxud2luZG93Lm1hdGNoTWVkaWF8fCh3aW5kb3cubWF0Y2hNZWRpYT1mdW5jdGlvbigpeyd1c2Ugc3RyaWN0JzsvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxudmFyIHN0eWxlTWVkaWE9d2luZG93LnN0eWxlTWVkaWF8fHdpbmRvdy5tZWRpYTsvLyBGb3IgdGhvc2UgdGhhdCBkb24ndCBzdXBwb3J0IG1hdGNoTWVkaXVtXG5pZighc3R5bGVNZWRpYSl7dmFyIHN0eWxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyksc2NyaXB0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXSxpbmZvPW51bGw7c3R5bGUudHlwZT0ndGV4dC9jc3MnO3N0eWxlLmlkPSdtYXRjaG1lZGlhanMtdGVzdCc7c2NyaXB0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHN0eWxlLHNjcmlwdCk7Ly8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbmluZm89J2dldENvbXB1dGVkU3R5bGUnaW4gd2luZG93JiZ3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSxudWxsKXx8c3R5bGUuY3VycmVudFN0eWxlO3N0eWxlTWVkaWE9e21hdGNoTWVkaXVtOmZ1bmN0aW9uIG1hdGNoTWVkaXVtKG1lZGlhKXt2YXIgdGV4dD0nQG1lZGlhICcrbWVkaWErJ3sgI21hdGNobWVkaWFqcy10ZXN0IHsgd2lkdGg6IDFweDsgfSB9JzsvLyAnc3R5bGUuc3R5bGVTaGVldCcgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnc3R5bGUudGV4dENvbnRlbnQnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcbmlmKHN0eWxlLnN0eWxlU2hlZXQpe3N0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dD10ZXh0O31lbHNle3N0eWxlLnRleHRDb250ZW50PXRleHQ7fS8vIFRlc3QgaWYgbWVkaWEgcXVlcnkgaXMgdHJ1ZSBvciBmYWxzZVxucmV0dXJuIGluZm8ud2lkdGg9PT0nMXB4Jzt9fTt9cmV0dXJuIGZ1bmN0aW9uKG1lZGlhKXtyZXR1cm57bWF0Y2hlczpzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhfHwnYWxsJyksbWVkaWE6bWVkaWF8fCdhbGwnfTt9O30oKSk7Ly8gVGhhbmsgeW91OiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZ1xuZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cil7dmFyIHN0eWxlT2JqZWN0PXt9O2lmKHR5cGVvZiBzdHIhPT0nc3RyaW5nJyl7cmV0dXJuIHN0eWxlT2JqZWN0O31zdHI9c3RyLnRyaW0oKS5zbGljZSgxLC0xKTsvLyBicm93c2VycyByZS1xdW90ZSBzdHJpbmcgc3R5bGUgdmFsdWVzXG5pZighc3RyKXtyZXR1cm4gc3R5bGVPYmplY3Q7fXN0eWxlT2JqZWN0PXN0ci5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbihyZXQscGFyYW0pe3ZhciBwYXJ0cz1wYXJhbS5yZXBsYWNlKC9cXCsvZywnICcpLnNwbGl0KCc9Jyk7dmFyIGtleT1wYXJ0c1swXTt2YXIgdmFsPXBhcnRzWzFdO2tleT1kZWNvZGVVUklDb21wb25lbnQoa2V5KTsvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuLy8gaHR0cDovL3czLm9yZy9UUi8yMDEyL1dELXVybC0yMDEyMDUyNC8jY29sbGVjdC11cmwtcGFyYW1ldGVyc1xudmFsPXZhbD09PXVuZGVmaW5lZD9udWxsOmRlY29kZVVSSUNvbXBvbmVudCh2YWwpO2lmKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSl7cmV0W2tleV09dmFsO31lbHNlIGlmKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKXtyZXRba2V5XS5wdXNoKHZhbCk7fWVsc2V7cmV0W2tleV09W3JldFtrZXldLHZhbF07fXJldHVybiByZXQ7fSx7fSk7cmV0dXJuIHN0eWxlT2JqZWN0O31Gb3VuZGF0aW9uLk1lZGlhUXVlcnk9TWVkaWFRdWVyeTt9KGpRdWVyeSk7IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBNb3Rpb24gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ubW90aW9uXG4gICAqL3ZhciBpbml0Q2xhc3Nlcz1bJ211aS1lbnRlcicsJ211aS1sZWF2ZSddO3ZhciBhY3RpdmVDbGFzc2VzPVsnbXVpLWVudGVyLWFjdGl2ZScsJ211aS1sZWF2ZS1hY3RpdmUnXTt2YXIgTW90aW9uPXthbmltYXRlSW46ZnVuY3Rpb24gYW5pbWF0ZUluKGVsZW1lbnQsYW5pbWF0aW9uLGNiKXthbmltYXRlKHRydWUsZWxlbWVudCxhbmltYXRpb24sY2IpO30sYW5pbWF0ZU91dDpmdW5jdGlvbiBhbmltYXRlT3V0KGVsZW1lbnQsYW5pbWF0aW9uLGNiKXthbmltYXRlKGZhbHNlLGVsZW1lbnQsYW5pbWF0aW9uLGNiKTt9fTtmdW5jdGlvbiBNb3ZlKGR1cmF0aW9uLGVsZW0sZm4pe3ZhciBhbmltLHByb2csc3RhcnQ9bnVsbDsvLyBjb25zb2xlLmxvZygnY2FsbGVkJyk7XG5mdW5jdGlvbiBtb3ZlKHRzKXtpZighc3RhcnQpc3RhcnQ9d2luZG93LnBlcmZvcm1hbmNlLm5vdygpOy8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XG5wcm9nPXRzLXN0YXJ0O2ZuLmFwcGx5KGVsZW0pO2lmKHByb2c8ZHVyYXRpb24pe2FuaW09d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlLGVsZW0pO31lbHNle3dpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltKTtlbGVtLnRyaWdnZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLFtlbGVtXSkudHJpZ2dlckhhbmRsZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLFtlbGVtXSk7fX1hbmltPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSk7fS8qKlxuICAgKiBBbmltYXRlcyBhbiBlbGVtZW50IGluIG9yIG91dCB1c2luZyBhIENTUyB0cmFuc2l0aW9uIGNsYXNzLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc0luIC0gRGVmaW5lcyBpZiB0aGUgYW5pbWF0aW9uIGlzIGluIG9yIG91dC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb3IgSFRNTCBvYmplY3QgdG8gYW5pbWF0ZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiAtIENTUyBjbGFzcyB0byB1c2UuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQ2FsbGJhY2sgdG8gcnVuIHdoZW4gYW5pbWF0aW9uIGlzIGZpbmlzaGVkLlxuICAgKi9mdW5jdGlvbiBhbmltYXRlKGlzSW4sZWxlbWVudCxhbmltYXRpb24sY2Ipe2VsZW1lbnQ9JChlbGVtZW50KS5lcSgwKTtpZighZWxlbWVudC5sZW5ndGgpcmV0dXJuO3ZhciBpbml0Q2xhc3M9aXNJbj9pbml0Q2xhc3Nlc1swXTppbml0Q2xhc3Nlc1sxXTt2YXIgYWN0aXZlQ2xhc3M9aXNJbj9hY3RpdmVDbGFzc2VzWzBdOmFjdGl2ZUNsYXNzZXNbMV07Ly8gU2V0IHVwIHRoZSBhbmltYXRpb25cbnJlc2V0KCk7ZWxlbWVudC5hZGRDbGFzcyhhbmltYXRpb24pLmNzcygndHJhbnNpdGlvbicsJ25vbmUnKTtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7aWYoaXNJbillbGVtZW50LnNob3coKTt9KTsvLyBTdGFydCB0aGUgYW5pbWF0aW9uXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtlbGVtZW50WzBdLm9mZnNldFdpZHRoO2VsZW1lbnQuY3NzKCd0cmFuc2l0aW9uJywnJykuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO30pOy8vIENsZWFuIHVwIHRoZSBhbmltYXRpb24gd2hlbiBpdCBmaW5pc2hlc1xuZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKGVsZW1lbnQpLGZpbmlzaCk7Ly8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xuZnVuY3Rpb24gZmluaXNoKCl7aWYoIWlzSW4pZWxlbWVudC5oaWRlKCk7cmVzZXQoKTtpZihjYiljYi5hcHBseShlbGVtZW50KTt9Ly8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXG5mdW5jdGlvbiByZXNldCgpe2VsZW1lbnRbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uPTA7ZWxlbWVudC5yZW1vdmVDbGFzcyhpbml0Q2xhc3MrJyAnK2FjdGl2ZUNsYXNzKycgJythbmltYXRpb24pO319Rm91bmRhdGlvbi5Nb3ZlPU1vdmU7Rm91bmRhdGlvbi5Nb3Rpb249TW90aW9uO30oalF1ZXJ5KTshZnVuY3Rpb24oJCl7dmFyIE5lc3Q9e0ZlYXRoZXI6ZnVuY3Rpb24gRmVhdGhlcihtZW51KXt2YXIgdHlwZT1hcmd1bWVudHMubGVuZ3RoPD0xfHxhcmd1bWVudHNbMV09PT11bmRlZmluZWQ/J3pmJzphcmd1bWVudHNbMV07bWVudS5hdHRyKCdyb2xlJywnbWVudWJhcicpO3ZhciBpdGVtcz1tZW51LmZpbmQoJ2xpJykuYXR0cih7J3JvbGUnOidtZW51aXRlbSd9KSxzdWJNZW51Q2xhc3M9J2lzLScrdHlwZSsnLXN1Ym1lbnUnLHN1Ykl0ZW1DbGFzcz1zdWJNZW51Q2xhc3MrJy1pdGVtJyxoYXNTdWJDbGFzcz0naXMtJyt0eXBlKyctc3VibWVudS1wYXJlbnQnO21lbnUuZmluZCgnYTpmaXJzdCcpLmF0dHIoJ3RhYmluZGV4JywwKTtpdGVtcy5lYWNoKGZ1bmN0aW9uKCl7dmFyICRpdGVtPSQodGhpcyksJHN1Yj0kaXRlbS5jaGlsZHJlbigndWwnKTtpZigkc3ViLmxlbmd0aCl7JGl0ZW0uYWRkQ2xhc3MoaGFzU3ViQ2xhc3MpLmF0dHIoeydhcmlhLWhhc3BvcHVwJzp0cnVlLCdhcmlhLWV4cGFuZGVkJzpmYWxzZSwnYXJpYS1sYWJlbCc6JGl0ZW0uY2hpbGRyZW4oJ2E6Zmlyc3QnKS50ZXh0KCl9KTskc3ViLmFkZENsYXNzKCdzdWJtZW51ICcrc3ViTWVudUNsYXNzKS5hdHRyKHsnZGF0YS1zdWJtZW51JzonJywnYXJpYS1oaWRkZW4nOnRydWUsJ3JvbGUnOidtZW51J30pO31pZigkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKXskaXRlbS5hZGRDbGFzcygnaXMtc3VibWVudS1pdGVtICcrc3ViSXRlbUNsYXNzKTt9fSk7cmV0dXJuO30sQnVybjpmdW5jdGlvbiBCdXJuKG1lbnUsdHlwZSl7dmFyIGl0ZW1zPW1lbnUuZmluZCgnbGknKS5yZW1vdmVBdHRyKCd0YWJpbmRleCcpLHN1Yk1lbnVDbGFzcz0naXMtJyt0eXBlKyctc3VibWVudScsc3ViSXRlbUNsYXNzPXN1Yk1lbnVDbGFzcysnLWl0ZW0nLGhhc1N1YkNsYXNzPSdpcy0nK3R5cGUrJy1zdWJtZW51LXBhcmVudCc7bWVudS5maW5kKCcqJykucmVtb3ZlQ2xhc3Moc3ViTWVudUNsYXNzKycgJytzdWJJdGVtQ2xhc3MrJyAnK2hhc1N1YkNsYXNzKycgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlJykucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykuY3NzKCdkaXNwbGF5JywnJyk7Ly8gY29uc29sZS5sb2coICAgICAgbWVudS5maW5kKCcuJyArIHN1Yk1lbnVDbGFzcyArICcsIC4nICsgc3ViSXRlbUNsYXNzICsgJywgLmhhcy1zdWJtZW51LCAuaXMtc3VibWVudS1pdGVtLCAuc3VibWVudSwgW2RhdGEtc3VibWVudV0nKVxuLy8gICAgICAgICAgIC5yZW1vdmVDbGFzcyhzdWJNZW51Q2xhc3MgKyAnICcgKyBzdWJJdGVtQ2xhc3MgKyAnIGhhcy1zdWJtZW51IGlzLXN1Ym1lbnUtaXRlbSBzdWJtZW51Jylcbi8vICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykpO1xuLy8gaXRlbXMuZWFjaChmdW5jdGlvbigpe1xuLy8gICB2YXIgJGl0ZW0gPSAkKHRoaXMpLFxuLy8gICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xuLy8gICBpZigkaXRlbS5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKXtcbi8vICAgICAkaXRlbS5yZW1vdmVDbGFzcygnaXMtc3VibWVudS1pdGVtICcgKyBzdWJJdGVtQ2xhc3MpO1xuLy8gICB9XG4vLyAgIGlmKCRzdWIubGVuZ3RoKXtcbi8vICAgICAkaXRlbS5yZW1vdmVDbGFzcygnaGFzLXN1Ym1lbnUnKTtcbi8vICAgICAkc3ViLnJlbW92ZUNsYXNzKCdzdWJtZW51ICcgKyBzdWJNZW51Q2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpO1xuLy8gICB9XG4vLyB9KTtcbn19O0ZvdW5kYXRpb24uTmVzdD1OZXN0O30oalF1ZXJ5KTshZnVuY3Rpb24oJCl7ZnVuY3Rpb24gVGltZXIoZWxlbSxvcHRpb25zLGNiKXt2YXIgX3RoaXM9dGhpcyxkdXJhdGlvbj1vcHRpb25zLmR1cmF0aW9uLC8vb3B0aW9ucyBpcyBhbiBvYmplY3QgZm9yIGVhc2lseSBhZGRpbmcgZmVhdHVyZXMgbGF0ZXIuXG5uYW1lU3BhY2U9T2JqZWN0LmtleXMoZWxlbS5kYXRhKCkpWzBdfHwndGltZXInLHJlbWFpbj0tMSxzdGFydCx0aW1lcjt0aGlzLmlzUGF1c2VkPWZhbHNlO3RoaXMucmVzdGFydD1mdW5jdGlvbigpe3JlbWFpbj0tMTtjbGVhclRpbWVvdXQodGltZXIpO3RoaXMuc3RhcnQoKTt9O3RoaXMuc3RhcnQ9ZnVuY3Rpb24oKXt0aGlzLmlzUGF1c2VkPWZhbHNlOy8vIGlmKCFlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxuY2xlYXJUaW1lb3V0KHRpbWVyKTtyZW1haW49cmVtYWluPD0wP2R1cmF0aW9uOnJlbWFpbjtlbGVtLmRhdGEoJ3BhdXNlZCcsZmFsc2UpO3N0YXJ0PURhdGUubm93KCk7dGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2lmKG9wdGlvbnMuaW5maW5pdGUpe190aGlzLnJlc3RhcnQoKTsvL3JlcnVuIHRoZSB0aW1lci5cbn1jYigpO30scmVtYWluKTtlbGVtLnRyaWdnZXIoJ3RpbWVyc3RhcnQuemYuJytuYW1lU3BhY2UpO307dGhpcy5wYXVzZT1mdW5jdGlvbigpe3RoaXMuaXNQYXVzZWQ9dHJ1ZTsvL2lmKGVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXG5jbGVhclRpbWVvdXQodGltZXIpO2VsZW0uZGF0YSgncGF1c2VkJyx0cnVlKTt2YXIgZW5kPURhdGUubm93KCk7cmVtYWluPXJlbWFpbi0oZW5kLXN0YXJ0KTtlbGVtLnRyaWdnZXIoJ3RpbWVycGF1c2VkLnpmLicrbmFtZVNwYWNlKTt9O30vKipcbiAgICogUnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoZW4gaW1hZ2VzIGFyZSBmdWxseSBsb2FkZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZXMgLSBJbWFnZShzKSB0byBjaGVjayBpZiBsb2FkZWQuXG4gICAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxuICAgKi9mdW5jdGlvbiBvbkltYWdlc0xvYWRlZChpbWFnZXMsY2FsbGJhY2spe3ZhciBzZWxmPXRoaXMsdW5sb2FkZWQ9aW1hZ2VzLmxlbmd0aDtpZih1bmxvYWRlZD09PTApe2NhbGxiYWNrKCk7fWltYWdlcy5lYWNoKGZ1bmN0aW9uKCl7aWYodGhpcy5jb21wbGV0ZSl7c2luZ2xlSW1hZ2VMb2FkZWQoKTt9ZWxzZSBpZih0eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGghPT0ndW5kZWZpbmVkJyYmdGhpcy5uYXR1cmFsV2lkdGg+MCl7c2luZ2xlSW1hZ2VMb2FkZWQoKTt9ZWxzZXskKHRoaXMpLm9uZSgnbG9hZCcsZnVuY3Rpb24oKXtzaW5nbGVJbWFnZUxvYWRlZCgpO30pO319KTtmdW5jdGlvbiBzaW5nbGVJbWFnZUxvYWRlZCgpe3VubG9hZGVkLS07aWYodW5sb2FkZWQ9PT0wKXtjYWxsYmFjaygpO319fUZvdW5kYXRpb24uVGltZXI9VGltZXI7Rm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZD1vbkltYWdlc0xvYWRlZDt9KGpRdWVyeSk7Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKldvcmsgaW5zcGlyZWQgYnkgbXVsdGlwbGUganF1ZXJ5IHN3aXBlIHBsdWdpbnMqKlxuLy8qKkRvbmUgYnkgWW9oYWkgQXJhcmF0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuKGZ1bmN0aW9uKCQpeyQuc3BvdFN3aXBlPXt2ZXJzaW9uOicxLjAuMCcsZW5hYmxlZDonb250b3VjaHN0YXJ0J2luIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxwcmV2ZW50RGVmYXVsdDpmYWxzZSxtb3ZlVGhyZXNob2xkOjc1LHRpbWVUaHJlc2hvbGQ6MjAwfTt2YXIgc3RhcnRQb3NYLHN0YXJ0UG9zWSxzdGFydFRpbWUsZWxhcHNlZFRpbWUsaXNNb3Zpbmc9ZmFsc2U7ZnVuY3Rpb24gb25Ub3VjaEVuZCgpey8vICBhbGVydCh0aGlzKTtcbnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJyxvblRvdWNoTW92ZSk7dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsb25Ub3VjaEVuZCk7aXNNb3Zpbmc9ZmFsc2U7fWZ1bmN0aW9uIG9uVG91Y2hNb3ZlKGUpe2lmKCQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0KXtlLnByZXZlbnREZWZhdWx0KCk7fWlmKGlzTW92aW5nKXt2YXIgeD1lLnRvdWNoZXNbMF0ucGFnZVg7dmFyIHk9ZS50b3VjaGVzWzBdLnBhZ2VZO3ZhciBkeD1zdGFydFBvc1gteDt2YXIgZHk9c3RhcnRQb3NZLXk7dmFyIGRpcjtlbGFwc2VkVGltZT1uZXcgRGF0ZSgpLmdldFRpbWUoKS1zdGFydFRpbWU7aWYoTWF0aC5hYnMoZHgpPj0kLnNwb3RTd2lwZS5tb3ZlVGhyZXNob2xkJiZlbGFwc2VkVGltZTw9JC5zcG90U3dpcGUudGltZVRocmVzaG9sZCl7ZGlyPWR4PjA/J2xlZnQnOidyaWdodCc7fS8vIGVsc2UgaWYoTWF0aC5hYnMoZHkpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xuLy8gICBkaXIgPSBkeSA+IDAgPyAnZG93bicgOiAndXAnO1xuLy8gfVxuaWYoZGlyKXtlLnByZXZlbnREZWZhdWx0KCk7b25Ub3VjaEVuZC5jYWxsKHRoaXMpOyQodGhpcykudHJpZ2dlcignc3dpcGUnLGRpcikudHJpZ2dlcignc3dpcGUnK2Rpcik7fX19ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpe2lmKGUudG91Y2hlcy5sZW5ndGg9PTEpe3N0YXJ0UG9zWD1lLnRvdWNoZXNbMF0ucGFnZVg7c3RhcnRQb3NZPWUudG91Y2hlc1swXS5wYWdlWTtpc01vdmluZz10cnVlO3N0YXJ0VGltZT1uZXcgRGF0ZSgpLmdldFRpbWUoKTt0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsb25Ub3VjaE1vdmUsZmFsc2UpO3RoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLG9uVG91Y2hFbmQsZmFsc2UpO319ZnVuY3Rpb24gaW5pdCgpe3RoaXMuYWRkRXZlbnRMaXN0ZW5lciYmdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JyxvblRvdWNoU3RhcnQsZmFsc2UpO31mdW5jdGlvbiB0ZWFyZG93bigpe3RoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsb25Ub3VjaFN0YXJ0KTt9JC5ldmVudC5zcGVjaWFsLnN3aXBlPXtzZXR1cDppbml0fTskLmVhY2goWydsZWZ0JywndXAnLCdkb3duJywncmlnaHQnXSxmdW5jdGlvbigpeyQuZXZlbnQuc3BlY2lhbFsnc3dpcGUnK3RoaXNdPXtzZXR1cDpmdW5jdGlvbiBzZXR1cCgpeyQodGhpcykub24oJ3N3aXBlJywkLm5vb3ApO319O30pO30pKGpRdWVyeSk7LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzdWVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqLyFmdW5jdGlvbigkKXskLmZuLmFkZFRvdWNoPWZ1bmN0aW9uKCl7dGhpcy5lYWNoKGZ1bmN0aW9uKGksZWwpeyQoZWwpLmJpbmQoJ3RvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsJyxmdW5jdGlvbigpey8vd2UgcGFzcyB0aGUgb3JpZ2luYWwgZXZlbnQgb2JqZWN0IGJlY2F1c2UgdGhlIGpRdWVyeSBldmVudFxuLy9vYmplY3QgaXMgbm9ybWFsaXplZCB0byB3M2Mgc3BlY3MgYW5kIGRvZXMgbm90IHByb3ZpZGUgdGhlIFRvdWNoTGlzdFxuaGFuZGxlVG91Y2goZXZlbnQpO30pO30pO3ZhciBoYW5kbGVUb3VjaD1mdW5jdGlvbiBoYW5kbGVUb3VjaChldmVudCl7dmFyIHRvdWNoZXM9ZXZlbnQuY2hhbmdlZFRvdWNoZXMsZmlyc3Q9dG91Y2hlc1swXSxldmVudFR5cGVzPXt0b3VjaHN0YXJ0Oidtb3VzZWRvd24nLHRvdWNobW92ZTonbW91c2Vtb3ZlJyx0b3VjaGVuZDonbW91c2V1cCd9LHR5cGU9ZXZlbnRUeXBlc1tldmVudC50eXBlXSxzaW11bGF0ZWRFdmVudDtpZignTW91c2VFdmVudCdpbiB3aW5kb3cmJnR5cGVvZiB3aW5kb3cuTW91c2VFdmVudD09PSdmdW5jdGlvbicpe3NpbXVsYXRlZEV2ZW50PW5ldyB3aW5kb3cuTW91c2VFdmVudCh0eXBlLHsnYnViYmxlcyc6dHJ1ZSwnY2FuY2VsYWJsZSc6dHJ1ZSwnc2NyZWVuWCc6Zmlyc3Quc2NyZWVuWCwnc2NyZWVuWSc6Zmlyc3Quc2NyZWVuWSwnY2xpZW50WCc6Zmlyc3QuY2xpZW50WCwnY2xpZW50WSc6Zmlyc3QuY2xpZW50WX0pO31lbHNle3NpbXVsYXRlZEV2ZW50PWRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQodHlwZSx0cnVlLHRydWUsd2luZG93LDEsZmlyc3Quc2NyZWVuWCxmaXJzdC5zY3JlZW5ZLGZpcnN0LmNsaWVudFgsZmlyc3QuY2xpZW50WSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSwwLypsZWZ0Ki8sbnVsbCk7fWZpcnN0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTt9O307fShqUXVlcnkpOy8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIWZ1bmN0aW9uKCQpe3ZhciBNdXRhdGlvbk9ic2VydmVyPWZ1bmN0aW9uKCl7dmFyIHByZWZpeGVzPVsnV2ViS2l0JywnTW96JywnTycsJ01zJywnJ107Zm9yKHZhciBpPTA7aTxwcmVmaXhlcy5sZW5ndGg7aSsrKXtpZihwcmVmaXhlc1tpXSsnTXV0YXRpb25PYnNlcnZlcidpbiB3aW5kb3cpe3JldHVybiB3aW5kb3dbcHJlZml4ZXNbaV0rJ011dGF0aW9uT2JzZXJ2ZXInXTt9fXJldHVybiBmYWxzZTt9KCk7dmFyIHRyaWdnZXJzPWZ1bmN0aW9uIHRyaWdnZXJzKGVsLHR5cGUpe2VsLmRhdGEodHlwZSkuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGlkKXskKCcjJytpZClbdHlwZT09PSdjbG9zZSc/J3RyaWdnZXInOid0cmlnZ2VySGFuZGxlciddKHR5cGUrJy56Zi50cmlnZ2VyJyxbZWxdKTt9KTt9Oy8vIEVsZW1lbnRzIHdpdGggW2RhdGEtb3Blbl0gd2lsbCByZXZlYWwgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXG4kKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsJ1tkYXRhLW9wZW5dJyxmdW5jdGlvbigpe3RyaWdnZXJzKCQodGhpcyksJ29wZW4nKTt9KTsvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxuLy8gSWYgdXNlZCB3aXRob3V0IGEgdmFsdWUgb24gW2RhdGEtY2xvc2VdLCB0aGUgZXZlbnQgd2lsbCBidWJibGUsIGFsbG93aW5nIGl0IHRvIGNsb3NlIGEgcGFyZW50IGNvbXBvbmVudC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywnW2RhdGEtY2xvc2VdJyxmdW5jdGlvbigpe3ZhciBpZD0kKHRoaXMpLmRhdGEoJ2Nsb3NlJyk7aWYoaWQpe3RyaWdnZXJzKCQodGhpcyksJ2Nsb3NlJyk7fWVsc2V7JCh0aGlzKS50cmlnZ2VyKCdjbG9zZS56Zi50cmlnZ2VyJyk7fX0pOy8vIEVsZW1lbnRzIHdpdGggW2RhdGEtdG9nZ2xlXSB3aWxsIHRvZ2dsZSBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cbiQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywnW2RhdGEtdG9nZ2xlXScsZnVuY3Rpb24oKXt0cmlnZ2VycygkKHRoaXMpLCd0b2dnbGUnKTt9KTsvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NhYmxlXSB3aWxsIHJlc3BvbmQgdG8gY2xvc2UuemYudHJpZ2dlciBldmVudHMuXG4kKGRvY3VtZW50KS5vbignY2xvc2UuemYudHJpZ2dlcicsJ1tkYXRhLWNsb3NhYmxlXScsZnVuY3Rpb24oZSl7ZS5zdG9wUHJvcGFnYXRpb24oKTt2YXIgYW5pbWF0aW9uPSQodGhpcykuZGF0YSgnY2xvc2FibGUnKTtpZihhbmltYXRpb24hPT0nJyl7Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkKHRoaXMpLGFuaW1hdGlvbixmdW5jdGlvbigpeyQodGhpcykudHJpZ2dlcignY2xvc2VkLnpmJyk7fSk7fWVsc2V7JCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcignY2xvc2VkLnpmJyk7fX0pOyQoZG9jdW1lbnQpLm9uKCdmb2N1cy56Zi50cmlnZ2VyIGJsdXIuemYudHJpZ2dlcicsJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLGZ1bmN0aW9uKCl7dmFyIGlkPSQodGhpcykuZGF0YSgndG9nZ2xlLWZvY3VzJyk7JCgnIycraWQpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsWyQodGhpcyldKTt9KTsvKipcbiAgKiBGaXJlcyBvbmNlIGFmdGVyIGFsbCBvdGhlciBzY3JpcHRzIGhhdmUgbG9hZGVkXG4gICogQGZ1bmN0aW9uXG4gICogQHByaXZhdGVcbiAgKi8kKHdpbmRvdykubG9hZChmdW5jdGlvbigpe2NoZWNrTGlzdGVuZXJzKCk7fSk7ZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcnMoKXtldmVudHNMaXN0ZW5lcigpO3Jlc2l6ZUxpc3RlbmVyKCk7c2Nyb2xsTGlzdGVuZXIoKTtjbG9zZW1lTGlzdGVuZXIoKTt9Ly8qKioqKioqKiBvbmx5IGZpcmVzIHRoaXMgZnVuY3Rpb24gb25jZSBvbiBsb2FkLCBpZiB0aGVyZSdzIHNvbWV0aGluZyB0byB3YXRjaCAqKioqKioqKlxuZnVuY3Rpb24gY2xvc2VtZUxpc3RlbmVyKHBsdWdpbk5hbWUpe3ZhciB5ZXRpQm94ZXM9JCgnW2RhdGEteWV0aS1ib3hdJykscGx1Z05hbWVzPVsnZHJvcGRvd24nLCd0b29sdGlwJywncmV2ZWFsJ107aWYocGx1Z2luTmFtZSl7aWYodHlwZW9mIHBsdWdpbk5hbWU9PT0nc3RyaW5nJyl7cGx1Z05hbWVzLnB1c2gocGx1Z2luTmFtZSk7fWVsc2UgaWYoKHR5cGVvZiBwbHVnaW5OYW1lPT09J3VuZGVmaW5lZCc/J3VuZGVmaW5lZCc6X3R5cGVvZihwbHVnaW5OYW1lKSk9PT0nb2JqZWN0JyYmdHlwZW9mIHBsdWdpbk5hbWVbMF09PT0nc3RyaW5nJyl7cGx1Z05hbWVzLmNvbmNhdChwbHVnaW5OYW1lKTt9ZWxzZXtjb25zb2xlLmVycm9yKCdQbHVnaW4gbmFtZXMgbXVzdCBiZSBzdHJpbmdzJyk7fX1pZih5ZXRpQm94ZXMubGVuZ3RoKXt2YXIgbGlzdGVuZXJzPXBsdWdOYW1lcy5tYXAoZnVuY3Rpb24obmFtZSl7cmV0dXJuJ2Nsb3NlbWUuemYuJytuYW1lO30pLmpvaW4oJyAnKTskKHdpbmRvdykub2ZmKGxpc3RlbmVycykub24obGlzdGVuZXJzLGZ1bmN0aW9uKGUscGx1Z2luSWQpe3ZhciBwbHVnaW49ZS5uYW1lc3BhY2Uuc3BsaXQoJy4nKVswXTt2YXIgcGx1Z2lucz0kKCdbZGF0YS0nK3BsdWdpbisnXScpLm5vdCgnW2RhdGEteWV0aS1ib3g9XCInK3BsdWdpbklkKydcIl0nKTtwbHVnaW5zLmVhY2goZnVuY3Rpb24oKXt2YXIgX3RoaXM9JCh0aGlzKTtfdGhpcy50cmlnZ2VySGFuZGxlcignY2xvc2UuemYudHJpZ2dlcicsW190aGlzXSk7fSk7fSk7fX1mdW5jdGlvbiByZXNpemVMaXN0ZW5lcihkZWJvdW5jZSl7dmFyIHRpbWVyPXZvaWQgMCwkbm9kZXM9JCgnW2RhdGEtcmVzaXplXScpO2lmKCRub2Rlcy5sZW5ndGgpeyQod2luZG93KS5vZmYoJ3Jlc2l6ZS56Zi50cmlnZ2VyJykub24oJ3Jlc2l6ZS56Zi50cmlnZ2VyJyxmdW5jdGlvbihlKXtpZih0aW1lcil7Y2xlYXJUaW1lb3V0KHRpbWVyKTt9dGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2lmKCFNdXRhdGlvbk9ic2VydmVyKXsvL2ZhbGxiYWNrIGZvciBJRSA5XG4kbm9kZXMuZWFjaChmdW5jdGlvbigpeyQodGhpcykudHJpZ2dlckhhbmRsZXIoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTt9KTt9Ly90cmlnZ2VyIGFsbCBsaXN0ZW5pbmcgZWxlbWVudHMgYW5kIHNpZ25hbCBhIHJlc2l6ZSBldmVudFxuJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJyxcInJlc2l6ZVwiKTt9LGRlYm91bmNlfHwxMCk7Ly9kZWZhdWx0IHRpbWUgdG8gZW1pdCByZXNpemUgZXZlbnRcbn0pO319ZnVuY3Rpb24gc2Nyb2xsTGlzdGVuZXIoZGVib3VuY2Upe3ZhciB0aW1lcj12b2lkIDAsJG5vZGVzPSQoJ1tkYXRhLXNjcm9sbF0nKTtpZigkbm9kZXMubGVuZ3RoKXskKHdpbmRvdykub2ZmKCdzY3JvbGwuemYudHJpZ2dlcicpLm9uKCdzY3JvbGwuemYudHJpZ2dlcicsZnVuY3Rpb24oZSl7aWYodGltZXIpe2NsZWFyVGltZW91dCh0aW1lcik7fXRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZighTXV0YXRpb25PYnNlcnZlcil7Ly9mYWxsYmFjayBmb3IgSUUgOVxuJG5vZGVzLmVhY2goZnVuY3Rpb24oKXskKHRoaXMpLnRyaWdnZXJIYW5kbGVyKCdzY3JvbGxtZS56Zi50cmlnZ2VyJyk7fSk7fS8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcbiRub2Rlcy5hdHRyKCdkYXRhLWV2ZW50cycsXCJzY3JvbGxcIik7fSxkZWJvdW5jZXx8MTApOy8vZGVmYXVsdCB0aW1lIHRvIGVtaXQgc2Nyb2xsIGV2ZW50XG59KTt9fWZ1bmN0aW9uIGV2ZW50c0xpc3RlbmVyKCl7aWYoIU11dGF0aW9uT2JzZXJ2ZXIpe3JldHVybiBmYWxzZTt9dmFyIG5vZGVzPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV0nKTsvL2VsZW1lbnQgY2FsbGJhY2tcbnZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uPWZ1bmN0aW9uIGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24obXV0YXRpb25SZWNvcmRzTGlzdCl7dmFyICR0YXJnZXQ9JChtdXRhdGlvblJlY29yZHNMaXN0WzBdLnRhcmdldCk7Ly90cmlnZ2VyIHRoZSBldmVudCBoYW5kbGVyIGZvciB0aGUgZWxlbWVudCBkZXBlbmRpbmcgb24gdHlwZVxuc3dpdGNoKCR0YXJnZXQuYXR0cihcImRhdGEtZXZlbnRzXCIpKXtjYXNlXCJyZXNpemVcIjokdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdyZXNpemVtZS56Zi50cmlnZ2VyJyxbJHRhcmdldF0pO2JyZWFrO2Nhc2VcInNjcm9sbFwiOiR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ3Njcm9sbG1lLnpmLnRyaWdnZXInLFskdGFyZ2V0LHdpbmRvdy5wYWdlWU9mZnNldF0pO2JyZWFrOy8vIGNhc2UgXCJtdXRhdGVcIiA6XG4vLyBjb25zb2xlLmxvZygnbXV0YXRlJywgJHRhcmdldCk7XG4vLyAkdGFyZ2V0LnRyaWdnZXJIYW5kbGVyKCdtdXRhdGUuemYudHJpZ2dlcicpO1xuLy9cbi8vIC8vbWFrZSBzdXJlIHdlIGRvbid0IGdldCBzdHVjayBpbiBhbiBpbmZpbml0ZSBsb29wIGZyb20gc2xvcHB5IGNvZGVpbmdcbi8vIGlmICgkdGFyZ2V0LmluZGV4KCdbZGF0YS1tdXRhdGVdJykgPT0gJChcIltkYXRhLW11dGF0ZV1cIikubGVuZ3RoLTEpIHtcbi8vICAgZG9tTXV0YXRpb25PYnNlcnZlcigpO1xuLy8gfVxuLy8gYnJlYWs7XG5kZWZhdWx0OnJldHVybiBmYWxzZTsvL25vdGhpbmdcbn19O2lmKG5vZGVzLmxlbmd0aCl7Ly9mb3IgZWFjaCBlbGVtZW50IHRoYXQgbmVlZHMgdG8gbGlzdGVuIGZvciByZXNpemluZywgc2Nyb2xsaW5nLCAob3IgY29taW5nIHNvb24gbXV0YXRpb24pIGFkZCBhIHNpbmdsZSBvYnNlcnZlclxuZm9yKHZhciBpPTA7aTw9bm9kZXMubGVuZ3RoLTE7aSsrKXt2YXIgZWxlbWVudE9ic2VydmVyPW5ldyBNdXRhdGlvbk9ic2VydmVyKGxpc3RlbmluZ0VsZW1lbnRzTXV0YXRpb24pO2VsZW1lbnRPYnNlcnZlci5vYnNlcnZlKG5vZGVzW2ldLHthdHRyaWJ1dGVzOnRydWUsY2hpbGRMaXN0OmZhbHNlLGNoYXJhY3RlckRhdGE6ZmFsc2Usc3VidHJlZTpmYWxzZSxhdHRyaWJ1dGVGaWx0ZXI6W1wiZGF0YS1ldmVudHNcIl19KTt9fX0vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFtQSF1cbi8vIEZvdW5kYXRpb24uQ2hlY2tXYXRjaGVycyA9IGNoZWNrV2F0Y2hlcnM7XG5Gb3VuZGF0aW9uLklIZWFyWW91PWNoZWNrTGlzdGVuZXJzOy8vIEZvdW5kYXRpb24uSVNlZVlvdSA9IHNjcm9sbExpc3RlbmVyO1xuLy8gRm91bmRhdGlvbi5JRmVlbFlvdSA9IGNsb3NlbWVMaXN0ZW5lcjtcbn0oalF1ZXJ5KTsvLyBmdW5jdGlvbiBkb21NdXRhdGlvbk9ic2VydmVyKGRlYm91bmNlKSB7XG52YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogQWJpZGUgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uYWJpZGVcbiAgICovdmFyIEFiaWRlPWZ1bmN0aW9uKCl7LyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBBYmlkZS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgQWJpZGUjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIEFiaWRlKGVsZW1lbnQpe3ZhciBvcHRpb25zPWFyZ3VtZW50cy5sZW5ndGg8PTF8fGFyZ3VtZW50c1sxXT09PXVuZGVmaW5lZD97fTphcmd1bWVudHNbMV07X2NsYXNzQ2FsbENoZWNrKHRoaXMsQWJpZGUpO3RoaXMuJGVsZW1lbnQ9ZWxlbWVudDt0aGlzLm9wdGlvbnM9JC5leHRlbmQoe30sQWJpZGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnQWJpZGUnKTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFiaWRlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBBYmlkZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovX2NyZWF0ZUNsYXNzKEFiaWRlLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt0aGlzLiRpbnB1dHM9dGhpcy4kZWxlbWVudC5maW5kKCdpbnB1dCwgdGV4dGFyZWEsIHNlbGVjdCcpO3RoaXMuX2V2ZW50cygpO30vKipcbiAgICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgQWJpZGUuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfZXZlbnRzJyx2YWx1ZTpmdW5jdGlvbiBfZXZlbnRzKCl7dmFyIF90aGlzMj10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKCcuYWJpZGUnKS5vbigncmVzZXQuemYuYWJpZGUnLGZ1bmN0aW9uKCl7X3RoaXMyLnJlc2V0Rm9ybSgpO30pLm9uKCdzdWJtaXQuemYuYWJpZGUnLGZ1bmN0aW9uKCl7cmV0dXJuIF90aGlzMi52YWxpZGF0ZUZvcm0oKTt9KTtpZih0aGlzLm9wdGlvbnMudmFsaWRhdGVPbj09PSdmaWVsZENoYW5nZScpe3RoaXMuJGlucHV0cy5vZmYoJ2NoYW5nZS56Zi5hYmlkZScpLm9uKCdjaGFuZ2UuemYuYWJpZGUnLGZ1bmN0aW9uKGUpe190aGlzMi52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTt9KTt9aWYodGhpcy5vcHRpb25zLmxpdmVWYWxpZGF0ZSl7dGhpcy4kaW5wdXRzLm9mZignaW5wdXQuemYuYWJpZGUnKS5vbignaW5wdXQuemYuYWJpZGUnLGZ1bmN0aW9uKGUpe190aGlzMi52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTt9KTt9fS8qKlxuICAgICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgQWJpZGUgdXBvbiBET00gY2hhbmdlXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfcmVmbG93Jyx2YWx1ZTpmdW5jdGlvbiBfcmVmbG93KCl7dGhpcy5faW5pdCgpO30vKipcbiAgICAgICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBhIGZvcm0gZWxlbWVudCBoYXMgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBhbmQgaWYgaXQncyBjaGVja2VkIG9yIG5vdFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcbiAgICAgICAqL30se2tleToncmVxdWlyZWRDaGVjaycsdmFsdWU6ZnVuY3Rpb24gcmVxdWlyZWRDaGVjaygkZWwpe2lmKCEkZWwuYXR0cigncmVxdWlyZWQnKSlyZXR1cm4gdHJ1ZTt2YXIgaXNHb29kPXRydWU7c3dpdGNoKCRlbFswXS50eXBlKXtjYXNlJ2NoZWNrYm94Jzppc0dvb2Q9JGVsWzBdLmNoZWNrZWQ7YnJlYWs7Y2FzZSdzZWxlY3QnOmNhc2Unc2VsZWN0LW9uZSc6Y2FzZSdzZWxlY3QtbXVsdGlwbGUnOnZhciBvcHQ9JGVsLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpO2lmKCFvcHQubGVuZ3RofHwhb3B0LnZhbCgpKWlzR29vZD1mYWxzZTticmVhaztkZWZhdWx0OmlmKCEkZWwudmFsKCl8fCEkZWwudmFsKCkubGVuZ3RoKWlzR29vZD1mYWxzZTt9cmV0dXJuIGlzR29vZDt9LyoqXG4gICAgICAgKiBCYXNlZCBvbiAkZWwsIGdldCB0aGUgZmlyc3QgZWxlbWVudCB3aXRoIHNlbGVjdG9yIGluIHRoaXMgb3JkZXI6XG4gICAgICAgKiAxLiBUaGUgZWxlbWVudCdzIGRpcmVjdCBzaWJsaW5nKCdzKS5cbiAgICAgICAqIDMuIFRoZSBlbGVtZW50J3MgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAgICAgKlxuICAgICAgICogVGhpcyBhbGxvd3MgZm9yIG11bHRpcGxlIGZvcm0gZXJyb3JzIHBlciBpbnB1dCwgdGhvdWdoIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBmb3JtIGVycm9ycyB3aWxsIGJlIHNob3duLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHVzZSBhcyByZWZlcmVuY2UgdG8gZmluZCB0aGUgZm9ybSBlcnJvciBzZWxlY3Rvci5cbiAgICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGpRdWVyeSBvYmplY3Qgd2l0aCB0aGUgc2VsZWN0b3IuXG4gICAgICAgKi99LHtrZXk6J2ZpbmRGb3JtRXJyb3InLHZhbHVlOmZ1bmN0aW9uIGZpbmRGb3JtRXJyb3IoJGVsKXt2YXIgJGVycm9yPSRlbC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO2lmKCEkZXJyb3IubGVuZ3RoKXskZXJyb3I9JGVsLnBhcmVudCgpLmZpbmQodGhpcy5vcHRpb25zLmZvcm1FcnJvclNlbGVjdG9yKTt9cmV0dXJuICRlcnJvcjt9LyoqXG4gICAgICAgKiBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhpcyBvcmRlcjpcbiAgICAgICAqIDIuIFRoZSA8bGFiZWw+IHdpdGggdGhlIGF0dHJpYnV0ZSBgW2Zvcj1cInNvbWVJbnB1dElkXCJdYFxuICAgICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxuICAgICAgICovfSx7a2V5OidmaW5kTGFiZWwnLHZhbHVlOmZ1bmN0aW9uIGZpbmRMYWJlbCgkZWwpe3ZhciBpZD0kZWxbMF0uaWQ7dmFyICRsYWJlbD10aGlzLiRlbGVtZW50LmZpbmQoJ2xhYmVsW2Zvcj1cIicraWQrJ1wiXScpO2lmKCEkbGFiZWwubGVuZ3RoKXtyZXR1cm4gJGVsLmNsb3Nlc3QoJ2xhYmVsJyk7fXJldHVybiAkbGFiZWw7fS8qKlxuICAgICAgICogR2V0IHRoZSBzZXQgb2YgbGFiZWxzIGFzc29jaWF0ZWQgd2l0aCBhIHNldCBvZiByYWRpbyBlbHMgaW4gdGhpcyBvcmRlclxuICAgICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVwic29tZUlucHV0SWRcIl1gXG4gICAgICAgKiAzLiBUaGUgYC5jbG9zZXN0KClgIDxsYWJlbD5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XG4gICAgICAgKi99LHtrZXk6J2ZpbmRSYWRpb0xhYmVscycsdmFsdWU6ZnVuY3Rpb24gZmluZFJhZGlvTGFiZWxzKCRlbHMpe3ZhciBfdGhpczM9dGhpczt2YXIgbGFiZWxzPSRlbHMubWFwKGZ1bmN0aW9uKGksZWwpe3ZhciBpZD1lbC5pZDt2YXIgJGxhYmVsPV90aGlzMy4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XCInK2lkKydcIl0nKTtpZighJGxhYmVsLmxlbmd0aCl7JGxhYmVsPSQoZWwpLmNsb3Nlc3QoJ2xhYmVsJyk7fXJldHVybiAkbGFiZWxbMF07fSk7cmV0dXJuICQobGFiZWxzKTt9LyoqXG4gICAgICAgKiBBZGRzIHRoZSBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyB0byB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgY2xhc3MgdG9cbiAgICAgICAqL30se2tleTonYWRkRXJyb3JDbGFzc2VzJyx2YWx1ZTpmdW5jdGlvbiBhZGRFcnJvckNsYXNzZXMoJGVsKXt2YXIgJGxhYmVsPXRoaXMuZmluZExhYmVsKCRlbCk7dmFyICRmb3JtRXJyb3I9dGhpcy5maW5kRm9ybUVycm9yKCRlbCk7aWYoJGxhYmVsLmxlbmd0aCl7JGxhYmVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO31pZigkZm9ybUVycm9yLmxlbmd0aCl7JGZvcm1FcnJvci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO30kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cignZGF0YS1pbnZhbGlkJywnJyk7fS8qKlxuICAgICAgICogUmVtb3ZlIENTUyBlcnJvciBjbGFzc2VzIGV0YyBmcm9tIGFuIGVudGlyZSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cFxuICAgICAgICpcbiAgICAgICAqL30se2tleToncmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMnLHZhbHVlOmZ1bmN0aW9uIHJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKGdyb3VwTmFtZSl7dmFyICRlbHM9dGhpcy4kZWxlbWVudC5maW5kKCc6cmFkaW9bbmFtZT1cIicrZ3JvdXBOYW1lKydcIl0nKTt2YXIgJGxhYmVscz10aGlzLmZpbmRSYWRpb0xhYmVscygkZWxzKTt2YXIgJGZvcm1FcnJvcnM9dGhpcy5maW5kRm9ybUVycm9yKCRlbHMpO2lmKCRsYWJlbHMubGVuZ3RoKXskbGFiZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO31pZigkZm9ybUVycm9ycy5sZW5ndGgpeyRmb3JtRXJyb3JzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyk7fSRlbHMucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7fS8qKlxuICAgICAgICogUmVtb3ZlcyBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyBmcm9tIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gcmVtb3ZlIHRoZSBjbGFzcyBmcm9tXG4gICAgICAgKi99LHtrZXk6J3JlbW92ZUVycm9yQ2xhc3NlcycsdmFsdWU6ZnVuY3Rpb24gcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCl7Ly8gcmFkaW9zIG5lZWQgdG8gY2xlYXIgYWxsIG9mIHRoZSBlbHNcbmlmKCRlbFswXS50eXBlPT0ncmFkaW8nKXtyZXR1cm4gdGhpcy5yZW1vdmVSYWRpb0Vycm9yQ2xhc3NlcygkZWwuYXR0cignbmFtZScpKTt9dmFyICRsYWJlbD10aGlzLmZpbmRMYWJlbCgkZWwpO3ZhciAkZm9ybUVycm9yPXRoaXMuZmluZEZvcm1FcnJvcigkZWwpO2lmKCRsYWJlbC5sZW5ndGgpeyRsYWJlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKTt9aWYoJGZvcm1FcnJvci5sZW5ndGgpeyRmb3JtRXJyb3IucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTt9JGVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO30vKipcbiAgICAgICAqIEdvZXMgdGhyb3VnaCBhIGZvcm0gdG8gZmluZCBpbnB1dHMgYW5kIHByb2NlZWRzIHRvIHZhbGlkYXRlIHRoZW0gaW4gd2F5cyBzcGVjaWZpYyB0byB0aGVpciB0eXBlXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjaW52YWxpZFxuICAgICAgICogQGZpcmVzIEFiaWRlI3ZhbGlkXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdmFsaWRhdGUsIHNob3VsZCBiZSBhbiBIVE1MIGlucHV0XG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZ29vZFRvR28gLSBJZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LlxuICAgICAgICovfSx7a2V5Oid2YWxpZGF0ZUlucHV0Jyx2YWx1ZTpmdW5jdGlvbiB2YWxpZGF0ZUlucHV0KCRlbCl7dmFyIGNsZWFyUmVxdWlyZT10aGlzLnJlcXVpcmVkQ2hlY2soJGVsKSx2YWxpZGF0ZWQ9ZmFsc2UsY3VzdG9tVmFsaWRhdG9yPXRydWUsdmFsaWRhdG9yPSRlbC5hdHRyKCdkYXRhLXZhbGlkYXRvcicpLGVxdWFsVG89dHJ1ZTsvLyBkb24ndCB2YWxpZGF0ZSBpZ25vcmVkIGlucHV0cyBvciBoaWRkZW4gaW5wdXRzXG5pZigkZWwuaXMoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKXx8JGVsLmlzKCdbdHlwZT1cImhpZGRlblwiXScpKXtyZXR1cm4gdHJ1ZTt9c3dpdGNoKCRlbFswXS50eXBlKXtjYXNlJ3JhZGlvJzp2YWxpZGF0ZWQ9dGhpcy52YWxpZGF0ZVJhZGlvKCRlbC5hdHRyKCduYW1lJykpO2JyZWFrO2Nhc2UnY2hlY2tib3gnOnZhbGlkYXRlZD1jbGVhclJlcXVpcmU7YnJlYWs7Y2FzZSdzZWxlY3QnOmNhc2Unc2VsZWN0LW9uZSc6Y2FzZSdzZWxlY3QtbXVsdGlwbGUnOnZhbGlkYXRlZD1jbGVhclJlcXVpcmU7YnJlYWs7ZGVmYXVsdDp2YWxpZGF0ZWQ9dGhpcy52YWxpZGF0ZVRleHQoJGVsKTt9aWYodmFsaWRhdG9yKXtjdXN0b21WYWxpZGF0b3I9dGhpcy5tYXRjaFZhbGlkYXRpb24oJGVsLHZhbGlkYXRvciwkZWwuYXR0cigncmVxdWlyZWQnKSk7fWlmKCRlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSl7ZXF1YWxUbz10aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKCRlbCk7fXZhciBnb29kVG9Hbz1bY2xlYXJSZXF1aXJlLHZhbGlkYXRlZCxjdXN0b21WYWxpZGF0b3IsZXF1YWxUb10uaW5kZXhPZihmYWxzZSk9PT0tMTt2YXIgbWVzc2FnZT0oZ29vZFRvR28/J3ZhbGlkJzonaW52YWxpZCcpKycuemYuYWJpZGUnO3RoaXNbZ29vZFRvR28/J3JlbW92ZUVycm9yQ2xhc3Nlcyc6J2FkZEVycm9yQ2xhc3NlcyddKCRlbCk7LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGlucHV0IGlzIGRvbmUgY2hlY2tpbmcgZm9yIHZhbGlkYXRpb24uIEV2ZW50IHRyaWdnZXIgaXMgZWl0aGVyIGB2YWxpZC56Zi5hYmlkZWAgb3IgYGludmFsaWQuemYuYWJpZGVgXG4gICAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICogQGV2ZW50IEFiaWRlI3ZhbGlkXG4gICAgICAgICAqIEBldmVudCBBYmlkZSNpbnZhbGlkXG4gICAgICAgICAqLyRlbC50cmlnZ2VyKG1lc3NhZ2UsWyRlbF0pO3JldHVybiBnb29kVG9Hbzt9LyoqXG4gICAgICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIGFuZCBpZiB0aGVyZSBhcmUgYW55IGludmFsaWQgaW5wdXRzLCBpdCB3aWxsIGRpc3BsYXkgdGhlIGZvcm0gZXJyb3IgZWxlbWVudFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IG5vRXJyb3IgLSB0cnVlIGlmIG5vIGVycm9ycyB3ZXJlIGRldGVjdGVkLi4uXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybXZhbGlkXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybWludmFsaWRcbiAgICAgICAqL30se2tleTondmFsaWRhdGVGb3JtJyx2YWx1ZTpmdW5jdGlvbiB2YWxpZGF0ZUZvcm0oKXt2YXIgYWNjPVtdO3ZhciBfdGhpcz10aGlzO3RoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uKCl7YWNjLnB1c2goX3RoaXMudmFsaWRhdGVJbnB1dCgkKHRoaXMpKSk7fSk7dmFyIG5vRXJyb3I9YWNjLmluZGV4T2YoZmFsc2UpPT09LTE7dGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1hYmlkZS1lcnJvcl0nKS5jc3MoJ2Rpc3BsYXknLG5vRXJyb3I/J25vbmUnOidibG9jaycpOy8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBmb3JtIGlzIGZpbmlzaGVkIHZhbGlkYXRpbmcuIEV2ZW50IHRyaWdnZXIgaXMgZWl0aGVyIGBmb3JtdmFsaWQuemYuYWJpZGVgIG9yIGBmb3JtaW52YWxpZC56Zi5hYmlkZWAuXG4gICAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIGVsZW1lbnQgb2YgdGhlIGZvcm0uXG4gICAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtdmFsaWRcbiAgICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm1pbnZhbGlkXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcigobm9FcnJvcj8nZm9ybXZhbGlkJzonZm9ybWludmFsaWQnKSsnLnpmLmFiaWRlJyxbdGhpcy4kZWxlbWVudF0pO3JldHVybiBub0Vycm9yO30vKipcbiAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHRleHQgaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gdGhlIHBhdHRlcm4gc3BlY2lmaWVkIGluIHRoZSBhdHRyaWJ1dGUuIElmIG5vIG1hdGNoaW5nIHBhdHRlcm4gaXMgZm91bmQsIHJldHVybnMgdHJ1ZS5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSB0ZXh0IGlucHV0IEhUTUwgZWxlbWVudFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdHRlcm4gLSBzdHJpbmcgdmFsdWUgb2Ygb25lIG9mIHRoZSBSZWdFeCBwYXR0ZXJucyBpbiBBYmlkZS5vcHRpb25zLnBhdHRlcm5zXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCB2YWx1ZSBtYXRjaGVzIHRoZSBwYXR0ZXJuIHNwZWNpZmllZFxuICAgICAgICovfSx7a2V5Oid2YWxpZGF0ZVRleHQnLHZhbHVlOmZ1bmN0aW9uIHZhbGlkYXRlVGV4dCgkZWwscGF0dGVybil7Ly8gQSBwYXR0ZXJuIGNhbiBiZSBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBiZSBpbmZlcmVkIGZyb20gdGhlIGlucHV0J3MgXCJwYXR0ZXJuXCIgYXR0cmlidXRlLCBvciBpdCdzIFwidHlwZVwiIGF0dHJpYnV0ZVxucGF0dGVybj1wYXR0ZXJufHwkZWwuYXR0cigncGF0dGVybicpfHwkZWwuYXR0cigndHlwZScpO3ZhciBpbnB1dFRleHQ9JGVsLnZhbCgpO3ZhciB2YWxpZD1mYWxzZTtpZihpbnB1dFRleHQubGVuZ3RoKXsvLyBJZiB0aGUgcGF0dGVybiBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQgaXMgaW4gQWJpZGUncyBsaXN0IG9mIHBhdHRlcm5zLCB0aGVuIHRlc3QgdGhhdCByZWdleHBcbmlmKHRoaXMub3B0aW9ucy5wYXR0ZXJucy5oYXNPd25Qcm9wZXJ0eShwYXR0ZXJuKSl7dmFsaWQ9dGhpcy5vcHRpb25zLnBhdHRlcm5zW3BhdHRlcm5dLnRlc3QoaW5wdXRUZXh0KTt9Ly8gSWYgdGhlIHBhdHRlcm4gbmFtZSBpc24ndCBhbHNvIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiB0aGUgZmllbGQsIHRoZW4gdGVzdCBpdCBhcyBhIHJlZ2V4cFxuZWxzZSBpZihwYXR0ZXJuIT09JGVsLmF0dHIoJ3R5cGUnKSl7dmFsaWQ9bmV3IFJlZ0V4cChwYXR0ZXJuKS50ZXN0KGlucHV0VGV4dCk7fWVsc2V7dmFsaWQ9dHJ1ZTt9fS8vIEFuIGVtcHR5IGZpZWxkIGlzIHZhbGlkIGlmIGl0J3Mgbm90IHJlcXVpcmVkXG5lbHNlIGlmKCEkZWwucHJvcCgncmVxdWlyZWQnKSl7dmFsaWQ9dHJ1ZTt9cmV0dXJuIHZhbGlkO30vKipcbiAgICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBhIG5vdCBhIHJhZGlvIGlucHV0IGlzIHZhbGlkIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IGl0IGlzIHJlcXVpcmVkIGFuZCBzZWxlY3RlZC4gQWx0aG91Z2ggdGhlIGZ1bmN0aW9uIHRhcmdldHMgYSBzaW5nbGUgYDxpbnB1dD5gLCBpdCB2YWxpZGF0ZXMgYnkgY2hlY2tpbmcgdGhlIGByZXF1aXJlZGAgYW5kIGBjaGVja2VkYCBwcm9wZXJ0aWVzIG9mIGFsbCByYWRpbyBidXR0b25zIGluIGl0cyBncm91cC5cbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdCBsZWFzdCBvbmUgcmFkaW8gaW5wdXQgaGFzIGJlZW4gc2VsZWN0ZWQgKGlmIGl0J3MgcmVxdWlyZWQpXG4gICAgICAgKi99LHtrZXk6J3ZhbGlkYXRlUmFkaW8nLHZhbHVlOmZ1bmN0aW9uIHZhbGlkYXRlUmFkaW8oZ3JvdXBOYW1lKXsvLyBJZiBhdCBsZWFzdCBvbmUgcmFkaW8gaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXG4vLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcbnZhciAkZ3JvdXA9dGhpcy4kZWxlbWVudC5maW5kKCc6cmFkaW9bbmFtZT1cIicrZ3JvdXBOYW1lKydcIl0nKTt2YXIgdmFsaWQ9ZmFsc2UscmVxdWlyZWQ9ZmFsc2U7Ly8gRm9yIHRoZSBncm91cCB0byBiZSByZXF1aXJlZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIHJlcXVpcmVkXG4kZ3JvdXAuZWFjaChmdW5jdGlvbihpLGUpe2lmKCQoZSkuYXR0cigncmVxdWlyZWQnKSl7cmVxdWlyZWQ9dHJ1ZTt9fSk7aWYoIXJlcXVpcmVkKXZhbGlkPXRydWU7aWYoIXZhbGlkKXsvLyBGb3IgdGhlIGdyb3VwIHRvIGJlIHZhbGlkLCBhdCBsZWFzdCBvbmUgcmFkaW8gbmVlZHMgdG8gYmUgY2hlY2tlZFxuJGdyb3VwLmVhY2goZnVuY3Rpb24oaSxlKXtpZigkKGUpLnByb3AoJ2NoZWNrZWQnKSl7dmFsaWQ9dHJ1ZTt9fSk7fXJldHVybiB2YWxpZDt9LyoqXG4gICAgICAgKiBEZXRlcm1pbmVzIGlmIGEgc2VsZWN0ZWQgaW5wdXQgcGFzc2VzIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uIE11bHRpcGxlIHZhbGlkYXRpb25zIGNhbiBiZSB1c2VkLCBpZiBwYXNzZWQgdG8gdGhlIGVsZW1lbnQgd2l0aCBgZGF0YS12YWxpZGF0b3I9XCJmb28gYmFyIGJhelwiYCBpbiBhIHNwYWNlIHNlcGFyYXRlZCBsaXN0ZWQuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IGlucHV0IGVsZW1lbnQuXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsaWRhdG9ycyAtIGEgc3RyaW5nIG9mIGZ1bmN0aW9uIG5hbWVzIG1hdGNoaW5nIGZ1bmN0aW9ucyBpbiB0aGUgQWJpZGUub3B0aW9ucy52YWxpZGF0b3JzIG9iamVjdC5cbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVxdWlyZWQgLSBzZWxmIGV4cGxhbmF0b3J5P1xuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiB2YWxpZGF0aW9ucyBwYXNzZWQuXG4gICAgICAgKi99LHtrZXk6J21hdGNoVmFsaWRhdGlvbicsdmFsdWU6ZnVuY3Rpb24gbWF0Y2hWYWxpZGF0aW9uKCRlbCx2YWxpZGF0b3JzLHJlcXVpcmVkKXt2YXIgX3RoaXM0PXRoaXM7cmVxdWlyZWQ9cmVxdWlyZWQ/dHJ1ZTpmYWxzZTt2YXIgY2xlYXI9dmFsaWRhdG9ycy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbih2KXtyZXR1cm4gX3RoaXM0Lm9wdGlvbnMudmFsaWRhdG9yc1t2XSgkZWwscmVxdWlyZWQsJGVsLnBhcmVudCgpKTt9KTtyZXR1cm4gY2xlYXIuaW5kZXhPZihmYWxzZSk9PT0tMTt9LyoqXG4gICAgICAgKiBSZXNldHMgZm9ybSBpbnB1dHMgYW5kIHN0eWxlc1xuICAgICAgICogQGZpcmVzIEFiaWRlI2Zvcm1yZXNldFxuICAgICAgICovfSx7a2V5OidyZXNldEZvcm0nLHZhbHVlOmZ1bmN0aW9uIHJlc2V0Rm9ybSgpe3ZhciAkZm9ybT10aGlzLiRlbGVtZW50LG9wdHM9dGhpcy5vcHRpb25zOyQoJy4nK29wdHMubGFiZWxFcnJvckNsYXNzLCRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5sYWJlbEVycm9yQ2xhc3MpOyQoJy4nK29wdHMuaW5wdXRFcnJvckNsYXNzLCRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5pbnB1dEVycm9yQ2xhc3MpOyQob3B0cy5mb3JtRXJyb3JTZWxlY3RvcisnLicrb3B0cy5mb3JtRXJyb3JDbGFzcykucmVtb3ZlQ2xhc3Mob3B0cy5mb3JtRXJyb3JDbGFzcyk7JGZvcm0uZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5Jywnbm9uZScpOyQoJzppbnB1dCcsJGZvcm0pLm5vdCgnOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXScpLnZhbCgnJykucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7JCgnOmlucHV0OnJhZGlvJywkZm9ybSkubm90KCdbZGF0YS1hYmlkZS1pZ25vcmVdJykucHJvcCgnY2hlY2tlZCcsZmFsc2UpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpOyQoJzppbnB1dDpjaGVja2JveCcsJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLGZhbHNlKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTsvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBoYXMgYmVlbiByZXNldC5cbiAgICAgICAgICogQGV2ZW50IEFiaWRlI2Zvcm1yZXNldFxuICAgICAgICAgKi8kZm9ybS50cmlnZ2VyKCdmb3JtcmVzZXQuemYuYWJpZGUnLFskZm9ybV0pO30vKipcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIEFiaWRlLlxuICAgICAgICogUmVtb3ZlcyBlcnJvciBzdHlsZXMgYW5kIGNsYXNzZXMgZnJvbSBlbGVtZW50cywgd2l0aG91dCByZXNldHRpbmcgdGhlaXIgdmFsdWVzLlxuICAgICAgICovfSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dmFyIF90aGlzPXRoaXM7dGhpcy4kZWxlbWVudC5vZmYoJy5hYmlkZScpLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsJ25vbmUnKTt0aGlzLiRpbnB1dHMub2ZmKCcuYWJpZGUnKS5lYWNoKGZ1bmN0aW9uKCl7X3RoaXMucmVtb3ZlRXJyb3JDbGFzc2VzKCQodGhpcykpO30pO0ZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pO3JldHVybiBBYmlkZTt9KCk7LyoqXG4gICAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICAgKi9BYmlkZS5kZWZhdWx0cz17LyoqXG4gICAgICogVGhlIGRlZmF1bHQgZXZlbnQgdG8gdmFsaWRhdGUgaW5wdXRzLiBDaGVja2JveGVzIGFuZCByYWRpb3MgdmFsaWRhdGUgaW1tZWRpYXRlbHkuXG4gICAgICogUmVtb3ZlIG9yIGNoYW5nZSB0aGlzIHZhbHVlIGZvciBtYW51YWwgdmFsaWRhdGlvbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2ZpZWxkQ2hhbmdlJ1xuICAgICAqL3ZhbGlkYXRlT246J2ZpZWxkQ2hhbmdlJywvKipcbiAgICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIGlucHV0IGxhYmVscyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2lzLWludmFsaWQtbGFiZWwnXG4gICAgICovbGFiZWxFcnJvckNsYXNzOidpcy1pbnZhbGlkLWxhYmVsJywvKipcbiAgICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIGlucHV0cyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2lzLWludmFsaWQtaW5wdXQnXG4gICAgICovaW5wdXRFcnJvckNsYXNzOidpcy1pbnZhbGlkLWlucHV0JywvKipcbiAgICAgKiBDbGFzcyBzZWxlY3RvciB0byB1c2UgdG8gdGFyZ2V0IEZvcm0gRXJyb3JzIGZvciBzaG93L2hpZGUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICcuZm9ybS1lcnJvcidcbiAgICAgKi9mb3JtRXJyb3JTZWxlY3RvcjonLmZvcm0tZXJyb3InLC8qKlxuICAgICAqIENsYXNzIGFkZGVkIHRvIEZvcm0gRXJyb3JzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnaXMtdmlzaWJsZSdcbiAgICAgKi9mb3JtRXJyb3JDbGFzczonaXMtdmlzaWJsZScsLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gdmFsaWRhdGUgdGV4dCBpbnB1dHMgb24gYW55IHZhbHVlIGNoYW5nZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9saXZlVmFsaWRhdGU6ZmFsc2UscGF0dGVybnM6e2FscGhhOi9eW2EtekEtWl0rJC8sYWxwaGFfbnVtZXJpYzovXlthLXpBLVowLTldKyQvLGludGVnZXI6L15bLStdP1xcZCskLyxudW1iZXI6L15bLStdP1xcZCooPzpbXFwuXFwsXVxcZCspPyQvLC8vIGFtZXgsIHZpc2EsIGRpbmVyc1xuY2FyZDovXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX0pJC8sY3Z2Oi9eKFswLTldKXszLDR9JC8sLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2Uvc3RhdGVzLW9mLXRoZS10eXBlLWF0dHJpYnV0ZS5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXG5lbWFpbDovXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyx1cmw6L14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFwvXFwvKCgoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDopKkApPygoKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16QS1aXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpBLVpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuPykoOlxcZCopPykoXFwvKCgoW2EtekEtWl18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSsoXFwvKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApKikqKT8pPyhcXD8oKChbYS16QS1aXXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFtcXHVFMDAwLVxcdUY4RkZdfFxcL3xcXD8pKik/KFxcIygoKFthLXpBLVpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCl8XFwvfFxcPykqKT8kLywvLyBhYmMuZGVcbmRvbWFpbjovXihbYS16QS1aMC05XShbYS16QS1aMC05XFwtXXswLDYxfVthLXpBLVowLTldKT9cXC4pK1thLXpBLVpdezIsOH0kLyxkYXRldGltZTovXihbMC0yXVswLTldezN9KVxcLShbMC0xXVswLTldKVxcLShbMC0zXVswLTldKVQoWzAtNV1bMC05XSlcXDooWzAtNV1bMC05XSlcXDooWzAtNV1bMC05XSkoWnwoW1xcLVxcK10oWzAtMV1bMC05XSlcXDowMCkpJC8sLy8gWVlZWS1NTS1ERFxuZGF0ZTovKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLywvLyBISDpNTTpTU1xudGltZTovXigwWzAtOV18MVswLTldfDJbMC0zXSkoOlswLTVdWzAtOV0pezJ9JC8sZGF0ZUlTTzovXlxcZHs0fVtcXC9cXC1dXFxkezEsMn1bXFwvXFwtXVxcZHsxLDJ9JC8sLy8gTU0vREQvWVlZWVxubW9udGhfZGF5X3llYXI6L14oMFsxLTldfDFbMDEyXSlbLSBcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcLy5dXFxkezR9JC8sLy8gREQvTU0vWVlZWVxuZGF5X21vbnRoX3llYXI6L14oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXC8uXSgwWzEtOV18MVswMTJdKVstIFxcLy5dXFxkezR9JC8sLy8gI0ZGRiBvciAjRkZGRkZGXG5jb2xvcjovXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvfSwvKipcbiAgICAgKiBPcHRpb25hbCB2YWxpZGF0aW9uIGZ1bmN0aW9ucyB0byBiZSB1c2VkLiBgZXF1YWxUb2AgYmVpbmcgdGhlIG9ubHkgZGVmYXVsdCBpbmNsdWRlZCBmdW5jdGlvbi5cbiAgICAgKiBGdW5jdGlvbnMgc2hvdWxkIHJldHVybiBvbmx5IGEgYm9vbGVhbiBpZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LiBGdW5jdGlvbnMgYXJlIGdpdmVuIHRoZSBmb2xsb3dpbmcgYXJndW1lbnRzOlxuICAgICAqIGVsIDogVGhlIGpRdWVyeSBlbGVtZW50IHRvIHZhbGlkYXRlLlxuICAgICAqIHJlcXVpcmVkIDogQm9vbGVhbiB2YWx1ZSBvZiB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIGJlIHByZXNlbnQgb3Igbm90LlxuICAgICAqIHBhcmVudCA6IFRoZSBkaXJlY3QgcGFyZW50IG9mIHRoZSBpbnB1dC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICovdmFsaWRhdG9yczp7ZXF1YWxUbzpmdW5jdGlvbiBlcXVhbFRvKGVsLHJlcXVpcmVkLHBhcmVudCl7cmV0dXJuICQoJyMnK2VsLmF0dHIoJ2RhdGEtZXF1YWx0bycpKS52YWwoKT09PWVsLnZhbCgpO319fTsvLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oQWJpZGUsJ0FiaWRlJyk7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fTt9KCk7IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBBY2NvcmRpb24gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAgICovdmFyIEFjY29yZGlvbj1mdW5jdGlvbigpey8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gYSBwbGFpbiBvYmplY3Qgd2l0aCBzZXR0aW5ncyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqL2Z1bmN0aW9uIEFjY29yZGlvbihlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLEFjY29yZGlvbik7dGhpcy4kZWxlbWVudD1lbGVtZW50O3RoaXMub3B0aW9ucz0kLmV4dGVuZCh7fSxBY2NvcmRpb24uZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnQWNjb3JkaW9uJyk7Rm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uJyx7J0VOVEVSJzondG9nZ2xlJywnU1BBQ0UnOid0b2dnbGUnLCdBUlJPV19ET1dOJzonbmV4dCcsJ0FSUk9XX1VQJzoncHJldmlvdXMnfSk7fS8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gYnkgYW5pbWF0aW5nIHRoZSBwcmVzZXQgYWN0aXZlIHBhbmUocykuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoQWNjb3JkaW9uLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt0aGlzLiRlbGVtZW50LmF0dHIoJ3JvbGUnLCd0YWJsaXN0Jyk7dGhpcy4kdGFicz10aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdsaSwgW2RhdGEtYWNjb3JkaW9uLWl0ZW1dJyk7dGhpcy4kdGFicy5lYWNoKGZ1bmN0aW9uKGlkeCxlbCl7dmFyICRlbD0kKGVsKSwkY29udGVudD0kZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLGlkPSRjb250ZW50WzBdLmlkfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsJ2FjY29yZGlvbicpLGxpbmtJZD1lbC5pZHx8aWQrJy1sYWJlbCc7JGVsLmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKHsnYXJpYS1jb250cm9scyc6aWQsJ3JvbGUnOid0YWInLCdpZCc6bGlua0lkLCdhcmlhLWV4cGFuZGVkJzpmYWxzZSwnYXJpYS1zZWxlY3RlZCc6ZmFsc2V9KTskY29udGVudC5hdHRyKHsncm9sZSc6J3RhYnBhbmVsJywnYXJpYS1sYWJlbGxlZGJ5JzpsaW5rSWQsJ2FyaWEtaGlkZGVuJzp0cnVlLCdpZCc6aWR9KTt9KTt2YXIgJGluaXRBY3RpdmU9dGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO2lmKCRpbml0QWN0aXZlLmxlbmd0aCl7dGhpcy5kb3duKCRpbml0QWN0aXZlLHRydWUpO310aGlzLl9ldmVudHMoKTt9LyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIGFjY29yZGlvbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19ldmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9ldmVudHMoKXt2YXIgX3RoaXM9dGhpczt0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24oKXt2YXIgJGVsZW09JCh0aGlzKTt2YXIgJHRhYkNvbnRlbnQ9JGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO2lmKCR0YWJDb250ZW50Lmxlbmd0aCl7JGVsZW0uY2hpbGRyZW4oJ2EnKS5vZmYoJ2NsaWNrLnpmLmFjY29yZGlvbiBrZXlkb3duLnpmLmFjY29yZGlvbicpLm9uKCdjbGljay56Zi5hY2NvcmRpb24nLGZ1bmN0aW9uKGUpey8vICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSkge1xuZS5wcmV2ZW50RGVmYXVsdCgpO2lmKCRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7aWYoX3RoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZHx8JGVsZW0uc2libGluZ3MoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpe190aGlzLnVwKCR0YWJDb250ZW50KTt9fWVsc2V7X3RoaXMuZG93bigkdGFiQ29udGVudCk7fX0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbicsZnVuY3Rpb24oZSl7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwnQWNjb3JkaW9uJyx7dG9nZ2xlOmZ1bmN0aW9uIHRvZ2dsZSgpe190aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7fSxuZXh0OmZ1bmN0aW9uIG5leHQoKXt2YXIgJGE9JGVsZW0ubmV4dCgpLmZpbmQoJ2EnKS5mb2N1cygpO2lmKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKXskYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTt9fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe3ZhciAkYT0kZWxlbS5wcmV2KCkuZmluZCgnYScpLmZvY3VzKCk7aWYoIV90aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQpeyRhLnRyaWdnZXIoJ2NsaWNrLnpmLmFjY29yZGlvbicpO319LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe2UucHJldmVudERlZmF1bHQoKTtlLnN0b3BQcm9wYWdhdGlvbigpO319KTt9KTt9fSk7fS8qKlxuICAgICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0galF1ZXJ5IG9iamVjdCBvZiB0aGUgcGFuZSB0byB0b2dnbGUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTondG9nZ2xlJyx2YWx1ZTpmdW5jdGlvbiB0b2dnbGUoJHRhcmdldCl7aWYoJHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpe2lmKHRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZHx8JHRhcmdldC5wYXJlbnQoKS5zaWJsaW5ncygpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSl7dGhpcy51cCgkdGFyZ2V0KTt9ZWxzZXtyZXR1cm47fX1lbHNle3RoaXMuZG93bigkdGFyZ2V0KTt9fS8qKlxuICAgICAgICogT3BlbnMgdGhlIGFjY29yZGlvbiB0YWIgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiBwYW5lIHRvIG9wZW4uXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpcnN0VGltZSAtIGZsYWcgdG8gZGV0ZXJtaW5lIGlmIHJlZmxvdyBzaG91bGQgaGFwcGVuLlxuICAgICAgICogQGZpcmVzIEFjY29yZGlvbiNkb3duXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonZG93bicsdmFsdWU6ZnVuY3Rpb24gZG93bigkdGFyZ2V0LGZpcnN0VGltZSl7dmFyIF90aGlzMj10aGlzO2lmKCF0aGlzLm9wdGlvbnMubXVsdGlFeHBhbmQmJiFmaXJzdFRpbWUpe3ZhciAkY3VycmVudEFjdGl2ZT10aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtYWN0aXZlJykuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpO2lmKCRjdXJyZW50QWN0aXZlLmxlbmd0aCl7dGhpcy51cCgkY3VycmVudEFjdGl2ZSk7fX0kdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJyxmYWxzZSkucGFyZW50KCdbZGF0YS10YWItY29udGVudF0nKS5hZGRCYWNrKCkucGFyZW50KCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpOyR0YXJnZXQuc2xpZGVEb3duKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLGZ1bmN0aW9uKCl7LyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uI2Rvd25cbiAgICAgICAgICAgKi9fdGhpczIuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb24nLFskdGFyZ2V0XSk7fSk7JCgnIycrJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7J2FyaWEtZXhwYW5kZWQnOnRydWUsJ2FyaWEtc2VsZWN0ZWQnOnRydWV9KTt9LyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZS5cbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb24jdXBcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5Oid1cCcsdmFsdWU6ZnVuY3Rpb24gdXAoJHRhcmdldCl7dmFyICRhdW50cz0kdGFyZ2V0LnBhcmVudCgpLnNpYmxpbmdzKCksX3RoaXM9dGhpczt2YXIgY2FuQ2xvc2U9dGhpcy5vcHRpb25zLm11bHRpRXhwYW5kPyRhdW50cy5oYXNDbGFzcygnaXMtYWN0aXZlJyk6JHRhcmdldC5wYXJlbnQoKS5oYXNDbGFzcygnaXMtYWN0aXZlJyk7aWYoIXRoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZCYmIWNhbkNsb3NlKXtyZXR1cm47fS8vIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcbiR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXsvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB0YWIgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jdXBcbiAgICAgICAgICAgKi9fdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cC56Zi5hY2NvcmRpb24nLFskdGFyZ2V0XSk7fSk7Ly8gfSk7XG4kdGFyZ2V0LmF0dHIoJ2FyaWEtaGlkZGVuJyx0cnVlKS5wYXJlbnQoKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7JCgnIycrJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7J2FyaWEtZXhwYW5kZWQnOmZhbHNlLCdhcmlhLXNlbGVjdGVkJzpmYWxzZX0pO30vKipcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb24jZGVzdHJveWVkXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtdGFiLWNvbnRlbnRdJykuc3RvcCh0cnVlKS5zbGlkZVVwKDApLmNzcygnZGlzcGxheScsJycpO3RoaXMuJGVsZW1lbnQuZmluZCgnYScpLm9mZignLnpmLmFjY29yZGlvbicpO0ZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pO3JldHVybiBBY2NvcmRpb247fSgpO0FjY29yZGlvbi5kZWZhdWx0cz17LyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgdG8gYW5pbWF0ZSB0aGUgb3BlbmluZyBvZiBhbiBhY2NvcmRpb24gcGFuZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMjUwXG4gICAgICovc2xpZGVTcGVlZDoyNTAsLyoqXG4gICAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovbXVsdGlFeHBhbmQ6ZmFsc2UsLyoqXG4gICAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBjbG9zZSBhbGwgcGFuZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovYWxsb3dBbGxDbG9zZWQ6ZmFsc2V9Oy8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb24sJ0FjY29yZGlvbicpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogQWNjb3JkaW9uTWVudSBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25NZW51XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XG4gICAqL3ZhciBBY2NvcmRpb25NZW51PWZ1bmN0aW9uKCl7LyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24gbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovZnVuY3Rpb24gQWNjb3JkaW9uTWVudShlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLEFjY29yZGlvbk1lbnUpO3RoaXMuJGVsZW1lbnQ9ZWxlbWVudDt0aGlzLm9wdGlvbnM9JC5leHRlbmQoe30sQWNjb3JkaW9uTWVudS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxvcHRpb25zKTtGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCdhY2NvcmRpb24nKTt0aGlzLl9pbml0KCk7Rm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCdBY2NvcmRpb25NZW51Jyk7Rm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uTWVudScseydFTlRFUic6J3RvZ2dsZScsJ1NQQUNFJzondG9nZ2xlJywnQVJST1dfUklHSFQnOidvcGVuJywnQVJST1dfVVAnOid1cCcsJ0FSUk9XX0RPV04nOidkb3duJywnQVJST1dfTEVGVCc6J2Nsb3NlJywnRVNDQVBFJzonY2xvc2VBbGwnLCdUQUInOidkb3duJywnU0hJRlRfVEFCJzondXAnfSk7fS8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBhY2NvcmRpb24gbWVudSBieSBoaWRpbmcgYWxsIG5lc3RlZCBtZW51cy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhBY2NvcmRpb25NZW51LFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykubm90KCcuaXMtYWN0aXZlJykuc2xpZGVVcCgwKTsvLy5maW5kKCdhJykuY3NzKCdwYWRkaW5nLWxlZnQnLCAnMXJlbScpO1xudGhpcy4kZWxlbWVudC5hdHRyKHsncm9sZSc6J3RhYmxpc3QnLCdhcmlhLW11bHRpc2VsZWN0YWJsZSc6dGhpcy5vcHRpb25zLm11bHRpT3Blbn0pO3RoaXMuJG1lbnVMaW5rcz10aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKTt0aGlzLiRtZW51TGlua3MuZWFjaChmdW5jdGlvbigpe3ZhciBsaW5rSWQ9dGhpcy5pZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCdhY2MtbWVudS1saW5rJyksJGVsZW09JCh0aGlzKSwkc3ViPSRlbGVtLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLHN1YklkPSRzdWJbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwnYWNjLW1lbnUnKSxpc0FjdGl2ZT0kc3ViLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTskZWxlbS5hdHRyKHsnYXJpYS1jb250cm9scyc6c3ViSWQsJ2FyaWEtZXhwYW5kZWQnOmlzQWN0aXZlLCdyb2xlJzondGFiJywnaWQnOmxpbmtJZH0pOyRzdWIuYXR0cih7J2FyaWEtbGFiZWxsZWRieSc6bGlua0lkLCdhcmlhLWhpZGRlbic6IWlzQWN0aXZlLCdyb2xlJzondGFicGFuZWwnLCdpZCc6c3ViSWR9KTt9KTt2YXIgaW5pdFBhbmVzPXRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpO2lmKGluaXRQYW5lcy5sZW5ndGgpe3ZhciBfdGhpcz10aGlzO2luaXRQYW5lcy5lYWNoKGZ1bmN0aW9uKCl7X3RoaXMuZG93bigkKHRoaXMpKTt9KTt9dGhpcy5fZXZlbnRzKCk7fS8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBtZW51LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpcz10aGlzO3RoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5lYWNoKGZ1bmN0aW9uKCl7dmFyICRzdWJtZW51PSQodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7aWYoJHN1Ym1lbnUubGVuZ3RoKXskKHRoaXMpLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jykub24oJ2NsaWNrLnpmLmFjY29yZGlvbk1lbnUnLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtfdGhpcy50b2dnbGUoJHN1Ym1lbnUpO30pO319KS5vbigna2V5ZG93bi56Zi5hY2NvcmRpb25tZW51JyxmdW5jdGlvbihlKXt2YXIgJGVsZW1lbnQ9JCh0aGlzKSwkZWxlbWVudHM9JGVsZW1lbnQucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLCRwcmV2RWxlbWVudCwkbmV4dEVsZW1lbnQsJHRhcmdldD0kZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKTskZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKXtpZigkKHRoaXMpLmlzKCRlbGVtZW50KSl7JHByZXZFbGVtZW50PSRlbGVtZW50cy5lcShNYXRoLm1heCgwLGktMSkpLmZpbmQoJ2EnKS5maXJzdCgpOyRuZXh0RWxlbWVudD0kZWxlbWVudHMuZXEoTWF0aC5taW4oaSsxLCRlbGVtZW50cy5sZW5ndGgtMSkpLmZpbmQoJ2EnKS5maXJzdCgpO2lmKCQodGhpcykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpey8vIGhhcyBvcGVuIHN1YiBtZW51XG4kbmV4dEVsZW1lbnQ9JGVsZW1lbnQuZmluZCgnbGk6Zmlyc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTt9aWYoJCh0aGlzKS5pcygnOmZpcnN0LWNoaWxkJykpey8vIGlzIGZpcnN0IGVsZW1lbnQgb2Ygc3ViIG1lbnVcbiRwcmV2RWxlbWVudD0kZWxlbWVudC5wYXJlbnRzKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCk7fWVsc2UgaWYoJHByZXZFbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XTp2aXNpYmxlJykubGVuZ3RoKXsvLyBpZiBwcmV2aW91cyBlbGVtZW50IGhhcyBvcGVuIHN1YiBtZW51XG4kcHJldkVsZW1lbnQ9JHByZXZFbGVtZW50LmZpbmQoJ2xpOmxhc3QtY2hpbGQnKS5maW5kKCdhJykuZmlyc3QoKTt9aWYoJCh0aGlzKS5pcygnOmxhc3QtY2hpbGQnKSl7Ly8gaXMgbGFzdCBlbGVtZW50IG9mIHN1YiBtZW51XG4kbmV4dEVsZW1lbnQ9JGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLm5leHQoJ2xpJykuZmluZCgnYScpLmZpcnN0KCk7fXJldHVybjt9fSk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwnQWNjb3JkaW9uTWVudScse29wZW46ZnVuY3Rpb24gb3Blbigpe2lmKCR0YXJnZXQuaXMoJzpoaWRkZW4nKSl7X3RoaXMuZG93bigkdGFyZ2V0KTskdGFyZ2V0LmZpbmQoJ2xpJykuZmlyc3QoKS5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpO319LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7aWYoJHRhcmdldC5sZW5ndGgmJiEkdGFyZ2V0LmlzKCc6aGlkZGVuJykpey8vIGNsb3NlIGFjdGl2ZSBzdWIgb2YgdGhpcyBpdGVtXG5fdGhpcy51cCgkdGFyZ2V0KTt9ZWxzZSBpZigkZWxlbWVudC5wYXJlbnQoJ1tkYXRhLXN1Ym1lbnVdJykubGVuZ3RoKXsvLyBjbG9zZSBjdXJyZW50bHkgb3BlbiBzdWJcbl90aGlzLnVwKCRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3VibWVudV0nKSk7JGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7fX0sdXA6ZnVuY3Rpb24gdXAoKXskcHJldkVsZW1lbnQuYXR0cigndGFiaW5kZXgnLC0xKS5mb2N1cygpO3JldHVybiB0cnVlO30sZG93bjpmdW5jdGlvbiBkb3duKCl7JG5leHRFbGVtZW50LmF0dHIoJ3RhYmluZGV4JywtMSkuZm9jdXMoKTtyZXR1cm4gdHJ1ZTt9LHRvZ2dsZTpmdW5jdGlvbiB0b2dnbGUoKXtpZigkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpe190aGlzLnRvZ2dsZSgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSk7fX0sY2xvc2VBbGw6ZnVuY3Rpb24gY2xvc2VBbGwoKXtfdGhpcy5oaWRlQWxsKCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQocHJldmVudERlZmF1bHQpe2lmKHByZXZlbnREZWZhdWx0KXtlLnByZXZlbnREZWZhdWx0KCk7fWUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX0pO30pOy8vLmF0dHIoJ3RhYmluZGV4JywgMCk7XG59LyoqXG4gICAgICAgKiBDbG9zZXMgYWxsIHBhbmVzIG9mIHRoZSBtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J2hpZGVBbGwnLHZhbHVlOmZ1bmN0aW9uIGhpZGVBbGwoKXt0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7fS8qKlxuICAgICAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZSBzdGF0ZSBvZiBhIHN1Ym1lbnUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gdGhlIHN1Ym1lbnUgdG8gdG9nZ2xlXG4gICAgICAgKi99LHtrZXk6J3RvZ2dsZScsdmFsdWU6ZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpe2lmKCEkdGFyZ2V0LmlzKCc6YW5pbWF0ZWQnKSl7aWYoISR0YXJnZXQuaXMoJzpoaWRkZW4nKSl7dGhpcy51cCgkdGFyZ2V0KTt9ZWxzZXt0aGlzLmRvd24oJHRhcmdldCk7fX19LyoqXG4gICAgICAgKiBPcGVucyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIG9wZW4uXG4gICAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNkb3duXG4gICAgICAgKi99LHtrZXk6J2Rvd24nLHZhbHVlOmZ1bmN0aW9uIGRvd24oJHRhcmdldCl7dmFyIF90aGlzPXRoaXM7aWYoIXRoaXMub3B0aW9ucy5tdWx0aU9wZW4pe3RoaXMudXAodGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWN0aXZlJykubm90KCR0YXJnZXQucGFyZW50c1VudGlsKHRoaXMuJGVsZW1lbnQpLmFkZCgkdGFyZ2V0KSkpO30kdGFyZ2V0LmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsnYXJpYS1oaWRkZW4nOmZhbHNlfSkucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7J2FyaWEtZXhwYW5kZWQnOnRydWV9KTsvL0ZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKSB7XG4kdGFyZ2V0LnNsaWRlRG93bihfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsZnVuY3Rpb24oKXsvKipcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtZW51IGlzIGRvbmUgb3BlbmluZy5cbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSNkb3duXG4gICAgICAgICAgICovX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb25NZW51JyxbJHRhcmdldF0pO30pOy8vfSk7XG59LyoqXG4gICAgICAgKiBDbG9zZXMgdGhlIHN1Yi1tZW51IGRlZmluZWQgYnkgYCR0YXJnZXRgLiBBbGwgc3ViLW1lbnVzIGluc2lkZSB0aGUgdGFyZ2V0IHdpbGwgYmUgY2xvc2VkIGFzIHdlbGwuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIGNsb3NlLlxuICAgICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjdXBcbiAgICAgICAqL30se2tleTondXAnLHZhbHVlOmZ1bmN0aW9uIHVwKCR0YXJnZXQpe3ZhciBfdGhpcz10aGlzOy8vRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAkdGFyZ2V0LCBmdW5jdGlvbigpe1xuJHRhcmdldC5zbGlkZVVwKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCxmdW5jdGlvbigpey8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxuICAgICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I3VwXG4gICAgICAgICAgICovX3RoaXMuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uTWVudScsWyR0YXJnZXRdKTt9KTsvL30pO1xudmFyICRtZW51cz0kdGFyZ2V0LmZpbmQoJ1tkYXRhLXN1Ym1lbnVdJykuc2xpZGVVcCgwKS5hZGRCYWNrKCkuYXR0cignYXJpYS1oaWRkZW4nLHRydWUpOyRtZW51cy5wYXJlbnQoJy5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQnKS5hdHRyKCdhcmlhLWV4cGFuZGVkJyxmYWxzZSk7fS8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYWNjb3JkaW9uIG1lbnUuXG4gICAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNkZXN0cm95ZWRcbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5zbGlkZURvd24oMCkuY3NzKCdkaXNwbGF5JywnJyk7dGhpcy4kZWxlbWVudC5maW5kKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jyk7Rm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCwnYWNjb3JkaW9uJyk7Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSk7cmV0dXJuIEFjY29yZGlvbk1lbnU7fSgpO0FjY29yZGlvbk1lbnUuZGVmYXVsdHM9ey8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyNTBcbiAgICAgKi9zbGlkZVNwZWVkOjI1MCwvKipcbiAgICAgKiBBbGxvdyB0aGUgbWVudSB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9tdWx0aU9wZW46dHJ1ZX07Ly8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKEFjY29yZGlvbk1lbnUsJ0FjY29yZGlvbk1lbnUnKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvcilkZXNjcmlwdG9yLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKTt9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtpZihwcm90b1Byb3BzKWRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpO2lmKHN0YXRpY1Byb3BzKWRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9O30oKTshZnVuY3Rpb24oJCl7LyoqXG4gICAqIERyaWxsZG93biBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5kcmlsbGRvd25cbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcbiAgICovdmFyIERyaWxsZG93bj1mdW5jdGlvbigpey8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcmlsbGRvd24gbWVudS5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9mdW5jdGlvbiBEcmlsbGRvd24oZWxlbWVudCxvcHRpb25zKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxEcmlsbGRvd24pO3RoaXMuJGVsZW1lbnQ9ZWxlbWVudDt0aGlzLm9wdGlvbnM9JC5leHRlbmQoe30sRHJpbGxkb3duLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG9wdGlvbnMpO0ZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsJ2RyaWxsZG93bicpO3RoaXMuX2luaXQoKTtGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsJ0RyaWxsZG93bicpO0ZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0RyaWxsZG93bicseydFTlRFUic6J29wZW4nLCdTUEFDRSc6J29wZW4nLCdBUlJPV19SSUdIVCc6J25leHQnLCdBUlJPV19VUCc6J3VwJywnQVJST1dfRE9XTic6J2Rvd24nLCdBUlJPV19MRUZUJzoncHJldmlvdXMnLCdFU0NBUEUnOidjbG9zZScsJ1RBQic6J2Rvd24nLCdTSElGVF9UQUInOid1cCd9KTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGRyaWxsZG93biBieSBjcmVhdGluZyBqUXVlcnkgY29sbGVjdGlvbnMgb2YgZWxlbWVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhEcmlsbGRvd24sW3trZXk6J19pbml0Jyx2YWx1ZTpmdW5jdGlvbiBfaW5pdCgpe3RoaXMuJHN1Ym1lbnVBbmNob3JzPXRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJ2EnKTt0aGlzLiRzdWJtZW51cz10aGlzLiRzdWJtZW51QW5jaG9ycy5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJyk7dGhpcy4kbWVudUl0ZW1zPXRoaXMuJGVsZW1lbnQuZmluZCgnbGknKS5ub3QoJy5qcy1kcmlsbGRvd24tYmFjaycpLmF0dHIoJ3JvbGUnLCdtZW51aXRlbScpLmZpbmQoJ2EnKTt0aGlzLl9wcmVwYXJlTWVudSgpO3RoaXMuX2tleWJvYXJkRXZlbnRzKCk7fS8qKlxuICAgICAgICogcHJlcGFyZXMgZHJpbGxkb3duIG1lbnUgYnkgc2V0dGluZyBhdHRyaWJ1dGVzIHRvIGxpbmtzIGFuZCBlbGVtZW50c1xuICAgICAgICogc2V0cyBhIG1pbiBoZWlnaHQgdG8gcHJldmVudCBjb250ZW50IGp1bXBpbmdcbiAgICAgICAqIHdyYXBzIHRoZSBlbGVtZW50IGlmIG5vdCBhbHJlYWR5IHdyYXBwZWRcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonX3ByZXBhcmVNZW51Jyx2YWx1ZTpmdW5jdGlvbiBfcHJlcGFyZU1lbnUoKXt2YXIgX3RoaXM9dGhpczsvLyBpZighdGhpcy5vcHRpb25zLmhvbGRPcGVuKXtcbi8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcbi8vIH1cbnRoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24oKXt2YXIgJGxpbms9JCh0aGlzKTt2YXIgJHN1Yj0kbGluay5wYXJlbnQoKTtpZihfdGhpcy5vcHRpb25zLnBhcmVudExpbmspeyRsaW5rLmNsb25lKCkucHJlcGVuZFRvKCRzdWIuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykpLndyYXAoJzxsaSBjbGFzcz1cImlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0gaXMtc3VibWVudS1pdGVtIGlzLWRyaWxsZG93bi1zdWJtZW51LWl0ZW1cIiByb2xlPVwibWVudS1pdGVtXCI+PC9saT4nKTt9JGxpbmsuZGF0YSgnc2F2ZWRIcmVmJywkbGluay5hdHRyKCdocmVmJykpLnJlbW92ZUF0dHIoJ2hyZWYnKTskbGluay5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hdHRyKHsnYXJpYS1oaWRkZW4nOnRydWUsJ3RhYmluZGV4JzowLCdyb2xlJzonbWVudSd9KTtfdGhpcy5fZXZlbnRzKCRsaW5rKTt9KTt0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uKCl7dmFyICRtZW51PSQodGhpcyksJGJhY2s9JG1lbnUuZmluZCgnLmpzLWRyaWxsZG93bi1iYWNrJyk7aWYoISRiYWNrLmxlbmd0aCl7JG1lbnUucHJlcGVuZChfdGhpcy5vcHRpb25zLmJhY2tCdXR0b24pO31fdGhpcy5fYmFjaygkbWVudSk7fSk7aWYoIXRoaXMuJGVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWRyaWxsZG93bicpKXt0aGlzLiR3cmFwcGVyPSQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKCdpcy1kcmlsbGRvd24nKTt0aGlzLiR3cmFwcGVyPXRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKS5wYXJlbnQoKS5jc3ModGhpcy5fZ2V0TWF4RGltcygpKTt9fS8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byBlbGVtZW50cyBpbiB0aGUgbWVudS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IG1lbnUgaXRlbSB0byBhZGQgaGFuZGxlcnMgdG8uXG4gICAgICAgKi99LHtrZXk6J19ldmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9ldmVudHMoJGVsZW0pe3ZhciBfdGhpcz10aGlzOyRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsZnVuY3Rpb24oZSl7aWYoJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsJ2xpJykuaGFzQ2xhc3MoJ2lzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpKXtlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO2UucHJldmVudERlZmF1bHQoKTt9Ly8gaWYoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldC5maXJzdEVsZW1lbnRDaGlsZCl7XG4vLyAgIHJldHVybiBmYWxzZTtcbi8vIH1cbl90aGlzLl9zaG93KCRlbGVtLnBhcmVudCgnbGknKSk7aWYoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe3ZhciAkYm9keT0kKCdib2R5Jyk7JGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsZnVuY3Rpb24oZSl7aWYoZS50YXJnZXQ9PT1fdGhpcy4kZWxlbWVudFswXXx8JC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSxlLnRhcmdldCkpe3JldHVybjt9ZS5wcmV2ZW50RGVmYXVsdCgpO190aGlzLl9oaWRlQWxsKCk7JGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJyk7fSk7fX0pO30vKipcbiAgICAgICAqIEFkZHMga2V5ZG93biBldmVudCBsaXN0ZW5lciB0byBgbGlgJ3MgaW4gdGhlIG1lbnUuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5Oidfa2V5Ym9hcmRFdmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9rZXlib2FyZEV2ZW50cygpe3ZhciBfdGhpcz10aGlzO3RoaXMuJG1lbnVJdGVtcy5hZGQodGhpcy4kZWxlbWVudC5maW5kKCcuanMtZHJpbGxkb3duLWJhY2sgPiBhJykpLm9uKCdrZXlkb3duLnpmLmRyaWxsZG93bicsZnVuY3Rpb24oZSl7dmFyICRlbGVtZW50PSQodGhpcyksJGVsZW1lbnRzPSRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKSwkcHJldkVsZW1lbnQsJG5leHRFbGVtZW50OyRlbGVtZW50cy5lYWNoKGZ1bmN0aW9uKGkpe2lmKCQodGhpcykuaXMoJGVsZW1lbnQpKXskcHJldkVsZW1lbnQ9JGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsaS0xKSk7JG5leHRFbGVtZW50PSRlbGVtZW50cy5lcShNYXRoLm1pbihpKzEsJGVsZW1lbnRzLmxlbmd0aC0xKSk7cmV0dXJuO319KTtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCdEcmlsbGRvd24nLHtuZXh0OmZ1bmN0aW9uIG5leHQoKXtpZigkZWxlbWVudC5pcyhfdGhpcy4kc3VibWVudUFuY2hvcnMpKXtfdGhpcy5fc2hvdygkZWxlbWVudC5wYXJlbnQoJ2xpJykpOyRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSxmdW5jdGlvbigpeyRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTt9KTtyZXR1cm4gdHJ1ZTt9fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe190aGlzLl9oaWRlKCRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykpOyRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbWVudCksZnVuY3Rpb24oKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7JGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7fSwxKTt9KTtyZXR1cm4gdHJ1ZTt9LHVwOmZ1bmN0aW9uIHVwKCl7JHByZXZFbGVtZW50LmZvY3VzKCk7cmV0dXJuIHRydWU7fSxkb3duOmZ1bmN0aW9uIGRvd24oKXskbmV4dEVsZW1lbnQuZm9jdXMoKTtyZXR1cm4gdHJ1ZTt9LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7X3RoaXMuX2JhY2soKTsvL190aGlzLiRtZW51SXRlbXMuZmlyc3QoKS5mb2N1cygpOyAvLyBmb2N1cyB0byBmaXJzdCBlbGVtZW50XG59LG9wZW46ZnVuY3Rpb24gb3Blbigpe2lmKCEkZWxlbWVudC5pcyhfdGhpcy4kbWVudUl0ZW1zKSl7Ly8gbm90IG1lbnUgaXRlbSBtZWFucyBiYWNrIGJ1dHRvblxuX3RoaXMuX2hpZGUoJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKSk7JGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSxmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXskZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLnBhcmVudCgnbGknKS5jaGlsZHJlbignYScpLmZpcnN0KCkuZm9jdXMoKTt9LDEpO30pO31lbHNlIGlmKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpe190aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7JGVsZW1lbnQucGFyZW50KCdsaScpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLGZ1bmN0aW9uKCl7JGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5maWx0ZXIoX3RoaXMuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO30pO31yZXR1cm4gdHJ1ZTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZChwcmV2ZW50RGVmYXVsdCl7aWYocHJldmVudERlZmF1bHQpe2UucHJldmVudERlZmF1bHQoKTt9ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTt9fSk7fSk7Ly8gZW5kIGtleWJvYXJkQWNjZXNzXG59LyoqXG4gICAgICAgKiBDbG9zZXMgYWxsIG9wZW4gZWxlbWVudHMsIGFuZCByZXR1cm5zIHRvIHJvb3QgbWVudS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZWRcbiAgICAgICAqL30se2tleTonX2hpZGVBbGwnLHZhbHVlOmZ1bmN0aW9uIF9oaWRlQWxsKCl7dmFyICRlbGVtPXRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZScpLmFkZENsYXNzKCdpcy1jbG9zaW5nJyk7JGVsZW0ub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbSksZnVuY3Rpb24oZSl7JGVsZW0ucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nJyk7fSk7LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgY2xvc2VkLlxuICAgICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI2Nsb3NlZFxuICAgICAgICAgKi90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlZC56Zi5kcmlsbGRvd24nKTt9LyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVyIGZvciBlYWNoIGBiYWNrYCBidXR0b24sIGFuZCBjbG9zZXMgb3BlbiBtZW51cy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIERyaWxsZG93biNiYWNrXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBzdWItbWVudSB0byBhZGQgYGJhY2tgIGV2ZW50LlxuICAgICAgICovfSx7a2V5OidfYmFjaycsdmFsdWU6ZnVuY3Rpb24gX2JhY2soJGVsZW0pe3ZhciBfdGhpcz10aGlzOyRlbGVtLm9mZignY2xpY2suemYuZHJpbGxkb3duJyk7JGVsZW0uY2hpbGRyZW4oJy5qcy1kcmlsbGRvd24tYmFjaycpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7Ly8gY29uc29sZS5sb2coJ21vdXNldXAgb24gYmFjaycpO1xuX3RoaXMuX2hpZGUoJGVsZW0pO30pO30vKipcbiAgICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgdG8gbWVudSBpdGVtcyB3L28gc3VibWVudXMgdG8gY2xvc2Ugb3BlbiBtZW51cyBvbiBjbGljay5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX21lbnVMaW5rRXZlbnRzJyx2YWx1ZTpmdW5jdGlvbiBfbWVudUxpbmtFdmVudHMoKXt2YXIgX3RoaXM9dGhpczt0aGlzLiRtZW51SXRlbXMubm90KCcuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50Jykub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKS5vbignY2xpY2suemYuZHJpbGxkb3duJyxmdW5jdGlvbihlKXsvLyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuc2V0VGltZW91dChmdW5jdGlvbigpe190aGlzLl9oaWRlQWxsKCk7fSwwKTt9KTt9LyoqXG4gICAgICAgKiBPcGVucyBhIHN1Ym1lbnUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBEcmlsbGRvd24jb3BlblxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gdGhlIGN1cnJlbnQgZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBvcGVuLCBpLmUuIHRoZSBgbGlgIHRhZy5cbiAgICAgICAqL30se2tleTonX3Nob3cnLHZhbHVlOmZ1bmN0aW9uIF9zaG93KCRlbGVtKXskZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaGFzIG9wZW5lZC5cbiAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNvcGVuXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcignb3Blbi56Zi5kcmlsbGRvd24nLFskZWxlbV0pO319LHtrZXk6J19oaWRlJywvKipcbiAgICAgICAqIEhpZGVzIGEgc3VibWVudVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2hpZGVcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGhpZGUsIGkuZS4gdGhlIGB1bGAgdGFnLlxuICAgICAgICovdmFsdWU6ZnVuY3Rpb24gX2hpZGUoJGVsZW0pe3ZhciBfdGhpcz10aGlzOyRlbGVtLmFkZENsYXNzKCdpcy1jbG9zaW5nJykub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbSksZnVuY3Rpb24oKXskZWxlbS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWNsb3NpbmcnKTskZWxlbS5ibHVyKCk7fSk7LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHN1Ym1lbnUgaGFzIGNsb3NlZC5cbiAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNoaWRlXG4gICAgICAgICAqLyRlbGVtLnRyaWdnZXIoJ2hpZGUuemYuZHJpbGxkb3duJyxbJGVsZW1dKTt9LyoqXG4gICAgICAgKiBJdGVyYXRlcyB0aHJvdWdoIHRoZSBuZXN0ZWQgbWVudXMgdG8gY2FsY3VsYXRlIHRoZSBtaW4taGVpZ2h0LCBhbmQgbWF4LXdpZHRoIGZvciB0aGUgbWVudS5cbiAgICAgICAqIFByZXZlbnRzIGNvbnRlbnQganVtcGluZy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2dldE1heERpbXMnLHZhbHVlOmZ1bmN0aW9uIF9nZXRNYXhEaW1zKCl7dmFyIG1heD0wLHJlc3VsdD17fTt0aGlzLiRzdWJtZW51cy5hZGQodGhpcy4kZWxlbWVudCkuZWFjaChmdW5jdGlvbigpe3ZhciBudW1PZkVsZW1zPSQodGhpcykuY2hpbGRyZW4oJ2xpJykubGVuZ3RoO21heD1udW1PZkVsZW1zPm1heD9udW1PZkVsZW1zOm1heDt9KTtyZXN1bHRbJ21pbi1oZWlnaHQnXT1tYXgqdGhpcy4kbWVudUl0ZW1zWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCsncHgnO3Jlc3VsdFsnbWF4LXdpZHRoJ109dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCsncHgnO3JldHVybiByZXN1bHQ7fS8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIERyaWxsZG93biBNZW51XG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe3RoaXMuX2hpZGVBbGwoKTtGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCdkcmlsbGRvd24nKTt0aGlzLiRlbGVtZW50LnVud3JhcCgpLmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaywgLmlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0nKS5yZW1vdmUoKS5lbmQoKS5maW5kKCcuaXMtYWN0aXZlLCAuaXMtY2xvc2luZywgLmlzLWRyaWxsZG93bi1zdWJtZW51JykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51JykuZW5kKCkuZmluZCgnW2RhdGEtc3VibWVudV0nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlJyk7dGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbigpeyQodGhpcykub2ZmKCcuemYuZHJpbGxkb3duJyk7fSk7dGhpcy4kZWxlbWVudC5maW5kKCdhJykuZWFjaChmdW5jdGlvbigpe3ZhciAkbGluaz0kKHRoaXMpO2lmKCRsaW5rLmRhdGEoJ3NhdmVkSHJlZicpKXskbGluay5hdHRyKCdocmVmJywkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkucmVtb3ZlRGF0YSgnc2F2ZWRIcmVmJyk7fWVsc2V7cmV0dXJuO319KTtGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gRHJpbGxkb3duO30oKTtEcmlsbGRvd24uZGVmYXVsdHM9ey8qKlxuICAgICAqIE1hcmt1cCB1c2VkIGZvciBKUyBnZW5lcmF0ZWQgYmFjayBidXR0b24uIFByZXBlbmRlZCB0byBzdWJtZW51IGxpc3RzIGFuZCBkZWxldGVkIG9uIGBkZXN0cm95YCBtZXRob2QsICdqcy1kcmlsbGRvd24tYmFjaycgY2xhc3MgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxgKSBpZiBjb3B5IGFuZCBwYXN0aW5nLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnPFxcbGk+PFxcYT5CYWNrPFxcL2E+PFxcL2xpPidcbiAgICAgKi9iYWNrQnV0dG9uOic8bGkgY2xhc3M9XCJqcy1kcmlsbGRvd24tYmFja1wiPjxhIHRhYmluZGV4PVwiMFwiPkJhY2s8L2E+PC9saT4nLC8qKlxuICAgICAqIE1hcmt1cCB1c2VkIHRvIHdyYXAgZHJpbGxkb3duIG1lbnUuIFVzZSBhIGNsYXNzIG5hbWUgZm9yIGluZGVwZW5kZW50IHN0eWxpbmc7IHRoZSBKUyBhcHBsaWVkIGNsYXNzOiBgaXMtZHJpbGxkb3duYCBpcyByZXF1aXJlZC4gUmVtb3ZlIHRoZSBiYWNrc2xhc2ggKGBcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICc8XFxkaXYgY2xhc3M9XCJpcy1kcmlsbGRvd25cIj48XFwvZGl2PidcbiAgICAgKi93cmFwcGVyOic8ZGl2PjwvZGl2PicsLyoqXG4gICAgICogQWRkcyB0aGUgcGFyZW50IGxpbmsgdG8gdGhlIHN1Ym1lbnUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovcGFyZW50TGluazpmYWxzZSwvKipcbiAgICAgKiBBbGxvdyB0aGUgbWVudSB0byByZXR1cm4gdG8gcm9vdCBsaXN0IG9uIGJvZHkgY2xpY2suXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovY2xvc2VPbkNsaWNrOmZhbHNlLy8gaG9sZE9wZW46IGZhbHNlXG59Oy8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihEcmlsbGRvd24sJ0RyaWxsZG93bicpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogRHJvcGRvd24gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd25cbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqL3ZhciBEcm9wZG93bj1mdW5jdGlvbigpey8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24uXG4gICAgICogICAgICAgIE9iamVjdCBzaG91bGQgYmUgb2YgdGhlIGRyb3Bkb3duIHBhbmVsLCByYXRoZXIgdGhhbiBpdHMgYW5jaG9yLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAgKi9mdW5jdGlvbiBEcm9wZG93bihlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLERyb3Bkb3duKTt0aGlzLiRlbGVtZW50PWVsZW1lbnQ7dGhpcy5vcHRpb25zPSQuZXh0ZW5kKHt9LERyb3Bkb3duLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG9wdGlvbnMpO3RoaXMuX2luaXQoKTtGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsJ0Ryb3Bkb3duJyk7Rm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignRHJvcGRvd24nLHsnRU5URVInOidvcGVuJywnU1BBQ0UnOidvcGVuJywnRVNDQVBFJzonY2xvc2UnLCdUQUInOid0YWJfZm9yd2FyZCcsJ1NISUZUX1RBQic6J3RhYl9iYWNrd2FyZCd9KTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBzZXR0aW5nL2NoZWNraW5nIG9wdGlvbnMgYW5kIGF0dHJpYnV0ZXMsIGFkZGluZyBoZWxwZXIgdmFyaWFibGVzLCBhbmQgc2F2aW5nIHRoZSBhbmNob3IuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoRHJvcGRvd24sW3trZXk6J19pbml0Jyx2YWx1ZTpmdW5jdGlvbiBfaW5pdCgpe3ZhciAkaWQ9dGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO3RoaXMuJGFuY2hvcj0kKCdbZGF0YS10b2dnbGU9XCInKyRpZCsnXCJdJyl8fCQoJ1tkYXRhLW9wZW49XCInKyRpZCsnXCJdJyk7dGhpcy4kYW5jaG9yLmF0dHIoeydhcmlhLWNvbnRyb2xzJzokaWQsJ2RhdGEtaXMtZm9jdXMnOmZhbHNlLCdkYXRhLXlldGktYm94JzokaWQsJ2FyaWEtaGFzcG9wdXAnOnRydWUsJ2FyaWEtZXhwYW5kZWQnOmZhbHNlfSk7dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3M9dGhpcy5nZXRQb3NpdGlvbkNsYXNzKCk7dGhpcy5jb3VudGVyPTQ7dGhpcy51c2VkUG9zaXRpb25zPVtdO3RoaXMuJGVsZW1lbnQuYXR0cih7J2FyaWEtaGlkZGVuJzondHJ1ZScsJ2RhdGEteWV0aS1ib3gnOiRpZCwnZGF0YS1yZXNpemUnOiRpZCwnYXJpYS1sYWJlbGxlZGJ5Jzp0aGlzLiRhbmNob3JbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwnZGQtYW5jaG9yJyl9KTt0aGlzLl9ldmVudHMoKTt9LyoqXG4gICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGN1cnJlbnQgb3JpZW50YXRpb24gb2YgZHJvcGRvd24gcGFuZS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gcG9zaXRpb24gLSBzdHJpbmcgdmFsdWUgb2YgYSBwb3NpdGlvbiBjbGFzcy5cbiAgICAgICAqL30se2tleTonZ2V0UG9zaXRpb25DbGFzcycsdmFsdWU6ZnVuY3Rpb24gZ2V0UG9zaXRpb25DbGFzcygpe3ZhciB2ZXJ0aWNhbFBvc2l0aW9uPXRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tKS9nKTt2ZXJ0aWNhbFBvc2l0aW9uPXZlcnRpY2FsUG9zaXRpb24/dmVydGljYWxQb3NpdGlvblswXTonJzt2YXIgaG9yaXpvbnRhbFBvc2l0aW9uPS9mbG9hdC0oXFxTKylcXHMvLmV4ZWModGhpcy4kYW5jaG9yWzBdLmNsYXNzTmFtZSk7aG9yaXpvbnRhbFBvc2l0aW9uPWhvcml6b250YWxQb3NpdGlvbj9ob3Jpem9udGFsUG9zaXRpb25bMV06Jyc7dmFyIHBvc2l0aW9uPWhvcml6b250YWxQb3NpdGlvbj9ob3Jpem9udGFsUG9zaXRpb24rJyAnK3ZlcnRpY2FsUG9zaXRpb246dmVydGljYWxQb3NpdGlvbjtyZXR1cm4gcG9zaXRpb247fS8qKlxuICAgICAgICogQWRqdXN0cyB0aGUgZHJvcGRvd24gcGFuZXMgb3JpZW50YXRpb24gYnkgYWRkaW5nL3JlbW92aW5nIHBvc2l0aW9uaW5nIGNsYXNzZXMuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiBjbGFzcyB0byByZW1vdmUuXG4gICAgICAgKi99LHtrZXk6J19yZXBvc2l0aW9uJyx2YWx1ZTpmdW5jdGlvbiBfcmVwb3NpdGlvbihwb3NpdGlvbil7dGhpcy51c2VkUG9zaXRpb25zLnB1c2gocG9zaXRpb24/cG9zaXRpb246J2JvdHRvbScpOy8vZGVmYXVsdCwgdHJ5IHN3aXRjaGluZyB0byBvcHBvc2l0ZSBzaWRlXG5pZighcG9zaXRpb24mJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKTwwKXt0aGlzLiRlbGVtZW50LmFkZENsYXNzKCd0b3AnKTt9ZWxzZSBpZihwb3NpdGlvbj09PSd0b3AnJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJyk8MCl7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7fWVsc2UgaWYocG9zaXRpb249PT0nbGVmdCcmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdyaWdodCcpPDApe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pLmFkZENsYXNzKCdyaWdodCcpO31lbHNlIGlmKHBvc2l0aW9uPT09J3JpZ2h0JyYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKTwwKXt0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO30vL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcbmVsc2UgaWYoIXBvc2l0aW9uJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigndG9wJyk+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0Jyk8MCl7dGhpcy4kZWxlbWVudC5hZGRDbGFzcygnbGVmdCcpO31lbHNlIGlmKHBvc2l0aW9uPT09J3RvcCcmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKTwwKXt0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO31lbHNlIGlmKHBvc2l0aW9uPT09J2xlZnQnJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpPDApe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO31lbHNlIGlmKHBvc2l0aW9uPT09J3JpZ2h0JyYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpPDApe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO30vL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuZWxzZXt0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTt9dGhpcy5jbGFzc0NoYW5nZWQ9dHJ1ZTt0aGlzLmNvdW50ZXItLTt9LyoqXG4gICAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgdGhlIGRyb3Bkb3duIHBhbmUsIGNoZWNrcyBmb3IgY29sbGlzaW9ucy5cbiAgICAgICAqIFJlY3Vyc2l2ZWx5IGNhbGxzIGl0c2VsZiBpZiBhIGNvbGxpc2lvbiBpcyBkZXRlY3RlZCwgd2l0aCBhIG5ldyBwb3NpdGlvbiBjbGFzcy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX3NldFBvc2l0aW9uJyx2YWx1ZTpmdW5jdGlvbiBfc2V0UG9zaXRpb24oKXtpZih0aGlzLiRhbmNob3IuYXR0cignYXJpYS1leHBhbmRlZCcpPT09J2ZhbHNlJyl7cmV0dXJuIGZhbHNlO312YXIgcG9zaXRpb249dGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksJGVsZURpbXM9Rm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KSwkYW5jaG9yRGltcz1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGFuY2hvciksX3RoaXM9dGhpcyxkaXJlY3Rpb249cG9zaXRpb249PT0nbGVmdCc/J2xlZnQnOnBvc2l0aW9uPT09J3JpZ2h0Jz8nbGVmdCc6J3RvcCcscGFyYW09ZGlyZWN0aW9uPT09J3RvcCc/J2hlaWdodCc6J3dpZHRoJyxvZmZzZXQ9cGFyYW09PT0naGVpZ2h0Jz90aGlzLm9wdGlvbnMudk9mZnNldDp0aGlzLm9wdGlvbnMuaE9mZnNldDtpZigkZWxlRGltcy53aWR0aD49JGVsZURpbXMud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCkpe3RoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCx0aGlzLiRhbmNob3IsJ2NlbnRlciBib3R0b20nLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0LHRydWUpKS5jc3Moeyd3aWR0aCc6JGVsZURpbXMud2luZG93RGltcy53aWR0aC10aGlzLm9wdGlvbnMuaE9mZnNldCoyLCdoZWlnaHQnOidhdXRvJ30pO3RoaXMuY2xhc3NDaGFuZ2VkPXRydWU7cmV0dXJuIGZhbHNlO310aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsdGhpcy4kYW5jaG9yLHBvc2l0aW9uLHRoaXMub3B0aW9ucy52T2Zmc2V0LHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7d2hpbGUoIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy4kZWxlbWVudCxmYWxzZSx0cnVlKSYmdGhpcy5jb3VudGVyKXt0aGlzLl9yZXBvc2l0aW9uKHBvc2l0aW9uKTt0aGlzLl9zZXRQb3NpdGlvbigpO319LyoqXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZWxlbWVudCB1dGlsaXppbmcgdGhlIHRyaWdnZXJzIHV0aWxpdHkgbGlicmFyeS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpcz10aGlzO3RoaXMuJGVsZW1lbnQub24oeydvcGVuLnpmLnRyaWdnZXInOnRoaXMub3Blbi5iaW5kKHRoaXMpLCdjbG9zZS56Zi50cmlnZ2VyJzp0aGlzLmNsb3NlLmJpbmQodGhpcyksJ3RvZ2dsZS56Zi50cmlnZ2VyJzp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLCdyZXNpemVtZS56Zi50cmlnZ2VyJzp0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpfSk7aWYodGhpcy5vcHRpb25zLmhvdmVyKXt0aGlzLiRhbmNob3Iub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKS5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7X3RoaXMudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7X3RoaXMub3BlbigpO190aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLHRydWUpO30sX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTt9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7X3RoaXMudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7X3RoaXMuY2xvc2UoKTtfdGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJyxmYWxzZSk7fSxfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO30pO2lmKHRoaXMub3B0aW9ucy5ob3ZlclBhbmUpe3RoaXMuJGVsZW1lbnQub2ZmKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd24nKS5vbignbW91c2VlbnRlci56Zi5kcm9wZG93bicsZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7fSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd24nLGZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO190aGlzLnRpbWVvdXQ9c2V0VGltZW91dChmdW5jdGlvbigpe190aGlzLmNsb3NlKCk7X3RoaXMuJGFuY2hvci5kYXRhKCdob3ZlcicsZmFsc2UpO30sX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTt9KTt9fXRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oJ2tleWRvd24uemYuZHJvcGRvd24nLGZ1bmN0aW9uKGUpe3ZhciAkdGFyZ2V0PSQodGhpcyksdmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShfdGhpcy4kZWxlbWVudCk7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwnRHJvcGRvd24nLHt0YWJfZm9yd2FyZDpmdW5jdGlvbiB0YWJfZm9yd2FyZCgpe2lmKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgtMSkpKXsvLyBsZWZ0IG1vZGFsIGRvd253YXJkcywgc2V0dGluZyBmb2N1cyB0byBmaXJzdCBlbGVtZW50XG5pZihfdGhpcy5vcHRpb25zLnRyYXBGb2N1cyl7Ly8gaWYgZm9jdXMgc2hhbGwgYmUgdHJhcHBlZFxudmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCk7ZS5wcmV2ZW50RGVmYXVsdCgpO31lbHNley8vIGlmIGZvY3VzIGlzIG5vdCB0cmFwcGVkLCBjbG9zZSBkcm9wZG93biBvbiBmb2N1cyBvdXRcbl90aGlzLmNsb3NlKCk7fX19LHRhYl9iYWNrd2FyZDpmdW5jdGlvbiB0YWJfYmFja3dhcmQoKXtpZihfdGhpcy4kZWxlbWVudC5maW5kKCc6Zm9jdXMnKS5pcyh2aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpfHxfdGhpcy4kZWxlbWVudC5pcygnOmZvY3VzJykpey8vIGxlZnQgbW9kYWwgdXB3YXJkcywgc2V0dGluZyBmb2N1cyB0byBsYXN0IGVsZW1lbnRcbmlmKF90aGlzLm9wdGlvbnMudHJhcEZvY3VzKXsvLyBpZiBmb2N1cyBzaGFsbCBiZSB0cmFwcGVkXG52aXNpYmxlRm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpLmZvY3VzKCk7ZS5wcmV2ZW50RGVmYXVsdCgpO31lbHNley8vIGlmIGZvY3VzIGlzIG5vdCB0cmFwcGVkLCBjbG9zZSBkcm9wZG93biBvbiBmb2N1cyBvdXRcbl90aGlzLmNsb3NlKCk7fX19LG9wZW46ZnVuY3Rpb24gb3Blbigpe2lmKCR0YXJnZXQuaXMoX3RoaXMuJGFuY2hvcikpe190aGlzLm9wZW4oKTtfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsLTEpLmZvY3VzKCk7ZS5wcmV2ZW50RGVmYXVsdCgpO319LGNsb3NlOmZ1bmN0aW9uIGNsb3NlKCl7X3RoaXMuY2xvc2UoKTtfdGhpcy4kYW5jaG9yLmZvY3VzKCk7fX0pO30pO30vKipcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19hZGRCb2R5SGFuZGxlcicsdmFsdWU6ZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCl7dmFyICRib2R5PSQoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLF90aGlzPXRoaXM7JGJvZHkub2ZmKCdjbGljay56Zi5kcm9wZG93bicpLm9uKCdjbGljay56Zi5kcm9wZG93bicsZnVuY3Rpb24oZSl7aWYoX3RoaXMuJGFuY2hvci5pcyhlLnRhcmdldCl8fF90aGlzLiRhbmNob3IuZmluZChlLnRhcmdldCkubGVuZ3RoKXtyZXR1cm47fWlmKF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCl7cmV0dXJuO31fdGhpcy5jbG9zZSgpOyRib2R5Lm9mZignY2xpY2suemYuZHJvcGRvd24nKTt9KTt9LyoqXG4gICAgICAgKiBPcGVucyB0aGUgZHJvcGRvd24gcGFuZSwgYW5kIGZpcmVzIGEgYnViYmxpbmcgZXZlbnQgdG8gY2xvc2Ugb3RoZXIgZHJvcGRvd25zLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZmlyZXMgRHJvcGRvd24jY2xvc2VtZVxuICAgICAgICogQGZpcmVzIERyb3Bkb3duI3Nob3dcbiAgICAgICAqL30se2tleTonb3BlbicsdmFsdWU6ZnVuY3Rpb24gb3Blbigpey8vIHZhciBfdGhpcyA9IHRoaXM7XG4vKipcbiAgICAgICAgICogRmlyZXMgdG8gY2xvc2Ugb3RoZXIgb3BlbiBkcm9wZG93bnNcbiAgICAgICAgICogQGV2ZW50IERyb3Bkb3duI2Nsb3NlbWVcbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLmRyb3Bkb3duJyx0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO3RoaXMuJGFuY2hvci5hZGRDbGFzcygnaG92ZXInKS5hdHRyKHsnYXJpYS1leHBhbmRlZCc6dHJ1ZX0pOy8vIHRoaXMuJGVsZW1lbnQvKi5zaG93KCkqLztcbnRoaXMuX3NldFBvc2l0aW9uKCk7dGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbicpLmF0dHIoeydhcmlhLWhpZGRlbic6ZmFsc2V9KTtpZih0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKXt2YXIgJGZvY3VzYWJsZT1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7aWYoJGZvY3VzYWJsZS5sZW5ndGgpeyRmb2N1c2FibGUuZXEoMCkuZm9jdXMoKTt9fWlmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe3RoaXMuX2FkZEJvZHlIYW5kbGVyKCk7fS8qKlxuICAgICAgICAgKiBGaXJlcyBvbmNlIHRoZSBkcm9wZG93biBpcyB2aXNpYmxlLlxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd24jc2hvd1xuICAgICAgICAgKi90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd24nLFt0aGlzLiRlbGVtZW50XSk7fS8qKlxuICAgICAgICogQ2xvc2VzIHRoZSBvcGVuIGRyb3Bkb3duIHBhbmUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBEcm9wZG93biNoaWRlXG4gICAgICAgKi99LHtrZXk6J2Nsb3NlJyx2YWx1ZTpmdW5jdGlvbiBjbG9zZSgpe2lmKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykpe3JldHVybiBmYWxzZTt9dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtb3BlbicpLmF0dHIoeydhcmlhLWhpZGRlbic6dHJ1ZX0pO3RoaXMuJGFuY2hvci5yZW1vdmVDbGFzcygnaG92ZXInKS5hdHRyKCdhcmlhLWV4cGFuZGVkJyxmYWxzZSk7aWYodGhpcy5jbGFzc0NoYW5nZWQpe3ZhciBjdXJQb3NpdGlvbkNsYXNzPXRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO2lmKGN1clBvc2l0aW9uQ2xhc3Mpe3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoY3VyUG9zaXRpb25DbGFzcyk7fXRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpLyouaGlkZSgpKi8uY3NzKHtoZWlnaHQ6Jycsd2lkdGg6Jyd9KTt0aGlzLmNsYXNzQ2hhbmdlZD1mYWxzZTt0aGlzLmNvdW50ZXI9NDt0aGlzLnVzZWRQb3NpdGlvbnMubGVuZ3RoPTA7fXRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi5kcm9wZG93bicsW3RoaXMuJGVsZW1lbnRdKTt9LyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSBkcm9wZG93biBwYW5lJ3MgdmlzaWJpbGl0eS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5Oid0b2dnbGUnLHZhbHVlOmZ1bmN0aW9uIHRvZ2dsZSgpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSl7aWYodGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJykpcmV0dXJuO3RoaXMuY2xvc2UoKTt9ZWxzZXt0aGlzLm9wZW4oKTt9fS8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIGRyb3Bkb3duLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J2Rlc3Ryb3knLHZhbHVlOmZ1bmN0aW9uIGRlc3Ryb3koKXt0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXInKS5oaWRlKCk7dGhpcy4kYW5jaG9yLm9mZignLnpmLmRyb3Bkb3duJyk7Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSk7cmV0dXJuIERyb3Bkb3duO30oKTtEcm9wZG93bi5kZWZhdWx0cz17LyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgb3BlbmluZyBhIHN1Ym1lbnUgb24gaG92ZXIgZXZlbnQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDI1MFxuICAgICAqL2hvdmVyRGVsYXk6MjUwLC8qKlxuICAgICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovaG92ZXI6ZmFsc2UsLyoqXG4gICAgICogRG9uJ3QgY2xvc2UgZHJvcGRvd24gd2hlbiBob3ZlcmluZyBvdmVyIGRyb3Bkb3duIHBhbmVcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2hvdmVyUGFuZTpmYWxzZSwvKipcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMVxuICAgICAqL3ZPZmZzZXQ6MSwvKipcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMVxuICAgICAqL2hPZmZzZXQ6MSwvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIGFkanVzdCBvcGVuIHBvc2l0aW9uLiBKUyB3aWxsIHRlc3QgYW5kIGZpbGwgdGhpcyBpbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3RvcCdcbiAgICAgKi9wb3NpdGlvbkNsYXNzOicnLC8qKlxuICAgICAqIEFsbG93IHRoZSBwbHVnaW4gdG8gdHJhcCBmb2N1cyB0byB0aGUgZHJvcGRvd24gcGFuZSBpZiBvcGVuZWQgd2l0aCBrZXlib2FyZCBjb21tYW5kcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi90cmFwRm9jdXM6ZmFsc2UsLyoqXG4gICAgICogQWxsb3cgdGhlIHBsdWdpbiB0byBzZXQgZm9jdXMgdG8gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgcGFuZSwgcmVnYXJkbGVzcyBvZiBtZXRob2Qgb2Ygb3BlbmluZy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2F1dG9Gb2N1czpmYWxzZSwvKipcbiAgICAgKiBBbGxvd3MgYSBjbGljayBvbiB0aGUgYm9keSB0byBjbG9zZSB0aGUgZHJvcGRvd24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovY2xvc2VPbkNsaWNrOmZhbHNlfTsvLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oRHJvcGRvd24sJ0Ryb3Bkb3duJyk7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fTt9KCk7IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBEcm9wZG93bk1lbnUgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd24tbWVudVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxuICAgKi92YXIgRHJvcGRvd25NZW51PWZ1bmN0aW9uKCl7LyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBEcm9wZG93bk1lbnUuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIERyb3Bkb3duTWVudSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIERyb3Bkb3duTWVudShlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLERyb3Bkb3duTWVudSk7dGhpcy4kZWxlbWVudD1lbGVtZW50O3RoaXMub3B0aW9ucz0kLmV4dGVuZCh7fSxEcm9wZG93bk1lbnUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7Rm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwnZHJvcGRvd24nKTt0aGlzLl9pbml0KCk7Rm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCdEcm9wZG93bk1lbnUnKTtGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bk1lbnUnLHsnRU5URVInOidvcGVuJywnU1BBQ0UnOidvcGVuJywnQVJST1dfUklHSFQnOiduZXh0JywnQVJST1dfVVAnOid1cCcsJ0FSUk9XX0RPV04nOidkb3duJywnQVJST1dfTEVGVCc6J3ByZXZpb3VzJywnRVNDQVBFJzonY2xvc2UnfSk7fS8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4sIGFuZCBjYWxscyBfcHJlcGFyZU1lbnVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqL19jcmVhdGVDbGFzcyhEcm9wZG93bk1lbnUsW3trZXk6J19pbml0Jyx2YWx1ZTpmdW5jdGlvbiBfaW5pdCgpe3ZhciBzdWJzPXRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTt0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKS5hZGRDbGFzcygnZmlyc3Qtc3ViJyk7dGhpcy4kbWVudUl0ZW1zPXRoaXMuJGVsZW1lbnQuZmluZCgnW3JvbGU9XCJtZW51aXRlbVwiXScpO3RoaXMuJHRhYnM9dGhpcy4kZWxlbWVudC5jaGlsZHJlbignW3JvbGU9XCJtZW51aXRlbVwiXScpO3RoaXMuJHRhYnMuZmluZCgndWwuaXMtZHJvcGRvd24tc3VibWVudScpLmFkZENsYXNzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbENsYXNzKTtpZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5yaWdodENsYXNzKXx8dGhpcy5vcHRpb25zLmFsaWdubWVudD09PSdyaWdodCd8fEZvdW5kYXRpb24ucnRsKCl8fHRoaXMuJGVsZW1lbnQucGFyZW50cygnLnRvcC1iYXItcmlnaHQnKS5pcygnKicpKXt0aGlzLm9wdGlvbnMuYWxpZ25tZW50PSdyaWdodCc7c3Vicy5hZGRDbGFzcygnb3BlbnMtbGVmdCcpO31lbHNle3N1YnMuYWRkQ2xhc3MoJ29wZW5zLXJpZ2h0Jyk7fXRoaXMuY2hhbmdlZD1mYWxzZTt0aGlzLl9ldmVudHMoKTt9fSx7a2V5OidfZXZlbnRzJywvKipcbiAgICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpcz10aGlzLGhhc1RvdWNoPSdvbnRvdWNoc3RhcnQnaW4gd2luZG93fHx0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCE9PSd1bmRlZmluZWQnLHBhckNsYXNzPSdpcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCc7Ly8gdXNlZCBmb3Igb25DbGljayBhbmQgaW4gdGhlIGtleWJvYXJkIGhhbmRsZXJzXG52YXIgaGFuZGxlQ2xpY2tGbj1mdW5jdGlvbiBoYW5kbGVDbGlja0ZuKGUpe3ZhciAkZWxlbT0kKGUudGFyZ2V0KS5wYXJlbnRzVW50aWwoJ3VsJywnLicrcGFyQ2xhc3MpLGhhc1N1Yj0kZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyksaGFzQ2xpY2tlZD0kZWxlbS5hdHRyKCdkYXRhLWlzLWNsaWNrJyk9PT0ndHJ1ZScsJHN1Yj0kZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtpZihoYXNTdWIpe2lmKGhhc0NsaWNrZWQpe2lmKCFfdGhpcy5vcHRpb25zLmNsb3NlT25DbGlja3x8IV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuJiYhaGFzVG91Y2h8fF90aGlzLm9wdGlvbnMuZm9yY2VGb2xsb3cmJmhhc1RvdWNoKXtyZXR1cm47fWVsc2V7ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtlLnByZXZlbnREZWZhdWx0KCk7X3RoaXMuX2hpZGUoJGVsZW0pO319ZWxzZXtlLnByZXZlbnREZWZhdWx0KCk7ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtfdGhpcy5fc2hvdygkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKSk7JGVsZW0uYWRkKCRlbGVtLnBhcmVudHNVbnRpbChfdGhpcy4kZWxlbWVudCwnLicrcGFyQ2xhc3MpKS5hdHRyKCdkYXRhLWlzLWNsaWNrJyx0cnVlKTt9fWVsc2V7cmV0dXJuO319O2lmKHRoaXMub3B0aW9ucy5jbGlja09wZW58fGhhc1RvdWNoKXt0aGlzLiRtZW51SXRlbXMub24oJ2NsaWNrLnpmLmRyb3Bkb3dubWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3dubWVudScsaGFuZGxlQ2xpY2tGbik7fWlmKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyKXt0aGlzLiRtZW51SXRlbXMub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51JyxmdW5jdGlvbihlKXt2YXIgJGVsZW09JCh0aGlzKSxoYXNTdWI9JGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO2lmKGhhc1N1Yil7Y2xlYXJUaW1lb3V0KF90aGlzLmRlbGF5KTtfdGhpcy5kZWxheT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7X3RoaXMuX3Nob3coJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykpO30sX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTt9fSkub24oJ21vdXNlbGVhdmUuemYuZHJvcGRvd25tZW51JyxmdW5jdGlvbihlKXt2YXIgJGVsZW09JCh0aGlzKSxoYXNTdWI9JGVsZW0uaGFzQ2xhc3MocGFyQ2xhc3MpO2lmKGhhc1N1YiYmX3RoaXMub3B0aW9ucy5hdXRvY2xvc2Upe2lmKCRlbGVtLmF0dHIoJ2RhdGEtaXMtY2xpY2snKT09PSd0cnVlJyYmX3RoaXMub3B0aW9ucy5jbGlja09wZW4pe3JldHVybiBmYWxzZTt9Y2xlYXJUaW1lb3V0KF90aGlzLmRlbGF5KTtfdGhpcy5kZWxheT1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7X3RoaXMuX2hpZGUoJGVsZW0pO30sX3RoaXMub3B0aW9ucy5jbG9zaW5nVGltZSk7fX0pO310aGlzLiRtZW51SXRlbXMub24oJ2tleWRvd24uemYuZHJvcGRvd25tZW51JyxmdW5jdGlvbihlKXt2YXIgJGVsZW1lbnQ9JChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsJ1tyb2xlPVwibWVudWl0ZW1cIl0nKSxpc1RhYj1fdGhpcy4kdGFicy5pbmRleCgkZWxlbWVudCk+LTEsJGVsZW1lbnRzPWlzVGFiP190aGlzLiR0YWJzOiRlbGVtZW50LnNpYmxpbmdzKCdsaScpLmFkZCgkZWxlbWVudCksJHByZXZFbGVtZW50LCRuZXh0RWxlbWVudDskZWxlbWVudHMuZWFjaChmdW5jdGlvbihpKXtpZigkKHRoaXMpLmlzKCRlbGVtZW50KSl7JHByZXZFbGVtZW50PSRlbGVtZW50cy5lcShpLTEpOyRuZXh0RWxlbWVudD0kZWxlbWVudHMuZXEoaSsxKTtyZXR1cm47fX0pO3ZhciBuZXh0U2libGluZz1mdW5jdGlvbiBuZXh0U2libGluZygpe2lmKCEkZWxlbWVudC5pcygnOmxhc3QtY2hpbGQnKSl7JG5leHRFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtlLnByZXZlbnREZWZhdWx0KCk7fX0scHJldlNpYmxpbmc9ZnVuY3Rpb24gcHJldlNpYmxpbmcoKXskcHJldkVsZW1lbnQuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO2UucHJldmVudERlZmF1bHQoKTt9LG9wZW5TdWI9ZnVuY3Rpb24gb3BlblN1Yigpe3ZhciAkc3ViPSRlbGVtZW50LmNoaWxkcmVuKCd1bC5pcy1kcm9wZG93bi1zdWJtZW51Jyk7aWYoJHN1Yi5sZW5ndGgpe190aGlzLl9zaG93KCRzdWIpOyRlbGVtZW50LmZpbmQoJ2xpID4gYTpmaXJzdCcpLmZvY3VzKCk7ZS5wcmV2ZW50RGVmYXVsdCgpO31lbHNle3JldHVybjt9fSxjbG9zZVN1Yj1mdW5jdGlvbiBjbG9zZVN1Yigpey8vaWYgKCRlbGVtZW50LmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xudmFyIGNsb3NlPSRlbGVtZW50LnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJyk7Y2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO190aGlzLl9oaWRlKGNsb3NlKTtlLnByZXZlbnREZWZhdWx0KCk7Ly99XG59O3ZhciBmdW5jdGlvbnM9e29wZW46b3BlblN1YixjbG9zZTpmdW5jdGlvbiBjbG9zZSgpe190aGlzLl9oaWRlKF90aGlzLiRlbGVtZW50KTtfdGhpcy4kbWVudUl0ZW1zLmZpbmQoJ2E6Zmlyc3QnKS5mb2N1cygpOy8vIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcbmUucHJldmVudERlZmF1bHQoKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7fX07aWYoaXNUYWIpe2lmKF90aGlzLiRlbGVtZW50Lmhhc0NsYXNzKF90aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcykpey8vIHZlcnRpY2FsIG1lbnVcbmlmKF90aGlzLm9wdGlvbnMuYWxpZ25tZW50PT09J2xlZnQnKXsvLyBsZWZ0IGFsaWduZWRcbiQuZXh0ZW5kKGZ1bmN0aW9ucyx7ZG93bjpuZXh0U2libGluZyx1cDpwcmV2U2libGluZyxuZXh0Om9wZW5TdWIscHJldmlvdXM6Y2xvc2VTdWJ9KTt9ZWxzZXsvLyByaWdodCBhbGlnbmVkXG4kLmV4dGVuZChmdW5jdGlvbnMse2Rvd246bmV4dFNpYmxpbmcsdXA6cHJldlNpYmxpbmcsbmV4dDpjbG9zZVN1YixwcmV2aW91czpvcGVuU3VifSk7fX1lbHNley8vIGhvcml6b250YWwgbWVudVxuJC5leHRlbmQoZnVuY3Rpb25zLHtuZXh0Om5leHRTaWJsaW5nLHByZXZpb3VzOnByZXZTaWJsaW5nLGRvd246b3BlblN1Yix1cDpjbG9zZVN1Yn0pO319ZWxzZXsvLyBub3QgdGFicyAtPiBvbmUgc3ViXG5pZihfdGhpcy5vcHRpb25zLmFsaWdubWVudD09PSdsZWZ0Jyl7Ly8gbGVmdCBhbGlnbmVkXG4kLmV4dGVuZChmdW5jdGlvbnMse25leHQ6b3BlblN1YixwcmV2aW91czpjbG9zZVN1Yixkb3duOm5leHRTaWJsaW5nLHVwOnByZXZTaWJsaW5nfSk7fWVsc2V7Ly8gcmlnaHQgYWxpZ25lZFxuJC5leHRlbmQoZnVuY3Rpb25zLHtuZXh0OmNsb3NlU3ViLHByZXZpb3VzOm9wZW5TdWIsZG93bjpuZXh0U2libGluZyx1cDpwcmV2U2libGluZ30pO319Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwnRHJvcGRvd25NZW51JyxmdW5jdGlvbnMpO30pO30vKipcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19hZGRCb2R5SGFuZGxlcicsdmFsdWU6ZnVuY3Rpb24gX2FkZEJvZHlIYW5kbGVyKCl7dmFyICRib2R5PSQoZG9jdW1lbnQuYm9keSksX3RoaXM9dGhpczskYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpLm9uKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnLGZ1bmN0aW9uKGUpe3ZhciAkbGluaz1fdGhpcy4kZWxlbWVudC5maW5kKGUudGFyZ2V0KTtpZigkbGluay5sZW5ndGgpe3JldHVybjt9X3RoaXMuX2hpZGUoKTskYm9keS5vZmYoJ21vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudScpO30pO30vKipcbiAgICAgICAqIE9wZW5zIGEgZHJvcGRvd24gcGFuZSwgYW5kIGNoZWNrcyBmb3IgY29sbGlzaW9ucyBmaXJzdC5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkc3ViIC0gdWwgZWxlbWVudCB0aGF0IGlzIGEgc3VibWVudSB0byBzaG93XG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAZmlyZXMgRHJvcGRvd25NZW51I3Nob3dcbiAgICAgICAqL30se2tleTonX3Nob3cnLHZhbHVlOmZ1bmN0aW9uIF9zaG93KCRzdWIpe3ZhciBpZHg9dGhpcy4kdGFicy5pbmRleCh0aGlzLiR0YWJzLmZpbHRlcihmdW5jdGlvbihpLGVsKXtyZXR1cm4gJChlbCkuZmluZCgkc3ViKS5sZW5ndGg+MDt9KSk7dmFyICRzaWJzPSRzdWIucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLnNpYmxpbmdzKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO3RoaXMuX2hpZGUoJHNpYnMsaWR4KTskc3ViLmNzcygndmlzaWJpbGl0eScsJ2hpZGRlbicpLmFkZENsYXNzKCdqcy1kcm9wZG93bi1hY3RpdmUnKS5hdHRyKHsnYXJpYS1oaWRkZW4nOmZhbHNlfSkucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsnYXJpYS1leHBhbmRlZCc6dHJ1ZX0pO3ZhciBjbGVhcj1Gb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KCRzdWIsbnVsbCx0cnVlKTtpZighY2xlYXIpe3ZhciBvbGRDbGFzcz10aGlzLm9wdGlvbnMuYWxpZ25tZW50PT09J2xlZnQnPyctcmlnaHQnOictbGVmdCcsJHBhcmVudExpPSRzdWIucGFyZW50KCcuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKTskcGFyZW50TGkucmVtb3ZlQ2xhc3MoJ29wZW5zJytvbGRDbGFzcykuYWRkQ2xhc3MoJ29wZW5zLScrdGhpcy5vcHRpb25zLmFsaWdubWVudCk7Y2xlYXI9Rm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLG51bGwsdHJ1ZSk7aWYoIWNsZWFyKXskcGFyZW50TGkucmVtb3ZlQ2xhc3MoJ29wZW5zLScrdGhpcy5vcHRpb25zLmFsaWdubWVudCkuYWRkQ2xhc3MoJ29wZW5zLWlubmVyJyk7fXRoaXMuY2hhbmdlZD10cnVlO30kc3ViLmNzcygndmlzaWJpbGl0eScsJycpO2lmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe3RoaXMuX2FkZEJvZHlIYW5kbGVyKCk7fS8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I3Nob3dcbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLmRyb3Bkb3dubWVudScsWyRzdWJdKTt9LyoqXG4gICAgICAgKiBIaWRlcyBhIHNpbmdsZSwgY3VycmVudGx5IG9wZW4gZHJvcGRvd24gcGFuZSwgaWYgcGFzc2VkIGEgcGFyYW1ldGVyLCBvdGhlcndpc2UsIGhpZGVzIGV2ZXJ5dGhpbmcuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIGVsZW1lbnQgd2l0aCBhIHN1Ym1lbnUgdG8gaGlkZVxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSAkdGFicyBjb2xsZWN0aW9uIHRvIGhpZGVcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19oaWRlJyx2YWx1ZTpmdW5jdGlvbiBfaGlkZSgkZWxlbSxpZHgpe3ZhciAkdG9DbG9zZTtpZigkZWxlbSYmJGVsZW0ubGVuZ3RoKXskdG9DbG9zZT0kZWxlbTt9ZWxzZSBpZihpZHghPT11bmRlZmluZWQpeyR0b0Nsb3NlPXRoaXMuJHRhYnMubm90KGZ1bmN0aW9uKGksZWwpe3JldHVybiBpPT09aWR4O30pO31lbHNleyR0b0Nsb3NlPXRoaXMuJGVsZW1lbnQ7fXZhciBzb21ldGhpbmdUb0Nsb3NlPSR0b0Nsb3NlLmhhc0NsYXNzKCdpcy1hY3RpdmUnKXx8JHRvQ2xvc2UuZmluZCgnLmlzLWFjdGl2ZScpLmxlbmd0aD4wO2lmKHNvbWV0aGluZ1RvQ2xvc2UpeyR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWFjdGl2ZScpLmFkZCgkdG9DbG9zZSkuYXR0cih7J2FyaWEtZXhwYW5kZWQnOmZhbHNlLCdkYXRhLWlzLWNsaWNrJzpmYWxzZX0pLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTskdG9DbG9zZS5maW5kKCd1bC5qcy1kcm9wZG93bi1hY3RpdmUnKS5hdHRyKHsnYXJpYS1oaWRkZW4nOnRydWV9KS5yZW1vdmVDbGFzcygnanMtZHJvcGRvd24tYWN0aXZlJyk7aWYodGhpcy5jaGFuZ2VkfHwkdG9DbG9zZS5maW5kKCdvcGVucy1pbm5lcicpLmxlbmd0aCl7dmFyIG9sZENsYXNzPXRoaXMub3B0aW9ucy5hbGlnbm1lbnQ9PT0nbGVmdCc/J3JpZ2h0JzonbGVmdCc7JHRvQ2xvc2UuZmluZCgnbGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnKS5hZGQoJHRvQ2xvc2UpLnJlbW92ZUNsYXNzKCdvcGVucy1pbm5lciBvcGVucy0nK3RoaXMub3B0aW9ucy5hbGlnbm1lbnQpLmFkZENsYXNzKCdvcGVucy0nK29sZENsYXNzKTt0aGlzLmNoYW5nZWQ9ZmFsc2U7fS8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9wZW4gbWVudXMgYXJlIGNsb3NlZC5cbiAgICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd25NZW51I2hpZGVcbiAgICAgICAgICAgKi90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUuemYuZHJvcGRvd25tZW51JyxbJHRvQ2xvc2VdKTt9fS8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIHBsdWdpbi5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dGhpcy4kbWVudUl0ZW1zLm9mZignLnpmLmRyb3Bkb3dubWVudScpLnJlbW92ZUF0dHIoJ2RhdGEtaXMtY2xpY2snKS5yZW1vdmVDbGFzcygnaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXInKTskKGRvY3VtZW50LmJvZHkpLm9mZignLnpmLmRyb3Bkb3dubWVudScpO0ZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsJ2Ryb3Bkb3duJyk7Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSk7cmV0dXJuIERyb3Bkb3duTWVudTt9KCk7LyoqXG4gICAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxuICAgKi9Ecm9wZG93bk1lbnUuZGVmYXVsdHM9ey8qKlxuICAgICAqIERpc2FsbG93cyBob3ZlciBldmVudHMgZnJvbSBvcGVuaW5nIHN1Ym1lbnVzXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovZGlzYWJsZUhvdmVyOmZhbHNlLC8qKlxuICAgICAqIEFsbG93IGEgc3VibWVudSB0byBhdXRvbWF0aWNhbGx5IGNsb3NlIG9uIGEgbW91c2VsZWF2ZSBldmVudCwgaWYgbm90IGNsaWNrZWQgb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2F1dG9jbG9zZTp0cnVlLC8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IG9wZW5pbmcgYSBzdWJtZW51IG9uIGhvdmVyIGV2ZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSA1MFxuICAgICAqL2hvdmVyRGVsYXk6NTAsLyoqXG4gICAgICogQWxsb3cgYSBzdWJtZW51IHRvIG9wZW4vcmVtYWluIG9wZW4gb24gcGFyZW50IGNsaWNrIGV2ZW50LiBBbGxvd3MgY3Vyc29yIHRvIG1vdmUgYXdheSBmcm9tIG1lbnUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9jbGlja09wZW46ZmFsc2UsLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgY2xvc2luZyBhIHN1Ym1lbnUgb24gYSBtb3VzZWxlYXZlIGV2ZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSA1MDBcbiAgICAgKi9jbG9zaW5nVGltZTo1MDAsLyoqXG4gICAgICogUG9zaXRpb24gb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gd2hhdCBkaXJlY3Rpb24gdGhlIHN1Ym1lbnVzIHNob3VsZCBvcGVuLiBIYW5kbGVkIGJ5IEpTLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnbGVmdCdcbiAgICAgKi9hbGlnbm1lbnQ6J2xlZnQnLC8qKlxuICAgICAqIEFsbG93IGNsaWNrcyBvbiB0aGUgYm9keSB0byBjbG9zZSBhbnkgb3BlbiBzdWJtZW51cy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2Nsb3NlT25DbGljazp0cnVlLC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdmVydGljYWwgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgdmVydGljYWxgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3ZlcnRpY2FsJ1xuICAgICAqL3ZlcnRpY2FsQ2xhc3M6J3ZlcnRpY2FsJywvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHJpZ2h0LXNpZGUgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgYWxpZ24tcmlnaHRgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2FsaWduLXJpZ2h0J1xuICAgICAqL3JpZ2h0Q2xhc3M6J2FsaWduLXJpZ2h0JywvKipcbiAgICAgKiBCb29sZWFuIHRvIGZvcmNlIG92ZXJpZGUgdGhlIGNsaWNraW5nIG9mIGxpbmtzIHRvIHBlcmZvcm0gZGVmYXVsdCBhY3Rpb24sIG9uIHNlY29uZCB0b3VjaCBldmVudCBmb3IgbW9iaWxlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL2ZvcmNlRm9sbG93OnRydWV9Oy8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihEcm9wZG93bk1lbnUsJ0Ryb3Bkb3duTWVudScpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogRXF1YWxpemVyIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLmVxdWFsaXplclxuICAgKi92YXIgRXF1YWxpemVyPWZ1bmN0aW9uKCl7LyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIEVxdWFsaXplciNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovZnVuY3Rpb24gRXF1YWxpemVyKGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsRXF1YWxpemVyKTt0aGlzLiRlbGVtZW50PWVsZW1lbnQ7dGhpcy5vcHRpb25zPSQuZXh0ZW5kKHt9LEVxdWFsaXplci5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxvcHRpb25zKTt0aGlzLl9pbml0KCk7Rm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCdFcXVhbGl6ZXInKTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEVxdWFsaXplciBwbHVnaW4gYW5kIGNhbGxzIGZ1bmN0aW9ucyB0byBnZXQgZXF1YWxpemVyIGZ1bmN0aW9uaW5nIG9uIGxvYWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoRXF1YWxpemVyLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt2YXIgZXFJZD10aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtZXF1YWxpemVyJyl8fCcnO3ZhciAkd2F0Y2hlZD10aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplci13YXRjaD1cIicrZXFJZCsnXCJdJyk7dGhpcy4kd2F0Y2hlZD0kd2F0Y2hlZC5sZW5ndGg/JHdhdGNoZWQ6dGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdJyk7dGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLXJlc2l6ZScsZXFJZHx8Rm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCdlcScpKTt0aGlzLmhhc05lc3RlZD10aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGg+MDt0aGlzLmlzTmVzdGVkPXRoaXMuJGVsZW1lbnQucGFyZW50c1VudGlsKGRvY3VtZW50LmJvZHksJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGg+MDt0aGlzLmlzT249ZmFsc2U7dGhpcy5fYmluZEhhbmRsZXI9e29uUmVzaXplTWVCb3VuZDp0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksb25Qb3N0RXF1YWxpemVkQm91bmQ6dGhpcy5fb25Qb3N0RXF1YWxpemVkLmJpbmQodGhpcyl9O3ZhciBpbWdzPXRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyk7dmFyIHRvb1NtYWxsO2lmKHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKXt0b29TbWFsbD10aGlzLl9jaGVja01RKCk7JCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLHRoaXMuX2NoZWNrTVEuYmluZCh0aGlzKSk7fWVsc2V7dGhpcy5fZXZlbnRzKCk7fWlmKHRvb1NtYWxsIT09dW5kZWZpbmVkJiZ0b29TbWFsbD09PWZhbHNlfHx0b29TbWFsbD09PXVuZGVmaW5lZCl7aWYoaW1ncy5sZW5ndGgpe0ZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoaW1ncyx0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSk7fWVsc2V7dGhpcy5fcmVmbG93KCk7fX19LyoqXG4gICAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBpZiB0aGUgYnJlYWtwb2ludCBpcyB0b28gc21hbGwuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfcGF1c2VFdmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9wYXVzZUV2ZW50cygpe3RoaXMuaXNPbj1mYWxzZTt0aGlzLiRlbGVtZW50Lm9mZih7Jy56Zi5lcXVhbGl6ZXInOnRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLCdyZXNpemVtZS56Zi50cmlnZ2VyJzp0aGlzLl9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmR9KTt9LyoqXG4gICAgICAgKiBmdW5jdGlvbiB0byBoYW5kbGUgJGVsZW1lbnRzIHJlc2l6ZW1lLnpmLnRyaWdnZXIsIHdpdGggYm91bmQgdGhpcyBvbiBfYmluZEhhbmRsZXIub25SZXNpemVNZUJvdW5kXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5Oidfb25SZXNpemVNZScsdmFsdWU6ZnVuY3Rpb24gX29uUmVzaXplTWUoZSl7dGhpcy5fcmVmbG93KCk7fS8qKlxuICAgICAgICogZnVuY3Rpb24gdG8gaGFuZGxlICRlbGVtZW50cyBwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZFxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX29uUG9zdEVxdWFsaXplZCcsdmFsdWU6ZnVuY3Rpb24gX29uUG9zdEVxdWFsaXplZChlKXtpZihlLnRhcmdldCE9PXRoaXMuJGVsZW1lbnRbMF0pe3RoaXMuX3JlZmxvdygpO319LyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEVxdWFsaXplci5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19ldmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9ldmVudHMoKXt2YXIgX3RoaXM9dGhpczt0aGlzLl9wYXVzZUV2ZW50cygpO2lmKHRoaXMuaGFzTmVzdGVkKXt0aGlzLiRlbGVtZW50Lm9uKCdwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplcicsdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpO31lbHNle3RoaXMuJGVsZW1lbnQub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCk7fXRoaXMuaXNPbj10cnVlO30vKipcbiAgICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBicmVha3BvaW50IHRvIHRoZSBtaW5pbXVtIHJlcXVpcmVkIHNpemUuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfY2hlY2tNUScsdmFsdWU6ZnVuY3Rpb24gX2NoZWNrTVEoKXt2YXIgdG9vU21hbGw9IUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKTtpZih0b29TbWFsbCl7aWYodGhpcy5pc09uKXt0aGlzLl9wYXVzZUV2ZW50cygpO3RoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCdhdXRvJyk7fX1lbHNle2lmKCF0aGlzLmlzT24pe3RoaXMuX2V2ZW50cygpO319cmV0dXJuIHRvb1NtYWxsO30vKipcbiAgICAgICAqIEEgbm9vcCB2ZXJzaW9uIGZvciB0aGUgcGx1Z2luXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5Oidfa2lsbHN3aXRjaCcsdmFsdWU6ZnVuY3Rpb24gX2tpbGxzd2l0Y2goKXtyZXR1cm47fS8qKlxuICAgICAgICogQ2FsbHMgbmVjZXNzYXJ5IGZ1bmN0aW9ucyB0byB1cGRhdGUgRXF1YWxpemVyIHVwb24gRE9NIGNoYW5nZVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX3JlZmxvdycsdmFsdWU6ZnVuY3Rpb24gX3JlZmxvdygpe2lmKCF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrKXtpZih0aGlzLl9pc1N0YWNrZWQoKSl7dGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsJ2F1dG8nKTtyZXR1cm4gZmFsc2U7fX1pZih0aGlzLm9wdGlvbnMuZXF1YWxpemVCeVJvdyl7dGhpcy5nZXRIZWlnaHRzQnlSb3codGhpcy5hcHBseUhlaWdodEJ5Um93LmJpbmQodGhpcykpO31lbHNle3RoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpO319LyoqXG4gICAgICAgKiBNYW51YWxseSBkZXRlcm1pbmVzIGlmIHRoZSBmaXJzdCAyIGVsZW1lbnRzIGFyZSAqTk9UKiBzdGFja2VkLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2lzU3RhY2tlZCcsdmFsdWU6ZnVuY3Rpb24gX2lzU3RhY2tlZCgpe3JldHVybiB0aGlzLiR3YXRjaGVkWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCE9PXRoaXMuJHdhdGNoZWRbMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO30vKipcbiAgICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICAgICAqL30se2tleTonZ2V0SGVpZ2h0cycsdmFsdWU6ZnVuY3Rpb24gZ2V0SGVpZ2h0cyhjYil7dmFyIGhlaWdodHM9W107Zm9yKHZhciBpPTAsbGVuPXRoaXMuJHdhdGNoZWQubGVuZ3RoO2k8bGVuO2krKyl7dGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQ9J2F1dG8nO2hlaWdodHMucHVzaCh0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodCk7fWNiKGhlaWdodHMpO30vKipcbiAgICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIEEgbm9uLW9wdGlvbmFsIGNhbGxiYWNrIHRvIHJldHVybiB0aGUgaGVpZ2h0cyBhcnJheSB0by5cbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxuICAgICAgICovfSx7a2V5OidnZXRIZWlnaHRzQnlSb3cnLHZhbHVlOmZ1bmN0aW9uIGdldEhlaWdodHNCeVJvdyhjYil7dmFyIGxhc3RFbFRvcE9mZnNldD10aGlzLiR3YXRjaGVkLmxlbmd0aD90aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wOjAsZ3JvdXBzPVtdLGdyb3VwPTA7Ly9ncm91cCBieSBSb3dcbmdyb3Vwc1tncm91cF09W107Zm9yKHZhciBpPTAsbGVuPXRoaXMuJHdhdGNoZWQubGVuZ3RoO2k8bGVuO2krKyl7dGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQ9J2F1dG8nOy8vbWF5YmUgY291bGQgdXNlIHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0VG9wXG52YXIgZWxPZmZzZXRUb3A9JCh0aGlzLiR3YXRjaGVkW2ldKS5vZmZzZXQoKS50b3A7aWYoZWxPZmZzZXRUb3AhPWxhc3RFbFRvcE9mZnNldCl7Z3JvdXArKztncm91cHNbZ3JvdXBdPVtdO2xhc3RFbFRvcE9mZnNldD1lbE9mZnNldFRvcDt9Z3JvdXBzW2dyb3VwXS5wdXNoKFt0aGlzLiR3YXRjaGVkW2ldLHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0XSk7fWZvcih2YXIgaj0wLGxuPWdyb3Vwcy5sZW5ndGg7ajxsbjtqKyspe3ZhciBoZWlnaHRzPSQoZ3JvdXBzW2pdKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc1sxXTt9KS5nZXQoKTt2YXIgbWF4PU1hdGgubWF4LmFwcGx5KG51bGwsaGVpZ2h0cyk7Z3JvdXBzW2pdLnB1c2gobWF4KTt9Y2IoZ3JvdXBzKTt9LyoqXG4gICAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdFxuICAgICAgICogQHBhcmFtIHthcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcbiAgICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgICAqL30se2tleTonYXBwbHlIZWlnaHQnLHZhbHVlOmZ1bmN0aW9uIGFwcGx5SGVpZ2h0KGhlaWdodHMpe3ZhciBtYXg9TWF0aC5tYXguYXBwbHkobnVsbCxoZWlnaHRzKTsvKipcbiAgICAgICAgICogRmlyZXMgYmVmb3JlIHRoZSBoZWlnaHRzIGFyZSBhcHBsaWVkXG4gICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkLnpmLmVxdWFsaXplcicpO3RoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLG1heCk7LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhlaWdodHMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTt9LyoqXG4gICAgICAgKiBDaGFuZ2VzIHRoZSBDU1MgaGVpZ2h0IHByb3BlcnR5IG9mIGVhY2ggY2hpbGQgaW4gYW4gRXF1YWxpemVyIHBhcmVudCB0byBtYXRjaCB0aGUgdGFsbGVzdCBieSByb3dcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGdyb3VwcyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXIgZ3JvdXBlZCBieSByb3cgd2l0aCBlbGVtZW50LGhlaWdodCBhbmQgbWF4IGFzIGxhc3QgY2hpbGRcbiAgICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFJvd1xuICAgICAgICogQGZpcmVzIEVxdWFsaXplciNwb3N0ZXF1YWxpemVkUm93XG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcbiAgICAgICAqL30se2tleTonYXBwbHlIZWlnaHRCeVJvdycsdmFsdWU6ZnVuY3Rpb24gYXBwbHlIZWlnaHRCeVJvdyhncm91cHMpey8qKlxuICAgICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7Zm9yKHZhciBpPTAsbGVuPWdyb3Vwcy5sZW5ndGg7aTxsZW47aSsrKXt2YXIgZ3JvdXBzSUxlbmd0aD1ncm91cHNbaV0ubGVuZ3RoLG1heD1ncm91cHNbaV1bZ3JvdXBzSUxlbmd0aC0xXTtpZihncm91cHNJTGVuZ3RoPD0yKXskKGdyb3Vwc1tpXVswXVswXSkuY3NzKHsnaGVpZ2h0JzonYXV0byd9KTtjb250aW51ZTt9LyoqXG4gICAgICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXG4gICAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkUm93XG4gICAgICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO2Zvcih2YXIgaj0wLGxlbko9Z3JvdXBzSUxlbmd0aC0xO2o8bGVuSjtqKyspeyQoZ3JvdXBzW2ldW2pdWzBdKS5jc3MoeydoZWlnaHQnOm1heH0pO30vKipcbiAgICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBwZXIgcm93IGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFJvd1xuICAgICAgICAgICAgKi90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWRyb3cuemYuZXF1YWxpemVyJyk7fS8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTt9LyoqXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBFcXVhbGl6ZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe3RoaXMuX3BhdXNlRXZlbnRzKCk7dGhpcy4kd2F0Y2hlZC5jc3MoJ2hlaWdodCcsJ2F1dG8nKTtGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gRXF1YWxpemVyO30oKTsvKipcbiAgICogRGVmYXVsdCBzZXR0aW5ncyBmb3IgcGx1Z2luXG4gICAqL0VxdWFsaXplci5kZWZhdWx0cz17LyoqXG4gICAgICogRW5hYmxlIGhlaWdodCBlcXVhbGl6YXRpb24gd2hlbiBzdGFja2VkIG9uIHNtYWxsZXIgc2NyZWVucy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2VxdWFsaXplT25TdGFjazp0cnVlLC8qKlxuICAgICAqIEVuYWJsZSBoZWlnaHQgZXF1YWxpemF0aW9uIHJvdyBieSByb3cuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovZXF1YWxpemVCeVJvdzpmYWxzZSwvKipcbiAgICAgKiBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSB0aGUgcGx1Z2luIHNob3VsZCBlcXVhbGl6ZSBoZWlnaHRzIG9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xuICAgICAqL2VxdWFsaXplT246Jyd9Oy8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihFcXVhbGl6ZXIsJ0VxdWFsaXplcicpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogSW50ZXJjaGFuZ2UgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uaW50ZXJjaGFuZ2VcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlclxuICAgKi92YXIgSW50ZXJjaGFuZ2U9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEludGVyY2hhbmdlLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBJbnRlcmNoYW5nZSNpbml0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovZnVuY3Rpb24gSW50ZXJjaGFuZ2UoZWxlbWVudCxvcHRpb25zKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxJbnRlcmNoYW5nZSk7dGhpcy4kZWxlbWVudD1lbGVtZW50O3RoaXMub3B0aW9ucz0kLmV4dGVuZCh7fSxJbnRlcmNoYW5nZS5kZWZhdWx0cyxvcHRpb25zKTt0aGlzLnJ1bGVzPVtdO3RoaXMuY3VycmVudFBhdGg9Jyc7dGhpcy5faW5pdCgpO3RoaXMuX2V2ZW50cygpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnSW50ZXJjaGFuZ2UnKTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEludGVyY2hhbmdlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBpbnRlcmNoYW5nZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovX2NyZWF0ZUNsYXNzKEludGVyY2hhbmdlLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt0aGlzLl9hZGRCcmVha3BvaW50cygpO3RoaXMuX2dlbmVyYXRlUnVsZXMoKTt0aGlzLl9yZWZsb3coKTt9LyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEludGVyY2hhbmdlLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfZXZlbnRzJyx2YWx1ZTpmdW5jdGlvbiBfZXZlbnRzKCl7JCh3aW5kb3cpLm9uKCdyZXNpemUuemYuaW50ZXJjaGFuZ2UnLEZvdW5kYXRpb24udXRpbC50aHJvdHRsZSh0aGlzLl9yZWZsb3cuYmluZCh0aGlzKSw1MCkpO30vKipcbiAgICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEludGVyY2hhbmdlIHVwb24gRE9NIGNoYW5nZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfcmVmbG93Jyx2YWx1ZTpmdW5jdGlvbiBfcmVmbG93KCl7dmFyIG1hdGNoOy8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHJ1bGUsIGJ1dCBvbmx5IHNhdmUgdGhlIGxhc3QgbWF0Y2hcbmZvcih2YXIgaSBpbiB0aGlzLnJ1bGVzKXtpZih0aGlzLnJ1bGVzLmhhc093blByb3BlcnR5KGkpKXt2YXIgcnVsZT10aGlzLnJ1bGVzW2ldO2lmKHdpbmRvdy5tYXRjaE1lZGlhKHJ1bGUucXVlcnkpLm1hdGNoZXMpe21hdGNoPXJ1bGU7fX19aWYobWF0Y2gpe3RoaXMucmVwbGFjZShtYXRjaC5wYXRoKTt9fS8qKlxuICAgICAgICogR2V0cyB0aGUgRm91bmRhdGlvbiBicmVha3BvaW50cyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVMgb2JqZWN0LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfYWRkQnJlYWtwb2ludHMnLHZhbHVlOmZ1bmN0aW9uIF9hZGRCcmVha3BvaW50cygpe2Zvcih2YXIgaSBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcyl7aWYoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpe3ZhciBxdWVyeT1Gb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllc1tpXTtJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV09cXVlcnkudmFsdWU7fX19LyoqXG4gICAgICAgKiBDaGVja3MgdGhlIEludGVyY2hhbmdlIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBtZWRpYSBxdWVyeSArIGNvbnRlbnQgcGFpcmluZ3NcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0aGF0IGlzIGFuIEludGVyY2hhbmdlIGluc3RhbmNlXG4gICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IHNjZW5hcmlvcyAtIEFycmF5IG9mIG9iamVjdHMgdGhhdCBoYXZlICdtcScgYW5kICdwYXRoJyBrZXlzIHdpdGggY29ycmVzcG9uZGluZyBrZXlzXG4gICAgICAgKi99LHtrZXk6J19nZW5lcmF0ZVJ1bGVzJyx2YWx1ZTpmdW5jdGlvbiBfZ2VuZXJhdGVSdWxlcyhlbGVtZW50KXt2YXIgcnVsZXNMaXN0PVtdO3ZhciBydWxlcztpZih0aGlzLm9wdGlvbnMucnVsZXMpe3J1bGVzPXRoaXMub3B0aW9ucy5ydWxlczt9ZWxzZXtydWxlcz10aGlzLiRlbGVtZW50LmRhdGEoJ2ludGVyY2hhbmdlJykubWF0Y2goL1xcWy4qP1xcXS9nKTt9Zm9yKHZhciBpIGluIHJ1bGVzKXtpZihydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSl7dmFyIHJ1bGU9cnVsZXNbaV0uc2xpY2UoMSwtMSkuc3BsaXQoJywgJyk7dmFyIHBhdGg9cnVsZS5zbGljZSgwLC0xKS5qb2luKCcnKTt2YXIgcXVlcnk9cnVsZVtydWxlLmxlbmd0aC0xXTtpZihJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldKXtxdWVyeT1JbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldO31ydWxlc0xpc3QucHVzaCh7cGF0aDpwYXRoLHF1ZXJ5OnF1ZXJ5fSk7fX10aGlzLnJ1bGVzPXJ1bGVzTGlzdDt9LyoqXG4gICAgICAgKiBVcGRhdGUgdGhlIGBzcmNgIHByb3BlcnR5IG9mIGFuIGltYWdlLCBvciBjaGFuZ2UgdGhlIEhUTUwgb2YgYSBjb250YWluZXIsIHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBQYXRoIHRvIHRoZSBpbWFnZSBvciBIVE1MIHBhcnRpYWwuXG4gICAgICAgKiBAZmlyZXMgSW50ZXJjaGFuZ2UjcmVwbGFjZWRcbiAgICAgICAqL30se2tleToncmVwbGFjZScsdmFsdWU6ZnVuY3Rpb24gcmVwbGFjZShwYXRoKXtpZih0aGlzLmN1cnJlbnRQYXRoPT09cGF0aClyZXR1cm47dmFyIF90aGlzPXRoaXMsdHJpZ2dlcj0ncmVwbGFjZWQuemYuaW50ZXJjaGFuZ2UnOy8vIFJlcGxhY2luZyBpbWFnZXNcbmlmKHRoaXMuJGVsZW1lbnRbMF0ubm9kZU5hbWU9PT0nSU1HJyl7dGhpcy4kZWxlbWVudC5hdHRyKCdzcmMnLHBhdGgpLmxvYWQoZnVuY3Rpb24oKXtfdGhpcy5jdXJyZW50UGF0aD1wYXRoO30pLnRyaWdnZXIodHJpZ2dlcik7fS8vIFJlcGxhY2luZyBiYWNrZ3JvdW5kIGltYWdlc1xuZWxzZSBpZihwYXRoLm1hdGNoKC9cXC4oZ2lmfGpwZ3xqcGVnfHBuZ3xzdmd8dGlmZikoWz8jXS4qKT8vaSkpe3RoaXMuJGVsZW1lbnQuY3NzKHsnYmFja2dyb3VuZC1pbWFnZSc6J3VybCgnK3BhdGgrJyknfSkudHJpZ2dlcih0cmlnZ2VyKTt9Ly8gUmVwbGFjaW5nIEhUTUxcbmVsc2V7JC5nZXQocGF0aCxmdW5jdGlvbihyZXNwb25zZSl7X3RoaXMuJGVsZW1lbnQuaHRtbChyZXNwb25zZSkudHJpZ2dlcih0cmlnZ2VyKTskKHJlc3BvbnNlKS5mb3VuZGF0aW9uKCk7X3RoaXMuY3VycmVudFBhdGg9cGF0aDt9KTt9LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gY29udGVudCBpbiBhbiBJbnRlcmNoYW5nZSBlbGVtZW50IGlzIGRvbmUgYmVpbmcgbG9hZGVkLlxuICAgICAgICAgKiBAZXZlbnQgSW50ZXJjaGFuZ2UjcmVwbGFjZWRcbiAgICAgICAgICovLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZXBsYWNlZC56Zi5pbnRlcmNoYW5nZScpO1xufS8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgaW50ZXJjaGFuZ2UuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpey8vVE9ETyB0aGlzLlxufX1dKTtyZXR1cm4gSW50ZXJjaGFuZ2U7fSgpOy8qKlxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAgICovSW50ZXJjaGFuZ2UuZGVmYXVsdHM9ey8qKlxuICAgICAqIFJ1bGVzIHRvIGJlIGFwcGxpZWQgdG8gSW50ZXJjaGFuZ2UgZWxlbWVudHMuIFNldCB3aXRoIHRoZSBgZGF0YS1pbnRlcmNoYW5nZWAgYXJyYXkgbm90YXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqL3J1bGVzOm51bGx9O0ludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFUz17J2xhbmRzY2FwZSc6J3NjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJywncG9ydHJhaXQnOidzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJywncmV0aW5hJzonb25seSBzY3JlZW4gYW5kICgtd2Via2l0LW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAoLW8tbWluLWRldmljZS1waXhlbC1yYXRpbzogMi8xKSwgb25seSBzY3JlZW4gYW5kIChtaW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwgb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMmRwcHgpJ307Ly8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKEludGVyY2hhbmdlLCdJbnRlcmNoYW5nZScpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogTWFnZWxsYW4gbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ubWFnZWxsYW5cbiAgICovdmFyIE1hZ2VsbGFuPWZ1bmN0aW9uKCl7LyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNYWdlbGxhbi5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgTWFnZWxsYW4jaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIE1hZ2VsbGFuKGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsTWFnZWxsYW4pO3RoaXMuJGVsZW1lbnQ9ZWxlbWVudDt0aGlzLm9wdGlvbnM9JC5leHRlbmQoe30sTWFnZWxsYW4uZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnTWFnZWxsYW4nKTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIE1hZ2VsbGFuIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBlcXVhbGl6ZXIgZnVuY3Rpb25pbmcgb24gbG9hZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhNYWdlbGxhbixbe2tleTonX2luaXQnLHZhbHVlOmZ1bmN0aW9uIF9pbml0KCl7dmFyIGlkPXRoaXMuJGVsZW1lbnRbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwnbWFnZWxsYW4nKTt2YXIgX3RoaXM9dGhpczt0aGlzLiR0YXJnZXRzPSQoJ1tkYXRhLW1hZ2VsbGFuLXRhcmdldF0nKTt0aGlzLiRsaW5rcz10aGlzLiRlbGVtZW50LmZpbmQoJ2EnKTt0aGlzLiRlbGVtZW50LmF0dHIoeydkYXRhLXJlc2l6ZSc6aWQsJ2RhdGEtc2Nyb2xsJzppZCwnaWQnOmlkfSk7dGhpcy4kYWN0aXZlPSQoKTt0aGlzLnNjcm9sbFBvcz1wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApO3RoaXMuX2V2ZW50cygpO30vKipcbiAgICAgICAqIENhbGN1bGF0ZXMgYW4gYXJyYXkgb2YgcGl4ZWwgdmFsdWVzIHRoYXQgYXJlIHRoZSBkZW1hcmNhdGlvbiBsaW5lcyBiZXR3ZWVuIGxvY2F0aW9ucyBvbiB0aGUgcGFnZS5cbiAgICAgICAqIENhbiBiZSBpbnZva2VkIGlmIG5ldyBlbGVtZW50cyBhcmUgYWRkZWQgb3IgdGhlIHNpemUgb2YgYSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J2NhbGNQb2ludHMnLHZhbHVlOmZ1bmN0aW9uIGNhbGNQb2ludHMoKXt2YXIgX3RoaXM9dGhpcyxib2R5PWRvY3VtZW50LmJvZHksaHRtbD1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dGhpcy5wb2ludHM9W107dGhpcy53aW5IZWlnaHQ9TWF0aC5yb3VuZChNYXRoLm1heCh3aW5kb3cuaW5uZXJIZWlnaHQsaHRtbC5jbGllbnRIZWlnaHQpKTt0aGlzLmRvY0hlaWdodD1NYXRoLnJvdW5kKE1hdGgubWF4KGJvZHkuc2Nyb2xsSGVpZ2h0LGJvZHkub2Zmc2V0SGVpZ2h0LGh0bWwuY2xpZW50SGVpZ2h0LGh0bWwuc2Nyb2xsSGVpZ2h0LGh0bWwub2Zmc2V0SGVpZ2h0KSk7dGhpcy4kdGFyZ2V0cy5lYWNoKGZ1bmN0aW9uKCl7dmFyICR0YXI9JCh0aGlzKSxwdD1NYXRoLnJvdW5kKCR0YXIub2Zmc2V0KCkudG9wLV90aGlzLm9wdGlvbnMudGhyZXNob2xkKTskdGFyLnRhcmdldFBvaW50PXB0O190aGlzLnBvaW50cy5wdXNoKHB0KTt9KTt9LyoqXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIE1hZ2VsbGFuLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpcz10aGlzLCRib2R5PSQoJ2h0bWwsIGJvZHknKSxvcHRzPXtkdXJhdGlvbjpfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLGVhc2luZzpfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZ307JCh3aW5kb3cpLm9uZSgnbG9hZCcsZnVuY3Rpb24oKXtpZihfdGhpcy5vcHRpb25zLmRlZXBMaW5raW5nKXtpZihsb2NhdGlvbi5oYXNoKXtfdGhpcy5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKTt9fV90aGlzLmNhbGNQb2ludHMoKTtfdGhpcy5fdXBkYXRlQWN0aXZlKCk7fSk7dGhpcy4kZWxlbWVudC5vbih7J3Jlc2l6ZW1lLnpmLnRyaWdnZXInOnRoaXMucmVmbG93LmJpbmQodGhpcyksJ3Njcm9sbG1lLnpmLnRyaWdnZXInOnRoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKHRoaXMpfSkub24oJ2NsaWNrLnpmLm1hZ2VsbGFuJywnYVtocmVmXj1cIiNcIl0nLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTt2YXIgYXJyaXZhbD10aGlzLmdldEF0dHJpYnV0ZSgnaHJlZicpO190aGlzLnNjcm9sbFRvTG9jKGFycml2YWwpO30pO30vKipcbiAgICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxvYyAtIGEgcHJvcGVybHkgZm9ybWF0dGVkIGpRdWVyeSBpZCBzZWxlY3Rvci4gRXhhbXBsZTogJyNmb28nXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonc2Nyb2xsVG9Mb2MnLHZhbHVlOmZ1bmN0aW9uIHNjcm9sbFRvTG9jKGxvYyl7dmFyIHNjcm9sbFBvcz1NYXRoLnJvdW5kKCQobG9jKS5vZmZzZXQoKS50b3AtdGhpcy5vcHRpb25zLnRocmVzaG9sZC8yLXRoaXMub3B0aW9ucy5iYXJPZmZzZXQpOyQoJ2h0bWwsIGJvZHknKS5zdG9wKHRydWUpLmFuaW1hdGUoe3Njcm9sbFRvcDpzY3JvbGxQb3N9LHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbix0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nKTt9LyoqXG4gICAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBNYWdlbGxhbiB1cG9uIERPTSBjaGFuZ2VcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5OidyZWZsb3cnLHZhbHVlOmZ1bmN0aW9uIHJlZmxvdygpe3RoaXMuY2FsY1BvaW50cygpO3RoaXMuX3VwZGF0ZUFjdGl2ZSgpO30vKipcbiAgICAgICAqIFVwZGF0ZXMgdGhlIHZpc2liaWxpdHkgb2YgYW4gYWN0aXZlIGxvY2F0aW9uIGxpbmssIGFuZCB1cGRhdGVzIHRoZSB1cmwgaGFzaCBmb3IgdGhlIHBhZ2UsIGlmIGRlZXBMaW5raW5nIGVuYWJsZWQuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAZmlyZXMgTWFnZWxsYW4jdXBkYXRlXG4gICAgICAgKi99LHtrZXk6J191cGRhdGVBY3RpdmUnLHZhbHVlOmZ1bmN0aW9uIF91cGRhdGVBY3RpdmUoKS8qZXZ0LCBlbGVtLCBzY3JvbGxQb3MqL3t2YXIgd2luUG9zPS8qc2Nyb2xsUG9zIHx8Ki9wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsMTApLGN1cklkeDtpZih3aW5Qb3MrdGhpcy53aW5IZWlnaHQ9PT10aGlzLmRvY0hlaWdodCl7Y3VySWR4PXRoaXMucG9pbnRzLmxlbmd0aC0xO31lbHNlIGlmKHdpblBvczx0aGlzLnBvaW50c1swXSl7Y3VySWR4PTA7fWVsc2V7dmFyIGlzRG93bj10aGlzLnNjcm9sbFBvczx3aW5Qb3MsX3RoaXM9dGhpcyxjdXJWaXNpYmxlPXRoaXMucG9pbnRzLmZpbHRlcihmdW5jdGlvbihwLGkpe3JldHVybiBpc0Rvd24/cC1fdGhpcy5vcHRpb25zLmJhck9mZnNldDw9d2luUG9zOnAtX3RoaXMub3B0aW9ucy5iYXJPZmZzZXQtX3RoaXMub3B0aW9ucy50aHJlc2hvbGQ8PXdpblBvczt9KTtjdXJJZHg9Y3VyVmlzaWJsZS5sZW5ndGg/Y3VyVmlzaWJsZS5sZW5ndGgtMTowO310aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTt0aGlzLiRhY3RpdmU9dGhpcy4kbGlua3MuZXEoY3VySWR4KS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpO2lmKHRoaXMub3B0aW9ucy5kZWVwTGlua2luZyl7dmFyIGhhc2g9dGhpcy4kYWN0aXZlWzBdLmdldEF0dHJpYnV0ZSgnaHJlZicpO2lmKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSl7d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsbnVsbCxoYXNoKTt9ZWxzZXt3aW5kb3cubG9jYXRpb24uaGFzaD1oYXNoO319dGhpcy5zY3JvbGxQb3M9d2luUG9zOy8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIG1hZ2VsbGFuIGlzIGZpbmlzaGVkIHVwZGF0aW5nIHRvIHRoZSBuZXcgYWN0aXZlIGVsZW1lbnQuXG4gICAgICAgICAqIEBldmVudCBNYWdlbGxhbiN1cGRhdGVcbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCd1cGRhdGUuemYubWFnZWxsYW4nLFt0aGlzLiRhY3RpdmVdKTt9LyoqXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBNYWdlbGxhbiBhbmQgcmVzZXRzIHRoZSB1cmwgb2YgdGhlIHdpbmRvdy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhbicpLmZpbmQoJy4nK3RoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtpZih0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpe3ZhciBoYXNoPXRoaXMuJGFjdGl2ZVswXS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTt3aW5kb3cubG9jYXRpb24uaGFzaC5yZXBsYWNlKGhhc2gsJycpO31Gb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gTWFnZWxsYW47fSgpOy8qKlxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cbiAgICovTWFnZWxsYW4uZGVmYXVsdHM9ey8qKlxuICAgICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIGFuaW1hdGVkIHNjcm9sbGluZyBzaG91bGQgdGFrZSBiZXR3ZWVuIGxvY2F0aW9ucy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgNTAwXG4gICAgICovYW5pbWF0aW9uRHVyYXRpb246NTAwLC8qKlxuICAgICAqIEFuaW1hdGlvbiBzdHlsZSB0byB1c2Ugd2hlbiBzY3JvbGxpbmcgYmV0d2VlbiBsb2NhdGlvbnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdlYXNlLWluLW91dCdcbiAgICAgKi9hbmltYXRpb25FYXNpbmc6J2xpbmVhcicsLyoqXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyB0byB1c2UgYXMgYSBtYXJrZXIgZm9yIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDUwXG4gICAgICovdGhyZXNob2xkOjUwLC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBsb2NhdGlvbnMgbGluayBvbiB0aGUgbWFnZWxsYW4gY29udGFpbmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnYWN0aXZlJ1xuICAgICAqL2FjdGl2ZUNsYXNzOidhY3RpdmUnLC8qKlxuICAgICAqIEFsbG93cyB0aGUgc2NyaXB0IHRvIG1hbmlwdWxhdGUgdGhlIHVybCBvZiB0aGUgY3VycmVudCBwYWdlLCBhbmQgaWYgc3VwcG9ydGVkLCBhbHRlciB0aGUgaGlzdG9yeS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2RlZXBMaW5raW5nOmZhbHNlLC8qKlxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgdG8gb2Zmc2V0IHRoZSBzY3JvbGwgb2YgdGhlIHBhZ2Ugb24gaXRlbSBjbGljayBpZiB1c2luZyBhIHN0aWNreSBuYXYgYmFyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyNVxuICAgICAqL2Jhck9mZnNldDowfTsvLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oTWFnZWxsYW4sJ01hZ2VsbGFuJyk7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fTt9KCk7IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBPZmZDYW52YXMgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ub2ZmY2FudmFzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gICAqL3ZhciBPZmZDYW52YXM9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9mZi1jYW52YXMgd3JhcHBlci5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgT2ZmQ2FudmFzI2luaXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gaW5pdGlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovZnVuY3Rpb24gT2ZmQ2FudmFzKGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsT2ZmQ2FudmFzKTt0aGlzLiRlbGVtZW50PWVsZW1lbnQ7dGhpcy5vcHRpb25zPSQuZXh0ZW5kKHt9LE9mZkNhbnZhcy5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxvcHRpb25zKTt0aGlzLiRsYXN0VHJpZ2dlcj0kKCk7dGhpcy4kdHJpZ2dlcnM9JCgpO3RoaXMuX2luaXQoKTt0aGlzLl9ldmVudHMoKTtGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsJ09mZkNhbnZhcycpO30vKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGJ5IGFkZGluZyB0aGUgZXhpdCBvdmVybGF5IChpZiBuZWVkZWQpLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovX2NyZWF0ZUNsYXNzKE9mZkNhbnZhcyxbe2tleTonX2luaXQnLHZhbHVlOmZ1bmN0aW9uIF9pbml0KCl7dmFyIGlkPXRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTt0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywndHJ1ZScpOy8vIEZpbmQgdHJpZ2dlcnMgdGhhdCBhZmZlY3QgdGhpcyBlbGVtZW50IGFuZCBhZGQgYXJpYS1leHBhbmRlZCB0byB0aGVtXG50aGlzLiR0cmlnZ2Vycz0kKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVwiJytpZCsnXCJdLCBbZGF0YS1jbG9zZT1cIicraWQrJ1wiXSwgW2RhdGEtdG9nZ2xlPVwiJytpZCsnXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsJ2ZhbHNlJykuYXR0cignYXJpYS1jb250cm9scycsaWQpOy8vIEFkZCBhIGNsb3NlIHRyaWdnZXIgb3ZlciB0aGUgYm9keSBpZiBuZWNlc3NhcnlcbmlmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe2lmKCQoJy5qcy1vZmYtY2FudmFzLWV4aXQnKS5sZW5ndGgpe3RoaXMuJGV4aXRlcj0kKCcuanMtb2ZmLWNhbnZhcy1leGl0Jyk7fWVsc2V7dmFyIGV4aXRlcj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtleGl0ZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsJ2pzLW9mZi1jYW52YXMtZXhpdCcpOyQoJ1tkYXRhLW9mZi1jYW52YXMtY29udGVudF0nKS5hcHBlbmQoZXhpdGVyKTt0aGlzLiRleGl0ZXI9JChleGl0ZXIpO319dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQ9dGhpcy5vcHRpb25zLmlzUmV2ZWFsZWR8fG5ldyBSZWdFeHAodGhpcy5vcHRpb25zLnJldmVhbENsYXNzLCdnJykudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSk7aWYodGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQpe3RoaXMub3B0aW9ucy5yZXZlYWxPbj10aGlzLm9wdGlvbnMucmV2ZWFsT258fHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8ocmV2ZWFsLWZvci1tZWRpdW18cmV2ZWFsLWZvci1sYXJnZSkvZylbMF0uc3BsaXQoJy0nKVsyXTt0aGlzLl9zZXRNUUNoZWNrZXIoKTt9aWYoIXRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSl7dGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lPXBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pKjEwMDA7fX0vKipcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gdGhlIG9mZi1jYW52YXMgd3JhcHBlciBhbmQgdGhlIGV4aXQgb3ZlcmxheS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3RoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYub2ZmY2FudmFzJykub24oeydvcGVuLnpmLnRyaWdnZXInOnRoaXMub3Blbi5iaW5kKHRoaXMpLCdjbG9zZS56Zi50cmlnZ2VyJzp0aGlzLmNsb3NlLmJpbmQodGhpcyksJ3RvZ2dsZS56Zi50cmlnZ2VyJzp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLCdrZXlkb3duLnpmLm9mZmNhbnZhcyc6dGhpcy5faGFuZGxlS2V5Ym9hcmQuYmluZCh0aGlzKX0pO2lmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2smJnRoaXMuJGV4aXRlci5sZW5ndGgpe3RoaXMuJGV4aXRlci5vbih7J2NsaWNrLnpmLm9mZmNhbnZhcyc6dGhpcy5jbG9zZS5iaW5kKHRoaXMpfSk7fX0vKipcbiAgICAgICAqIEFwcGxpZXMgZXZlbnQgbGlzdGVuZXIgZm9yIGVsZW1lbnRzIHRoYXQgd2lsbCByZXZlYWwgYXQgY2VydGFpbiBicmVha3BvaW50cy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19zZXRNUUNoZWNrZXInLHZhbHVlOmZ1bmN0aW9uIF9zZXRNUUNoZWNrZXIoKXt2YXIgX3RoaXM9dGhpczskKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsZnVuY3Rpb24oKXtpZihGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSl7X3RoaXMucmV2ZWFsKHRydWUpO31lbHNle190aGlzLnJldmVhbChmYWxzZSk7fX0pLm9uZSgnbG9hZC56Zi5vZmZjYW52YXMnLGZ1bmN0aW9uKCl7aWYoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoX3RoaXMub3B0aW9ucy5yZXZlYWxPbikpe190aGlzLnJldmVhbCh0cnVlKTt9fSk7fS8qKlxuICAgICAgICogSGFuZGxlcyB0aGUgcmV2ZWFsaW5nL2hpZGluZyB0aGUgb2ZmLWNhbnZhcyBhdCBicmVha3BvaW50cywgbm90IHRoZSBzYW1lIGFzIG9wZW4uXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGlzUmV2ZWFsZWQgLSB0cnVlIGlmIGVsZW1lbnQgc2hvdWxkIGJlIHJldmVhbGVkLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J3JldmVhbCcsdmFsdWU6ZnVuY3Rpb24gcmV2ZWFsKGlzUmV2ZWFsZWQpe3ZhciAkY2xvc2VyPXRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtY2xvc2VdJyk7aWYoaXNSZXZlYWxlZCl7dGhpcy5jbG9zZSgpO3RoaXMuaXNSZXZlYWxlZD10cnVlOy8vIGlmICghdGhpcy5vcHRpb25zLmZvcmNlVG9wKSB7XG4vLyAgIHZhciBzY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQpO1xuLy8gICB0aGlzLiRlbGVtZW50WzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgc2Nyb2xsUG9zICsgJ3B4KSc7XG4vLyB9XG4vLyBpZiAodGhpcy5vcHRpb25zLmlzU3RpY2t5KSB7IHRoaXMuX3N0aWNrKCk7IH1cbnRoaXMuJGVsZW1lbnQub2ZmKCdvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXInKTtpZigkY2xvc2VyLmxlbmd0aCl7JGNsb3Nlci5oaWRlKCk7fX1lbHNle3RoaXMuaXNSZXZlYWxlZD1mYWxzZTsvLyBpZiAodGhpcy5vcHRpb25zLmlzU3RpY2t5IHx8ICF0aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbi8vICAgdGhpcy4kZWxlbWVudFswXS5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbi8vICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLm9mZmNhbnZhcycpO1xuLy8gfVxudGhpcy4kZWxlbWVudC5vbih7J29wZW4uemYudHJpZ2dlcic6dGhpcy5vcGVuLmJpbmQodGhpcyksJ3RvZ2dsZS56Zi50cmlnZ2VyJzp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpfSk7aWYoJGNsb3Nlci5sZW5ndGgpeyRjbG9zZXIuc2hvdygpO319fS8qKlxuICAgICAgICogT3BlbnMgdGhlIG9mZi1jYW52YXMgbWVudS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgb2JqZWN0IHBhc3NlZCBmcm9tIGxpc3RlbmVyLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9IHRyaWdnZXIgLSBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBvZmYtY2FudmFzIHRvIG9wZW4uXG4gICAgICAgKiBAZmlyZXMgT2ZmQ2FudmFzI29wZW5lZFxuICAgICAgICovfSx7a2V5OidvcGVuJyx2YWx1ZTpmdW5jdGlvbiBvcGVuKGV2ZW50LHRyaWdnZXIpe2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKXx8dGhpcy5pc1JldmVhbGVkKXtyZXR1cm47fXZhciBfdGhpcz10aGlzLCRib2R5PSQoZG9jdW1lbnQuYm9keSk7aWYodGhpcy5vcHRpb25zLmZvcmNlVG9wKXskKCdib2R5Jykuc2Nyb2xsVG9wKDApO30vLyB3aW5kb3cucGFnZVlPZmZzZXQgPSAwO1xuLy8gaWYgKCF0aGlzLm9wdGlvbnMuZm9yY2VUb3ApIHtcbi8vICAgdmFyIHNjcm9sbFBvcyA9IHBhcnNlSW50KHdpbmRvdy5wYWdlWU9mZnNldCk7XG4vLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcbi8vICAgaWYgKHRoaXMuJGV4aXRlci5sZW5ndGgpIHtcbi8vICAgICB0aGlzLiRleGl0ZXJbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcbi8vICAgfVxuLy8gfVxuLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNvcGVuZWRcbiAgICAgICAgICovRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSx0aGlzLiRlbGVtZW50LGZ1bmN0aW9uKCl7JCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpLmFkZENsYXNzKCdpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi0nK190aGlzLm9wdGlvbnMucG9zaXRpb24pO190aGlzLiRlbGVtZW50LmFkZENsYXNzKCdpcy1vcGVuJyk7Ly8gaWYgKF90aGlzLm9wdGlvbnMuaXNTdGlja3kpIHtcbi8vICAgX3RoaXMuX3N0aWNrKCk7XG4vLyB9XG59KTt0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywndHJ1ZScpO3RoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCdmYWxzZScpLnRyaWdnZXIoJ29wZW5lZC56Zi5vZmZjYW52YXMnKTtpZih0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKXt0aGlzLiRleGl0ZXIuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTt9aWYodHJpZ2dlcil7dGhpcy4kbGFzdFRyaWdnZXI9dHJpZ2dlcjt9aWYodGhpcy5vcHRpb25zLmF1dG9Gb2N1cyl7dGhpcy4kZWxlbWVudC5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHRoaXMuJGVsZW1lbnQpLGZ1bmN0aW9uKCl7X3RoaXMuJGVsZW1lbnQuZmluZCgnYSwgYnV0dG9uJykuZXEoMCkuZm9jdXMoKTt9KTt9aWYodGhpcy5vcHRpb25zLnRyYXBGb2N1cyl7JCgnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmF0dHIoJ3RhYmluZGV4JywnLTEnKTt0aGlzLl90cmFwRm9jdXMoKTt9fS8qKlxuICAgICAgICogVHJhcHMgZm9jdXMgd2l0aGluIHRoZSBvZmZjYW52YXMgb24gb3Blbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J190cmFwRm9jdXMnLHZhbHVlOmZ1bmN0aW9uIF90cmFwRm9jdXMoKXt2YXIgZm9jdXNhYmxlPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KSxmaXJzdD1mb2N1c2FibGUuZXEoMCksbGFzdD1mb2N1c2FibGUuZXEoLTEpO2ZvY3VzYWJsZS5vZmYoJy56Zi5vZmZjYW52YXMnKS5vbigna2V5ZG93bi56Zi5vZmZjYW52YXMnLGZ1bmN0aW9uKGUpe2lmKGUud2hpY2g9PT05fHxlLmtleWNvZGU9PT05KXtpZihlLnRhcmdldD09PWxhc3RbMF0mJiFlLnNoaWZ0S2V5KXtlLnByZXZlbnREZWZhdWx0KCk7Zmlyc3QuZm9jdXMoKTt9aWYoZS50YXJnZXQ9PT1maXJzdFswXSYmZS5zaGlmdEtleSl7ZS5wcmV2ZW50RGVmYXVsdCgpO2xhc3QuZm9jdXMoKTt9fX0pO30vKipcbiAgICAgICAqIEFsbG93cyB0aGUgb2ZmY2FudmFzIHRvIGFwcGVhciBzdGlja3kgdXRpbGl6aW5nIHRyYW5zbGF0ZSBwcm9wZXJ0aWVzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqLy8vIE9mZkNhbnZhcy5wcm90b3R5cGUuX3N0aWNrID0gZnVuY3Rpb24oKSB7XG4vLyAgIHZhciBlbFN0eWxlID0gdGhpcy4kZWxlbWVudFswXS5zdHlsZTtcbi8vXG4vLyAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XG4vLyAgICAgdmFyIGV4aXRTdHlsZSA9IHRoaXMuJGV4aXRlclswXS5zdHlsZTtcbi8vICAgfVxuLy9cbi8vICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwuemYub2ZmY2FudmFzJywgZnVuY3Rpb24oZSkge1xuLy8gICAgIGNvbnNvbGUubG9nKGUpO1xuLy8gICAgIHZhciBwYWdlWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbi8vICAgICBlbFN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgcGFnZVkgKyAncHgpJztcbi8vICAgICBpZiAoZXhpdFN0eWxlICE9PSB1bmRlZmluZWQpIHsgZXhpdFN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgcGFnZVkgKyAncHgpJzsgfVxuLy8gICB9KTtcbi8vICAgLy8gdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzdHVjay56Zi5vZmZjYW52YXMnKTtcbi8vIH07XG4vKipcbiAgICAgICAqIENsb3NlcyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNiIHRvIGZpcmUgYWZ0ZXIgY2xvc3VyZS5cbiAgICAgICAqIEBmaXJlcyBPZmZDYW52YXMjY2xvc2VkXG4gICAgICAgKi99LHtrZXk6J2Nsb3NlJyx2YWx1ZTpmdW5jdGlvbiBjbG9zZShjYil7aWYoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKXx8dGhpcy5pc1JldmVhbGVkKXtyZXR1cm47fXZhciBfdGhpcz10aGlzOy8vICBGb3VuZGF0aW9uLk1vdmUodGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lLCB0aGlzLiRlbGVtZW50LCBmdW5jdGlvbigpIHtcbiQoJ1tkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl0nKS5yZW1vdmVDbGFzcygnaXMtb2ZmLWNhbnZhcy1vcGVuIGlzLW9wZW4tJytfdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtfdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtb3BlbicpOy8vIEZvdW5kYXRpb24uX3JlZmxvdygpO1xuLy8gfSk7XG50aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywndHJ1ZScpLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG9mZi1jYW52YXMgbWVudSBvcGVucy5cbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNjbG9zZWRcbiAgICAgICAgICovLnRyaWdnZXIoJ2Nsb3NlZC56Zi5vZmZjYW52YXMnKTsvLyBpZiAoX3RoaXMub3B0aW9ucy5pc1N0aWNreSB8fCAhX3RoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xuLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICAgIF90aGlzLiRlbGVtZW50WzBdLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuLy8gICAgICQod2luZG93KS5vZmYoJ3Njcm9sbC56Zi5vZmZjYW52YXMnKTtcbi8vICAgfSwgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKTtcbi8vIH1cbmlmKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spe3RoaXMuJGV4aXRlci5yZW1vdmVDbGFzcygnaXMtdmlzaWJsZScpO310aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywnZmFsc2UnKTtpZih0aGlzLm9wdGlvbnMudHJhcEZvY3VzKXskKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTt9fS8qKlxuICAgICAgICogVG9nZ2xlcyB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW4gb3IgY2xvc2VkLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBFdmVudCBvYmplY3QgcGFzc2VkIGZyb20gbGlzdGVuZXIuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gdHJpZ2dlciAtIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG9mZi1jYW52YXMgdG8gb3Blbi5cbiAgICAgICAqL30se2tleTondG9nZ2xlJyx2YWx1ZTpmdW5jdGlvbiB0b2dnbGUoZXZlbnQsdHJpZ2dlcil7aWYodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKXt0aGlzLmNsb3NlKGV2ZW50LHRyaWdnZXIpO31lbHNle3RoaXMub3BlbihldmVudCx0cmlnZ2VyKTt9fS8qKlxuICAgICAgICogSGFuZGxlcyBrZXlib2FyZCBpbnB1dCB3aGVuIGRldGVjdGVkLiBXaGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWQsIHRoZSBvZmYtY2FudmFzIG1lbnUgY2xvc2VzLCBhbmQgZm9jdXMgaXMgcmVzdG9yZWQgdG8gdGhlIGVsZW1lbnQgdGhhdCBvcGVuZWQgdGhlIG1lbnUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19oYW5kbGVLZXlib2FyZCcsdmFsdWU6ZnVuY3Rpb24gX2hhbmRsZUtleWJvYXJkKGV2ZW50KXtpZihldmVudC53aGljaCE9PTI3KXJldHVybjtldmVudC5zdG9wUHJvcGFnYXRpb24oKTtldmVudC5wcmV2ZW50RGVmYXVsdCgpO3RoaXMuY2xvc2UoKTt0aGlzLiRsYXN0VHJpZ2dlci5mb2N1cygpO30vKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBvZmZjYW52YXMgcGx1Z2luLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J2Rlc3Ryb3knLHZhbHVlOmZ1bmN0aW9uIGRlc3Ryb3koKXt0aGlzLmNsb3NlKCk7dGhpcy4kZWxlbWVudC5vZmYoJy56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXMnKTt0aGlzLiRleGl0ZXIub2ZmKCcuemYub2ZmY2FudmFzJyk7Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSk7cmV0dXJuIE9mZkNhbnZhczt9KCk7T2ZmQ2FudmFzLmRlZmF1bHRzPXsvKipcbiAgICAgKiBBbGxvdyB0aGUgdXNlciB0byBjbGljayBvdXRzaWRlIG9mIHRoZSBtZW51IHRvIGNsb3NlIGl0LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovY2xvc2VPbkNsaWNrOnRydWUsLyoqXG4gICAgICogQW1vdW50IG9mIHRpbWUgaW4gbXMgdGhlIG9wZW4gYW5kIGNsb3NlIHRyYW5zaXRpb24gcmVxdWlyZXMuIElmIG5vbmUgc2VsZWN0ZWQsIHB1bGxzIGZyb20gYm9keSBzdHlsZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgNTAwXG4gICAgICovdHJhbnNpdGlvblRpbWU6MCwvKipcbiAgICAgKiBEaXJlY3Rpb24gdGhlIG9mZmNhbnZhcyBvcGVucyBmcm9tLiBEZXRlcm1pbmVzIGNsYXNzIGFwcGxpZWQgdG8gYm9keS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgbGVmdFxuICAgICAqL3Bvc2l0aW9uOidsZWZ0JywvKipcbiAgICAgKiBGb3JjZSB0aGUgcGFnZSB0byBzY3JvbGwgdG8gdG9wIG9uIG9wZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9mb3JjZVRvcDp0cnVlLC8qKlxuICAgICAqIEFsbG93IHRoZSBvZmZjYW52YXMgdG8gcmVtYWluIG9wZW4gZm9yIGNlcnRhaW4gYnJlYWtwb2ludHMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovaXNSZXZlYWxlZDpmYWxzZSwvKipcbiAgICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyB3aXRoIHRoZSBgcmV2ZWFsQ2xhc3NgIG9wdGlvbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgcmV2ZWFsLWZvci1sYXJnZVxuICAgICAqL3JldmVhbE9uOm51bGwsLyoqXG4gICAgICogRm9yY2UgZm9jdXMgdG8gdGhlIG9mZmNhbnZhcyBvbiBvcGVuLiBJZiB0cnVlLCB3aWxsIGZvY3VzIHRoZSBvcGVuaW5nIHRyaWdnZXIgb24gY2xvc2UuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9hdXRvRm9jdXM6dHJ1ZSwvKipcbiAgICAgKiBDbGFzcyB1c2VkIHRvIGZvcmNlIGFuIG9mZmNhbnZhcyB0byByZW1haW4gb3Blbi4gRm91bmRhdGlvbiBkZWZhdWx0cyBmb3IgdGhpcyBhcmUgYHJldmVhbC1mb3ItbGFyZ2VgICYgYHJldmVhbC1mb3ItbWVkaXVtYC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogVE9ETyBpbXByb3ZlIHRoZSByZWdleCB0ZXN0aW5nIGZvciB0aGlzLlxuICAgICAqIEBleGFtcGxlIHJldmVhbC1mb3ItbGFyZ2VcbiAgICAgKi9yZXZlYWxDbGFzczoncmV2ZWFsLWZvci0nLC8qKlxuICAgICAqIFRyaWdnZXJzIG9wdGlvbmFsIGZvY3VzIHRyYXBwaW5nIHdoZW4gb3BlbmluZyBhbiBvZmZjYW52YXMuIFNldHMgdGFiaW5kZXggb2YgW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XSB0byAtMSBmb3IgYWNjZXNzaWJpbGl0eSBwdXJwb3Nlcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL3RyYXBGb2N1czpmYWxzZX07Ly8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKE9mZkNhbnZhcywnT2ZmQ2FudmFzJyk7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fTt9KCk7IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBPcmJpdCBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5vcmJpdFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudGltZXJBbmRJbWFnZUxvYWRlclxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRvdWNoXG4gICAqL3ZhciBPcmJpdD1mdW5jdGlvbigpey8qKlxuICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhbiBvcmJpdCBjYXJvdXNlbC5cbiAgICAqIEBjbGFzc1xuICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBPcmJpdCBDYXJvdXNlbC5cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cbiAgICAqL2Z1bmN0aW9uIE9yYml0KGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsT3JiaXQpO3RoaXMuJGVsZW1lbnQ9ZWxlbWVudDt0aGlzLm9wdGlvbnM9JC5leHRlbmQoe30sT3JiaXQuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnT3JiaXQnKTtGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdPcmJpdCcseydsdHInOnsnQVJST1dfUklHSFQnOiduZXh0JywnQVJST1dfTEVGVCc6J3ByZXZpb3VzJ30sJ3J0bCc6eydBUlJPV19MRUZUJzonbmV4dCcsJ0FSUk9XX1JJR0hUJzoncHJldmlvdXMnfX0pO30vKipcbiAgICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW4gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zLCBzZXR0aW5nIGF0dHJpYnV0ZXMsIGFuZCBzdGFydGluZyB0aGUgYW5pbWF0aW9uLlxuICAgICogQGZ1bmN0aW9uXG4gICAgKiBAcHJpdmF0ZVxuICAgICovX2NyZWF0ZUNsYXNzKE9yYml0LFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt0aGlzLiR3cmFwcGVyPXRoaXMuJGVsZW1lbnQuZmluZCgnLicrdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTt0aGlzLiRzbGlkZXM9dGhpcy4kZWxlbWVudC5maW5kKCcuJyt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7dmFyICRpbWFnZXM9dGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKSxpbml0QWN0aXZlPXRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKTtpZighaW5pdEFjdGl2ZS5sZW5ndGgpe3RoaXMuJHNsaWRlcy5lcSgwKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7fWlmKCF0aGlzLm9wdGlvbnMudXNlTVVJKXt0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoJ25vLW1vdGlvbnVpJyk7fWlmKCRpbWFnZXMubGVuZ3RoKXtGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKCRpbWFnZXMsdGhpcy5fcHJlcGFyZUZvck9yYml0LmJpbmQodGhpcykpO31lbHNle3RoaXMuX3ByZXBhcmVGb3JPcmJpdCgpOy8vaGVoZVxufWlmKHRoaXMub3B0aW9ucy5idWxsZXRzKXt0aGlzLl9sb2FkQnVsbGV0cygpO310aGlzLl9ldmVudHMoKTtpZih0aGlzLm9wdGlvbnMuYXV0b1BsYXkmJnRoaXMuJHNsaWRlcy5sZW5ndGg+MSl7dGhpcy5nZW9TeW5jKCk7fWlmKHRoaXMub3B0aW9ucy5hY2Nlc3NpYmxlKXsvLyBhbGxvdyB3cmFwcGVyIHRvIGJlIGZvY3VzYWJsZSB0byBlbmFibGUgYXJyb3cgbmF2aWdhdGlvblxudGhpcy4kd3JhcHBlci5hdHRyKCd0YWJpbmRleCcsMCk7fX0vKipcbiAgICAgICogQ3JlYXRlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGJ1bGxldHMsIGlmIHRoZXkgYXJlIGJlaW5nIHVzZWQuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKi99LHtrZXk6J19sb2FkQnVsbGV0cycsdmFsdWU6ZnVuY3Rpb24gX2xvYWRCdWxsZXRzKCl7dGhpcy4kYnVsbGV0cz10aGlzLiRlbGVtZW50LmZpbmQoJy4nK3RoaXMub3B0aW9ucy5ib3hPZkJ1bGxldHMpLmZpbmQoJ2J1dHRvbicpO30vKipcbiAgICAgICogU2V0cyBhIGB0aW1lcmAgb2JqZWN0IG9uIHRoZSBvcmJpdCwgYW5kIHN0YXJ0cyB0aGUgY291bnRlciBmb3IgdGhlIG5leHQgc2xpZGUuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKi99LHtrZXk6J2dlb1N5bmMnLHZhbHVlOmZ1bmN0aW9uIGdlb1N5bmMoKXt2YXIgX3RoaXM9dGhpczt0aGlzLnRpbWVyPW5ldyBGb3VuZGF0aW9uLlRpbWVyKHRoaXMuJGVsZW1lbnQse2R1cmF0aW9uOnRoaXMub3B0aW9ucy50aW1lckRlbGF5LGluZmluaXRlOmZhbHNlfSxmdW5jdGlvbigpe190aGlzLmNoYW5nZVNsaWRlKHRydWUpO30pO3RoaXMudGltZXIuc3RhcnQoKTt9LyoqXG4gICAgICAqIFNldHMgd3JhcHBlciBhbmQgc2xpZGUgaGVpZ2h0cyBmb3IgdGhlIG9yYml0LlxuICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovfSx7a2V5OidfcHJlcGFyZUZvck9yYml0Jyx2YWx1ZTpmdW5jdGlvbiBfcHJlcGFyZUZvck9yYml0KCl7dmFyIF90aGlzPXRoaXM7dGhpcy5fc2V0V3JhcHBlckhlaWdodChmdW5jdGlvbihtYXgpe190aGlzLl9zZXRTbGlkZUhlaWdodChtYXgpO30pO30vKipcbiAgICAgICogQ2FsdWxhdGVzIHRoZSBoZWlnaHQgb2YgZWFjaCBzbGlkZSBpbiB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgdGhlIHRhbGxlc3Qgb25lIGZvciB0aGUgd3JhcHBlciBoZWlnaHQuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcHJpdmF0ZVxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxuICAgICAgKi99LHtrZXk6J19zZXRXcmFwcGVySGVpZ2h0Jyx2YWx1ZTpmdW5jdGlvbiBfc2V0V3JhcHBlckhlaWdodChjYil7Ly9yZXdyaXRlIHRoaXMgdG8gYGZvcmAgbG9vcFxudmFyIG1heD0wLHRlbXAsY291bnRlcj0wO3RoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uKCl7dGVtcD10aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDskKHRoaXMpLmF0dHIoJ2RhdGEtc2xpZGUnLGNvdW50ZXIpO2lmKGNvdW50ZXIpey8vaWYgbm90IHRoZSBmaXJzdCBzbGlkZSwgc2V0IGNzcyBwb3NpdGlvbiBhbmQgZGlzcGxheSBwcm9wZXJ0eVxuJCh0aGlzKS5jc3Moeydwb3NpdGlvbic6J3JlbGF0aXZlJywnZGlzcGxheSc6J25vbmUnfSk7fW1heD10ZW1wPm1heD90ZW1wOm1heDtjb3VudGVyKys7fSk7aWYoY291bnRlcj09PXRoaXMuJHNsaWRlcy5sZW5ndGgpe3RoaXMuJHdyYXBwZXIuY3NzKHsnaGVpZ2h0JzptYXh9KTsvL29ubHkgY2hhbmdlIHRoZSB3cmFwcGVyIGhlaWdodCBwcm9wZXJ0eSBvbmNlLlxuY2IobWF4KTsvL2ZpcmUgY2FsbGJhY2sgd2l0aCBtYXggaGVpZ2h0IGRpbWVuc2lvbi5cbn19LyoqXG4gICAgICAqIFNldHMgdGhlIG1heC1oZWlnaHQgb2YgZWFjaCBzbGlkZS5cbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqL30se2tleTonX3NldFNsaWRlSGVpZ2h0Jyx2YWx1ZTpmdW5jdGlvbiBfc2V0U2xpZGVIZWlnaHQoaGVpZ2h0KXt0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbigpeyQodGhpcykuY3NzKCdtYXgtaGVpZ2h0JyxoZWlnaHQpO30pO30vKipcbiAgICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgd2l0aGluIHRoZSBlbGVtZW50LlxuICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICogQHByaXZhdGVcbiAgICAgICovfSx7a2V5OidfZXZlbnRzJyx2YWx1ZTpmdW5jdGlvbiBfZXZlbnRzKCl7dmFyIF90aGlzPXRoaXM7Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vKipOb3cgdXNpbmcgY3VzdG9tIGV2ZW50IC0gdGhhbmtzIHRvOioqXG4vLyoqICAgICAgWW9oYWkgQXJhcmF0IG9mIFRvcm9udG8gICAgICAqKlxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbmlmKHRoaXMuJHNsaWRlcy5sZW5ndGg+MSl7aWYodGhpcy5vcHRpb25zLnN3aXBlKXt0aGlzLiRzbGlkZXMub2ZmKCdzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdCcpLm9uKCdzd2lwZWxlZnQuemYub3JiaXQnLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtfdGhpcy5jaGFuZ2VTbGlkZSh0cnVlKTt9KS5vbignc3dpcGVyaWdodC56Zi5vcmJpdCcsZnVuY3Rpb24oZSl7ZS5wcmV2ZW50RGVmYXVsdCgpO190aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTt9KTt9Ly8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbmlmKHRoaXMub3B0aW9ucy5hdXRvUGxheSl7dGhpcy4kc2xpZGVzLm9uKCdjbGljay56Zi5vcmJpdCcsZnVuY3Rpb24oKXtfdGhpcy4kZWxlbWVudC5kYXRhKCdjbGlja2VkT24nLF90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpP2ZhbHNlOnRydWUpO190aGlzLnRpbWVyW190aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpPydwYXVzZSc6J3N0YXJ0J10oKTt9KTtpZih0aGlzLm9wdGlvbnMucGF1c2VPbkhvdmVyKXt0aGlzLiRlbGVtZW50Lm9uKCdtb3VzZWVudGVyLnpmLm9yYml0JyxmdW5jdGlvbigpe190aGlzLnRpbWVyLnBhdXNlKCk7fSkub24oJ21vdXNlbGVhdmUuemYub3JiaXQnLGZ1bmN0aW9uKCl7aWYoIV90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpKXtfdGhpcy50aW1lci5zdGFydCgpO319KTt9fWlmKHRoaXMub3B0aW9ucy5uYXZCdXR0b25zKXt2YXIgJGNvbnRyb2xzPXRoaXMuJGVsZW1lbnQuZmluZCgnLicrdGhpcy5vcHRpb25zLm5leHRDbGFzcysnLCAuJyt0aGlzLm9wdGlvbnMucHJldkNsYXNzKTskY29udHJvbHMuYXR0cigndGFiaW5kZXgnLDApLy9hbHNvIG5lZWQgdG8gaGFuZGxlIGVudGVyL3JldHVybiBhbmQgc3BhY2ViYXIga2V5IHByZXNzZXNcbi5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtfdGhpcy5jaGFuZ2VTbGlkZSgkKHRoaXMpLmhhc0NsYXNzKF90aGlzLm9wdGlvbnMubmV4dENsYXNzKSk7fSk7fWlmKHRoaXMub3B0aW9ucy5idWxsZXRzKXt0aGlzLiRidWxsZXRzLm9uKCdjbGljay56Zi5vcmJpdCB0b3VjaGVuZC56Zi5vcmJpdCcsZnVuY3Rpb24oKXtpZigvaXMtYWN0aXZlL2cudGVzdCh0aGlzLmNsYXNzTmFtZSkpe3JldHVybiBmYWxzZTt9Ly9pZiB0aGlzIGlzIGFjdGl2ZSwga2ljayBvdXQgb2YgZnVuY3Rpb24uXG52YXIgaWR4PSQodGhpcykuZGF0YSgnc2xpZGUnKSxsdHI9aWR4Pl90aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZGF0YSgnc2xpZGUnKSwkc2xpZGU9X3RoaXMuJHNsaWRlcy5lcShpZHgpO190aGlzLmNoYW5nZVNsaWRlKGx0ciwkc2xpZGUsaWR4KTt9KTt9dGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oJ2tleWRvd24uemYub3JiaXQnLGZ1bmN0aW9uKGUpey8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbkZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsJ09yYml0Jyx7bmV4dDpmdW5jdGlvbiBuZXh0KCl7X3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpe190aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTt9LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZCgpey8vIGlmIGJ1bGxldCBpcyBmb2N1c2VkLCBtYWtlIHN1cmUgZm9jdXMgbW92ZXNcbmlmKCQoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSl7X3RoaXMuJGJ1bGxldHMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZm9jdXMoKTt9fX0pO30pO319LyoqXG4gICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2xpZGUgdG8gYSBuZXcgb25lLlxuICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc0xUUiAtIGZsYWcgaWYgdGhlIHNsaWRlIHNob3VsZCBtb3ZlIGxlZnQgdG8gcmlnaHQuXG4gICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBjaG9zZW5TbGlkZSAtIHRoZSBqUXVlcnkgZWxlbWVudCBvZiB0aGUgc2xpZGUgdG8gc2hvdyBuZXh0LCBpZiBvbmUgaXMgc2VsZWN0ZWQuXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIG5ldyBzbGlkZSBpbiBpdHMgY29sbGVjdGlvbiwgaWYgb25lIGNob3Nlbi5cbiAgICAgICogQGZpcmVzIE9yYml0I3NsaWRlY2hhbmdlXG4gICAgICAqL30se2tleTonY2hhbmdlU2xpZGUnLHZhbHVlOmZ1bmN0aW9uIGNoYW5nZVNsaWRlKGlzTFRSLGNob3NlblNsaWRlLGlkeCl7dmFyICRjdXJTbGlkZT10aGlzLiRzbGlkZXMuZmlsdGVyKCcuaXMtYWN0aXZlJykuZXEoMCk7aWYoL211aS9nLnRlc3QoJGN1clNsaWRlWzBdLmNsYXNzTmFtZSkpe3JldHVybiBmYWxzZTt9Ly9pZiB0aGUgc2xpZGUgaXMgY3VycmVudGx5IGFuaW1hdGluZywga2ljayBvdXQgb2YgdGhlIGZ1bmN0aW9uXG52YXIgJGZpcnN0U2xpZGU9dGhpcy4kc2xpZGVzLmZpcnN0KCksJGxhc3RTbGlkZT10aGlzLiRzbGlkZXMubGFzdCgpLGRpckluPWlzTFRSPydSaWdodCc6J0xlZnQnLGRpck91dD1pc0xUUj8nTGVmdCc6J1JpZ2h0JyxfdGhpcz10aGlzLCRuZXdTbGlkZTtpZighY2hvc2VuU2xpZGUpey8vbW9zdCBvZiB0aGUgdGltZSwgdGhpcyB3aWxsIGJlIGF1dG8gcGxheWVkIG9yIGNsaWNrZWQgZnJvbSB0aGUgbmF2QnV0dG9ucy5cbiRuZXdTbGlkZT1pc0xUUj8vL2lmIHdyYXBwaW5nIGVuYWJsZWQsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGBuZXh0YCBvciBgcHJldmAgc2libGluZywgaWYgbm90LCBzZWxlY3QgdGhlIGZpcnN0IG9yIGxhc3Qgc2xpZGUgdG8gZmlsbCBpbi4gaWYgd3JhcHBpbmcgbm90IGVuYWJsZWQsIGF0dGVtcHQgdG8gc2VsZWN0IGBuZXh0YCBvciBgcHJldmAsIGlmIHRoZXJlJ3Mgbm90aGluZyB0aGVyZSwgdGhlIGZ1bmN0aW9uIHdpbGwga2ljayBvdXQgb24gbmV4dCBzdGVwLiBDUkFaWSBORVNURUQgVEVSTkFSSUVTISEhISFcbnRoaXMub3B0aW9ucy5pbmZpbml0ZVdyYXA/JGN1clNsaWRlLm5leHQoJy4nK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGg/JGN1clNsaWRlLm5leHQoJy4nK3RoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTokZmlyc3RTbGlkZTokY3VyU2xpZGUubmV4dCgnLicrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOi8vcGljayBuZXh0IHNsaWRlIGlmIG1vdmluZyBsZWZ0IHRvIHJpZ2h0XG50aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwPyRjdXJTbGlkZS5wcmV2KCcuJyt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoPyRjdXJTbGlkZS5wcmV2KCcuJyt0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk6JGxhc3RTbGlkZTokY3VyU2xpZGUucHJldignLicrdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOy8vcGljayBwcmV2IHNsaWRlIGlmIG1vdmluZyByaWdodCB0byBsZWZ0XG59ZWxzZXskbmV3U2xpZGU9Y2hvc2VuU2xpZGU7fWlmKCRuZXdTbGlkZS5sZW5ndGgpe2lmKHRoaXMub3B0aW9ucy5idWxsZXRzKXtpZHg9aWR4fHx0aGlzLiRzbGlkZXMuaW5kZXgoJG5ld1NsaWRlKTsvL2dyYWIgaW5kZXggdG8gdXBkYXRlIGJ1bGxldHNcbnRoaXMuX3VwZGF0ZUJ1bGxldHMoaWR4KTt9aWYodGhpcy5vcHRpb25zLnVzZU1VSSl7Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKCRuZXdTbGlkZS5hZGRDbGFzcygnaXMtYWN0aXZlJykuY3NzKHsncG9zaXRpb24nOidhYnNvbHV0ZScsJ3RvcCc6MH0pLHRoaXMub3B0aW9uc1snYW5pbUluRnJvbScrZGlySW5dLGZ1bmN0aW9uKCl7JG5ld1NsaWRlLmNzcyh7J3Bvc2l0aW9uJzoncmVsYXRpdmUnLCdkaXNwbGF5JzonYmxvY2snfSkuYXR0cignYXJpYS1saXZlJywncG9saXRlJyk7fSk7Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLHRoaXMub3B0aW9uc1snYW5pbU91dFRvJytkaXJPdXRdLGZ1bmN0aW9uKCl7JGN1clNsaWRlLnJlbW92ZUF0dHIoJ2FyaWEtbGl2ZScpO2lmKF90aGlzLm9wdGlvbnMuYXV0b1BsYXkmJiFfdGhpcy50aW1lci5pc1BhdXNlZCl7X3RoaXMudGltZXIucmVzdGFydCgpO30vL2RvIHN0dWZmP1xufSk7fWVsc2V7JGN1clNsaWRlLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5yZW1vdmVBdHRyKCdhcmlhLWxpdmUnKS5oaWRlKCk7JG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5hdHRyKCdhcmlhLWxpdmUnLCdwb2xpdGUnKS5zaG93KCk7aWYodGhpcy5vcHRpb25zLmF1dG9QbGF5JiYhdGhpcy50aW1lci5pc1BhdXNlZCl7dGhpcy50aW1lci5yZXN0YXJ0KCk7fX0vKipcbiAgICAgICAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4uXG4gICAgICAgICAgKiBAZXZlbnQgT3JiaXQjc2xpZGVjaGFuZ2VcbiAgICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLFskbmV3U2xpZGVdKTt9fS8qKlxuICAgICAgKiBVcGRhdGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGJ1bGxldHMsIGlmIGRpc3BsYXllZC5cbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwcml2YXRlXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgc2xpZGUuXG4gICAgICAqL30se2tleTonX3VwZGF0ZUJ1bGxldHMnLHZhbHVlOmZ1bmN0aW9uIF91cGRhdGVCdWxsZXRzKGlkeCl7dmFyICRvbGRCdWxsZXQ9dGhpcy4kZWxlbWVudC5maW5kKCcuJyt0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKCcuaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmJsdXIoKSxzcGFuPSRvbGRCdWxsZXQuZmluZCgnc3BhbjpsYXN0JykuZGV0YWNoKCksJG5ld0J1bGxldD10aGlzLiRidWxsZXRzLmVxKGlkeCkuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpLmFwcGVuZChzcGFuKTt9LyoqXG4gICAgICAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQuXG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKi99LHtrZXk6J2Rlc3Ryb3knLHZhbHVlOmZ1bmN0aW9uIGRlc3Ryb3koKXt0aGlzLiRlbGVtZW50Lm9mZignLnpmLm9yYml0JykuZmluZCgnKicpLm9mZignLnpmLm9yYml0JykuZW5kKCkuaGlkZSgpO0ZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pO3JldHVybiBPcmJpdDt9KCk7T3JiaXQuZGVmYXVsdHM9ey8qKlxuICAgICogVGVsbHMgdGhlIEpTIHRvIGxvb2sgZm9yIGFuZCBsb2FkQnVsbGV0cy5cbiAgICAqIEBvcHRpb25cbiAgICAqIEBleGFtcGxlIHRydWVcbiAgICAqL2J1bGxldHM6dHJ1ZSwvKipcbiAgICAqIFRlbGxzIHRoZSBKUyB0byBhcHBseSBldmVudCBsaXN0ZW5lcnMgdG8gbmF2IGJ1dHRvbnNcbiAgICAqIEBvcHRpb25cbiAgICAqIEBleGFtcGxlIHRydWVcbiAgICAqL25hdkJ1dHRvbnM6dHJ1ZSwvKipcbiAgICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcbiAgICAqIEBvcHRpb25cbiAgICAqIEBleGFtcGxlICdzbGlkZS1pbi1yaWdodCdcbiAgICAqL2FuaW1JbkZyb21SaWdodDonc2xpZGUtaW4tcmlnaHQnLC8qKlxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgJ3NsaWRlLW91dC1yaWdodCdcbiAgICAqL2FuaW1PdXRUb1JpZ2h0OidzbGlkZS1vdXQtcmlnaHQnLC8qKlxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgJ3NsaWRlLWluLWxlZnQnXG4gICAgKlxuICAgICovYW5pbUluRnJvbUxlZnQ6J3NsaWRlLWluLWxlZnQnLC8qKlxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgJ3NsaWRlLW91dC1sZWZ0J1xuICAgICovYW5pbU91dFRvTGVmdDonc2xpZGUtb3V0LWxlZnQnLC8qKlxuICAgICogQWxsb3dzIE9yYml0IHRvIGF1dG9tYXRpY2FsbHkgYW5pbWF0ZSBvbiBwYWdlIGxvYWQuXG4gICAgKiBAb3B0aW9uXG4gICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgKi9hdXRvUGxheTp0cnVlLC8qKlxuICAgICogQW1vdW50IG9mIHRpbWUsIGluIG1zLCBiZXR3ZWVuIHNsaWRlIHRyYW5zaXRpb25zXG4gICAgKiBAb3B0aW9uXG4gICAgKiBAZXhhbXBsZSA1MDAwXG4gICAgKi90aW1lckRlbGF5OjUwMDAsLyoqXG4gICAgKiBBbGxvd3MgT3JiaXQgdG8gaW5maW5pdGVseSBsb29wIHRocm91Z2ggdGhlIHNsaWRlc1xuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICovaW5maW5pdGVXcmFwOnRydWUsLyoqXG4gICAgKiBBbGxvd3MgdGhlIE9yYml0IHNsaWRlcyB0byBiaW5kIHRvIHN3aXBlIGV2ZW50cyBmb3IgbW9iaWxlLCByZXF1aXJlcyBhbiBhZGRpdGlvbmFsIHV0aWwgbGlicmFyeVxuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICovc3dpcGU6dHJ1ZSwvKipcbiAgICAqIEFsbG93cyB0aGUgdGltaW5nIGZ1bmN0aW9uIHRvIHBhdXNlIGFuaW1hdGlvbiBvbiBob3Zlci5cbiAgICAqIEBvcHRpb25cbiAgICAqIEBleGFtcGxlIHRydWVcbiAgICAqL3BhdXNlT25Ib3Zlcjp0cnVlLC8qKlxuICAgICogQWxsb3dzIE9yYml0IHRvIGJpbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHRoZSBzbGlkZXIsIHRvIGFuaW1hdGUgZnJhbWVzIHdpdGggYXJyb3cga2V5c1xuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICovYWNjZXNzaWJsZTp0cnVlLC8qKlxuICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGFpbmVyIG9mIE9yYml0XG4gICAgKiBAb3B0aW9uXG4gICAgKiBAZXhhbXBsZSAnb3JiaXQtY29udGFpbmVyJ1xuICAgICovY29udGFpbmVyQ2xhc3M6J29yYml0LWNvbnRhaW5lcicsLyoqXG4gICAgKiBDbGFzcyBhcHBsaWVkIHRvIGluZGl2aWR1YWwgc2xpZGVzLlxuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgJ29yYml0LXNsaWRlJ1xuICAgICovc2xpZGVDbGFzczonb3JiaXQtc2xpZGUnLC8qKlxuICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYnVsbGV0IGNvbnRhaW5lci4gWW91J3JlIHdlbGNvbWUuXG4gICAgKiBAb3B0aW9uXG4gICAgKiBAZXhhbXBsZSAnb3JiaXQtYnVsbGV0cydcbiAgICAqL2JveE9mQnVsbGV0czonb3JiaXQtYnVsbGV0cycsLyoqXG4gICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgbmV4dGAgbmF2aWdhdGlvbiBidXR0b24uXG4gICAgKiBAb3B0aW9uXG4gICAgKiBAZXhhbXBsZSAnb3JiaXQtbmV4dCdcbiAgICAqL25leHRDbGFzczonb3JiaXQtbmV4dCcsLyoqXG4gICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBgcHJldmlvdXNgIG5hdmlnYXRpb24gYnV0dG9uLlxuICAgICogQG9wdGlvblxuICAgICogQGV4YW1wbGUgJ29yYml0LXByZXZpb3VzJ1xuICAgICovcHJldkNsYXNzOidvcmJpdC1wcmV2aW91cycsLyoqXG4gICAgKiBCb29sZWFuIHRvIGZsYWcgdGhlIGpzIHRvIHVzZSBtb3Rpb24gdWkgY2xhc3NlcyBvciBub3QuIERlZmF1bHQgdG8gdHJ1ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkuXG4gICAgKiBAb3B0aW9uXG4gICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgKi91c2VNVUk6dHJ1ZX07Ly8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKE9yYml0LCdPcmJpdCcpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogUmVzcG9uc2l2ZU1lbnUgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnVcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1lZGlhUXVlcnlcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5hY2NvcmRpb25NZW51XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuZHJpbGxkb3duXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuZHJvcGRvd24tbWVudVxuICAgKi92YXIgUmVzcG9uc2l2ZU1lbnU9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgcmVzcG9uc2l2ZSBtZW51LlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBSZXNwb25zaXZlTWVudSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhIGRyb3Bkb3duIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIFJlc3BvbnNpdmVNZW51KGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsUmVzcG9uc2l2ZU1lbnUpO3RoaXMuJGVsZW1lbnQ9JChlbGVtZW50KTt0aGlzLnJ1bGVzPXRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS1tZW51Jyk7dGhpcy5jdXJyZW50TXE9bnVsbDt0aGlzLmN1cnJlbnRQbHVnaW49bnVsbDt0aGlzLl9pbml0KCk7dGhpcy5fZXZlbnRzKCk7Rm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCdSZXNwb25zaXZlTWVudScpO30vKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgTWVudSBieSBwYXJzaW5nIHRoZSBjbGFzc2VzIGZyb20gdGhlICdkYXRhLVJlc3BvbnNpdmVNZW51JyBhdHRyaWJ1dGUgb24gdGhlIGVsZW1lbnQuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZU1lbnUsW3trZXk6J19pbml0Jyx2YWx1ZTpmdW5jdGlvbiBfaW5pdCgpey8vIFRoZSBmaXJzdCB0aW1lIGFuIEludGVyY2hhbmdlIHBsdWdpbiBpcyBpbml0aWFsaXplZCwgdGhpcy5ydWxlcyBpcyBjb252ZXJ0ZWQgZnJvbSBhIHN0cmluZyBvZiBcImNsYXNzZXNcIiB0byBhbiBvYmplY3Qgb2YgcnVsZXNcbmlmKHR5cGVvZiB0aGlzLnJ1bGVzPT09J3N0cmluZycpe3ZhciBydWxlc1RyZWU9e307Ly8gUGFyc2UgcnVsZXMgZnJvbSBcImNsYXNzZXNcIiBwdWxsZWQgZnJvbSBkYXRhIGF0dHJpYnV0ZVxudmFyIHJ1bGVzPXRoaXMucnVsZXMuc3BsaXQoJyAnKTsvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgcnVsZSBmb3VuZFxuZm9yKHZhciBpPTA7aTxydWxlcy5sZW5ndGg7aSsrKXt2YXIgcnVsZT1ydWxlc1tpXS5zcGxpdCgnLScpO3ZhciBydWxlU2l6ZT1ydWxlLmxlbmd0aD4xP3J1bGVbMF06J3NtYWxsJzt2YXIgcnVsZVBsdWdpbj1ydWxlLmxlbmd0aD4xP3J1bGVbMV06cnVsZVswXTtpZihNZW51UGx1Z2luc1tydWxlUGx1Z2luXSE9PW51bGwpe3J1bGVzVHJlZVtydWxlU2l6ZV09TWVudVBsdWdpbnNbcnVsZVBsdWdpbl07fX10aGlzLnJ1bGVzPXJ1bGVzVHJlZTt9aWYoISQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSl7dGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTt9fS8qKlxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciB0aGUgTWVudS5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpcz10aGlzOyQod2luZG93KS5vbignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JyxmdW5jdGlvbigpe190aGlzLl9jaGVja01lZGlhUXVlcmllcygpO30pOy8vICQod2luZG93KS5vbigncmVzaXplLnpmLlJlc3BvbnNpdmVNZW51JywgZnVuY3Rpb24oKSB7XG4vLyAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xuLy8gfSk7XG59LyoqXG4gICAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgc2NyZWVuIHdpZHRoIGFnYWluc3QgYXZhaWxhYmxlIG1lZGlhIHF1ZXJpZXMuIElmIHRoZSBtZWRpYSBxdWVyeSBoYXMgY2hhbmdlZCwgYW5kIHRoZSBwbHVnaW4gbmVlZGVkIGhhcyBjaGFuZ2VkLCB0aGUgcGx1Z2lucyB3aWxsIHN3YXAgb3V0LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfY2hlY2tNZWRpYVF1ZXJpZXMnLHZhbHVlOmZ1bmN0aW9uIF9jaGVja01lZGlhUXVlcmllcygpe3ZhciBtYXRjaGVkTXEsX3RoaXM9dGhpczsvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlIGFuZCBmaW5kIHRoZSBsYXN0IG1hdGNoaW5nIHJ1bGVcbiQuZWFjaCh0aGlzLnJ1bGVzLGZ1bmN0aW9uKGtleSl7aWYoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3Qoa2V5KSl7bWF0Y2hlZE1xPWtleTt9fSk7Ly8gTm8gbWF0Y2g/IE5vIGRpY2VcbmlmKCFtYXRjaGVkTXEpcmV0dXJuOy8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXG5pZih0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW21hdGNoZWRNcV0ucGx1Z2luKXJldHVybjsvLyBSZW1vdmUgZXhpc3RpbmcgcGx1Z2luLXNwZWNpZmljIENTUyBjbGFzc2VzXG4kLmVhY2goTWVudVBsdWdpbnMsZnVuY3Rpb24oa2V5LHZhbHVlKXtfdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh2YWx1ZS5jc3NDbGFzcyk7fSk7Ly8gQWRkIHRoZSBDU1MgY2xhc3MgZm9yIHRoZSBuZXcgcGx1Z2luXG50aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5jc3NDbGFzcyk7Ly8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBuZXcgcGx1Z2luXG5pZih0aGlzLmN1cnJlbnRQbHVnaW4pdGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTt0aGlzLmN1cnJlbnRQbHVnaW49bmV3IHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4odGhpcy4kZWxlbWVudCx7fSk7fS8qKlxuICAgICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIHRoZSBjdXJyZW50IHBsdWdpbiBvbiB0aGlzIGVsZW1lbnQsIGFzIHdlbGwgYXMgdGhlIHdpbmRvdyByZXNpemUgaGFuZGxlciB0aGF0IHN3aXRjaGVzIHRoZSBwbHVnaW5zIG91dC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dGhpcy5jdXJyZW50UGx1Z2luLmRlc3Ryb3koKTskKHdpbmRvdykub2ZmKCcuemYuUmVzcG9uc2l2ZU1lbnUnKTtGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gUmVzcG9uc2l2ZU1lbnU7fSgpO1Jlc3BvbnNpdmVNZW51LmRlZmF1bHRzPXt9Oy8vIFRoZSBwbHVnaW4gbWF0Y2hlcyB0aGUgcGx1Z2luIGNsYXNzZXMgd2l0aCB0aGVzZSBwbHVnaW4gaW5zdGFuY2VzLlxudmFyIE1lbnVQbHVnaW5zPXtkcm9wZG93bjp7Y3NzQ2xhc3M6J2Ryb3Bkb3duJyxwbHVnaW46Rm91bmRhdGlvbi5fcGx1Z2luc1snZHJvcGRvd24tbWVudSddfHxudWxsfSxkcmlsbGRvd246e2Nzc0NsYXNzOidkcmlsbGRvd24nLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zWydkcmlsbGRvd24nXXx8bnVsbH0sYWNjb3JkaW9uOntjc3NDbGFzczonYWNjb3JkaW9uLW1lbnUnLHBsdWdpbjpGb3VuZGF0aW9uLl9wbHVnaW5zWydhY2NvcmRpb24tbWVudSddfHxudWxsfX07Ly8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVNZW51LCdSZXNwb25zaXZlTWVudScpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogUmVzcG9uc2l2ZVRvZ2dsZSBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXNwb25zaXZlVG9nZ2xlXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKi92YXIgUmVzcG9uc2l2ZVRvZ2dsZT1mdW5jdGlvbigpey8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgVGFiIEJhci5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZVRvZ2dsZSNpbml0XG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCB0YWIgYmFyIGZ1bmN0aW9uYWxpdHkgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIFJlc3BvbnNpdmVUb2dnbGUoZWxlbWVudCxvcHRpb25zKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxSZXNwb25zaXZlVG9nZ2xlKTt0aGlzLiRlbGVtZW50PSQoZWxlbWVudCk7dGhpcy5vcHRpb25zPSQuZXh0ZW5kKHt9LFJlc3BvbnNpdmVUb2dnbGUuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO3RoaXMuX2V2ZW50cygpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnUmVzcG9uc2l2ZVRvZ2dsZScpO30vKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdGFiIGJhciBieSBmaW5kaW5nIHRoZSB0YXJnZXQgZWxlbWVudCwgdG9nZ2xpbmcgZWxlbWVudCwgYW5kIHJ1bm5pbmcgdXBkYXRlKCkuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZVRvZ2dsZSxbe2tleTonX2luaXQnLHZhbHVlOmZ1bmN0aW9uIF9pbml0KCl7dmFyIHRhcmdldElEPXRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS10b2dnbGUnKTtpZighdGFyZ2V0SUQpe2NvbnNvbGUuZXJyb3IoJ1lvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci4nKTt9dGhpcy4kdGFyZ2V0TWVudT0kKCcjJyt0YXJnZXRJRCk7dGhpcy4kdG9nZ2xlcj10aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRvZ2dsZV0nKTt0aGlzLl91cGRhdGUoKTt9LyoqXG4gICAgICAgKiBBZGRzIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyBmb3IgdGhlIHRhYiBiYXIgdG8gd29yay5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpcz10aGlzO3RoaXMuX3VwZGF0ZU1xSGFuZGxlcj10aGlzLl91cGRhdGUuYmluZCh0aGlzKTskKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTt0aGlzLiR0b2dnbGVyLm9uKCdjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlJyx0aGlzLnRvZ2dsZU1lbnUuYmluZCh0aGlzKSk7fS8qKlxuICAgICAgICogQ2hlY2tzIHRoZSBjdXJyZW50IG1lZGlhIHF1ZXJ5IHRvIGRldGVybWluZSBpZiB0aGUgdGFiIGJhciBzaG91bGQgYmUgdmlzaWJsZSBvciBoaWRkZW4uXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J191cGRhdGUnLHZhbHVlOmZ1bmN0aW9uIF91cGRhdGUoKXsvLyBNb2JpbGVcbmlmKCFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpe3RoaXMuJGVsZW1lbnQuc2hvdygpO3RoaXMuJHRhcmdldE1lbnUuaGlkZSgpO30vLyBEZXNrdG9wXG5lbHNle3RoaXMuJGVsZW1lbnQuaGlkZSgpO3RoaXMuJHRhcmdldE1lbnUuc2hvdygpO319LyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyLiBUaGUgdG9nZ2xlIG9ubHkgaGFwcGVucyBpZiB0aGUgc2NyZWVuIGlzIHNtYWxsIGVub3VnaCB0byBhbGxvdyBpdC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjdG9nZ2xlZFxuICAgICAgICovfSx7a2V5Oid0b2dnbGVNZW51Jyx2YWx1ZTpmdW5jdGlvbiB0b2dnbGVNZW51KCl7aWYoIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSl7dGhpcy4kdGFyZ2V0TWVudS50b2dnbGUoMCk7LyoqXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZWxlbWVudCBhdHRhY2hlZCB0byB0aGUgdGFiIGJhciB0b2dnbGVzLlxuICAgICAgICAgICAqIEBldmVudCBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcbiAgICAgICAgICAgKi90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3RvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZScpO319fSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dGhpcy4kZWxlbWVudC5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7dGhpcy4kdG9nZ2xlci5vZmYoJy56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7JCh3aW5kb3cpLm9mZignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5Jyx0aGlzLl91cGRhdGVNcUhhbmRsZXIpO0ZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pO3JldHVybiBSZXNwb25zaXZlVG9nZ2xlO30oKTtSZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzPXsvKipcbiAgICAgKiBUaGUgYnJlYWtwb2ludCBhZnRlciB3aGljaCB0aGUgbWVudSBpcyBhbHdheXMgc2hvd24sIGFuZCB0aGUgdGFiIGJhciBpcyBoaWRkZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdtZWRpdW0nXG4gICAgICovaGlkZUZvcjonbWVkaXVtJ307Ly8gV2luZG93IGV4cG9ydHNcbkZvdW5kYXRpb24ucGx1Z2luKFJlc3BvbnNpdmVUb2dnbGUsJ1Jlc3BvbnNpdmVUb2dnbGUnKTt9KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcz1mdW5jdGlvbigpe2Z1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LHByb3BzKXtmb3IodmFyIGk9MDtpPHByb3BzLmxlbmd0aDtpKyspe3ZhciBkZXNjcmlwdG9yPXByb3BzW2ldO2Rlc2NyaXB0b3IuZW51bWVyYWJsZT1kZXNjcmlwdG9yLmVudW1lcmFibGV8fGZhbHNlO2Rlc2NyaXB0b3IuY29uZmlndXJhYmxlPXRydWU7aWYoXCJ2YWx1ZVwiaW4gZGVzY3JpcHRvcilkZXNjcmlwdG9yLndyaXRhYmxlPXRydWU7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCxkZXNjcmlwdG9yLmtleSxkZXNjcmlwdG9yKTt9fXJldHVybiBmdW5jdGlvbihDb25zdHJ1Y3Rvcixwcm90b1Byb3BzLHN0YXRpY1Byb3BzKXtpZihwcm90b1Byb3BzKWRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLHByb3RvUHJvcHMpO2lmKHN0YXRpY1Byb3BzKWRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3Isc3RhdGljUHJvcHMpO3JldHVybiBDb25zdHJ1Y3Rvcjt9O30oKTshZnVuY3Rpb24oJCl7LyoqXG4gICAqIFJldmVhbCBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5yZXZlYWxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvbiBpZiB1c2luZyBhbmltYXRpb25zXG4gICAqL3ZhciBSZXZlYWw9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJldmVhbC5cbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gdXNlIGZvciB0aGUgbW9kYWwuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25hbCBwYXJhbWV0ZXJzLlxuICAgICAqL2Z1bmN0aW9uIFJldmVhbChlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLFJldmVhbCk7dGhpcy4kZWxlbWVudD1lbGVtZW50O3RoaXMub3B0aW9ucz0kLmV4dGVuZCh7fSxSZXZlYWwuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnUmV2ZWFsJyk7Rm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignUmV2ZWFsJyx7J0VOVEVSJzonb3BlbicsJ1NQQUNFJzonb3BlbicsJ0VTQ0FQRSc6J2Nsb3NlJywnVEFCJzondGFiX2ZvcndhcmQnLCdTSElGVF9UQUInOid0YWJfYmFja3dhcmQnfSk7fS8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBtb2RhbCBieSBhZGRpbmcgdGhlIG92ZXJsYXkgYW5kIGNsb3NlIGJ1dHRvbnMsIChpZiBzZWxlY3RlZCkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoUmV2ZWFsLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt0aGlzLmlkPXRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTt0aGlzLmlzQWN0aXZlPWZhbHNlO3RoaXMuY2FjaGVkPXttcTpGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudH07dGhpcy5pc01vYmlsZT1tb2JpbGVTbmlmZigpO3RoaXMuJGFuY2hvcj0kKCdbZGF0YS1vcGVuPVwiJyt0aGlzLmlkKydcIl0nKS5sZW5ndGg/JCgnW2RhdGEtb3Blbj1cIicrdGhpcy5pZCsnXCJdJyk6JCgnW2RhdGEtdG9nZ2xlPVwiJyt0aGlzLmlkKydcIl0nKTt0aGlzLiRhbmNob3IuYXR0cih7J2FyaWEtY29udHJvbHMnOnRoaXMuaWQsJ2FyaWEtaGFzcG9wdXAnOnRydWUsJ3RhYmluZGV4JzowfSk7aWYodGhpcy5vcHRpb25zLmZ1bGxTY3JlZW58fHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Z1bGwnKSl7dGhpcy5vcHRpb25zLmZ1bGxTY3JlZW49dHJ1ZTt0aGlzLm9wdGlvbnMub3ZlcmxheT1mYWxzZTt9aWYodGhpcy5vcHRpb25zLm92ZXJsYXkmJiF0aGlzLiRvdmVybGF5KXt0aGlzLiRvdmVybGF5PXRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpO310aGlzLiRlbGVtZW50LmF0dHIoeydyb2xlJzonZGlhbG9nJywnYXJpYS1oaWRkZW4nOnRydWUsJ2RhdGEteWV0aS1ib3gnOnRoaXMuaWQsJ2RhdGEtcmVzaXplJzp0aGlzLmlkfSk7aWYodGhpcy4kb3ZlcmxheSl7dGhpcy4kZWxlbWVudC5kZXRhY2goKS5hcHBlbmRUbyh0aGlzLiRvdmVybGF5KTt9ZWxzZXt0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKCQoJ2JvZHknKSk7dGhpcy4kZWxlbWVudC5hZGRDbGFzcygnd2l0aG91dC1vdmVybGF5Jyk7fXRoaXMuX2V2ZW50cygpO2lmKHRoaXMub3B0aW9ucy5kZWVwTGluayYmd2luZG93LmxvY2F0aW9uLmhhc2g9PT0nIycrdGhpcy5pZCl7JCh3aW5kb3cpLm9uZSgnbG9hZC56Zi5yZXZlYWwnLHRoaXMub3Blbi5iaW5kKHRoaXMpKTt9fS8qKlxuICAgICAgICogQ3JlYXRlcyBhbiBvdmVybGF5IGRpdiB0byBkaXNwbGF5IGJlaGluZCB0aGUgbW9kYWwuXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfbWFrZU92ZXJsYXknLHZhbHVlOmZ1bmN0aW9uIF9tYWtlT3ZlcmxheShpZCl7dmFyICRvdmVybGF5PSQoJzxkaXY+PC9kaXY+JykuYWRkQ2xhc3MoJ3JldmVhbC1vdmVybGF5JykuYXBwZW5kVG8oJ2JvZHknKTtyZXR1cm4gJG92ZXJsYXk7fS8qKlxuICAgICAgICogVXBkYXRlcyBwb3NpdGlvbiBvZiBtb2RhbFxuICAgICAgICogVE9ETzogIEZpZ3VyZSBvdXQgaWYgd2UgYWN0dWFsbHkgbmVlZCB0byBjYWNoZSB0aGVzZSB2YWx1ZXMgb3IgaWYgaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J191cGRhdGVQb3NpdGlvbicsdmFsdWU6ZnVuY3Rpb24gX3VwZGF0ZVBvc2l0aW9uKCl7dmFyIHdpZHRoPXRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpO3ZhciBvdXRlcldpZHRoPSQod2luZG93KS53aWR0aCgpO3ZhciBoZWlnaHQ9dGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpO3ZhciBvdXRlckhlaWdodD0kKHdpbmRvdykuaGVpZ2h0KCk7dmFyIGxlZnQsdG9wO2lmKHRoaXMub3B0aW9ucy5oT2Zmc2V0PT09J2F1dG8nKXtsZWZ0PXBhcnNlSW50KChvdXRlcldpZHRoLXdpZHRoKS8yLDEwKTt9ZWxzZXtsZWZ0PXBhcnNlSW50KHRoaXMub3B0aW9ucy5oT2Zmc2V0LDEwKTt9aWYodGhpcy5vcHRpb25zLnZPZmZzZXQ9PT0nYXV0bycpe2lmKGhlaWdodD5vdXRlckhlaWdodCl7dG9wPXBhcnNlSW50KE1hdGgubWluKDEwMCxvdXRlckhlaWdodC8xMCksMTApO31lbHNle3RvcD1wYXJzZUludCgob3V0ZXJIZWlnaHQtaGVpZ2h0KS80LDEwKTt9fWVsc2V7dG9wPXBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LDEwKTt9dGhpcy4kZWxlbWVudC5jc3Moe3RvcDp0b3ArJ3B4J30pOy8vIG9ubHkgd29ycnkgYWJvdXQgbGVmdCBpZiB3ZSBkb24ndCBoYXZlIGFuIG92ZXJsYXkgb3Igd2UgaGF2ZWEgIGhvcml6b250YWwgb2Zmc2V0LFxuLy8gb3RoZXJ3aXNlIHdlJ3JlIHBlcmZlY3RseSBpbiB0aGUgbWlkZGxlXG5pZighdGhpcy4kb3ZlcmxheXx8dGhpcy5vcHRpb25zLmhPZmZzZXQhPT0nYXV0bycpe3RoaXMuJGVsZW1lbnQuY3NzKHtsZWZ0OmxlZnQrJ3B4J30pO3RoaXMuJGVsZW1lbnQuY3NzKHttYXJnaW46JzBweCd9KTt9fS8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIG1vZGFsLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3ZhciBfdGhpczI9dGhpczt2YXIgX3RoaXM9dGhpczt0aGlzLiRlbGVtZW50Lm9uKHsnb3Blbi56Zi50cmlnZ2VyJzp0aGlzLm9wZW4uYmluZCh0aGlzKSwnY2xvc2UuemYudHJpZ2dlcic6ZnVuY3Rpb24gY2xvc2VaZlRyaWdnZXIoZXZlbnQsJGVsZW1lbnQpe2lmKGV2ZW50LnRhcmdldD09PV90aGlzLiRlbGVtZW50WzBdfHwkKGV2ZW50LnRhcmdldCkucGFyZW50cygnW2RhdGEtY2xvc2FibGVdJylbMF09PT0kZWxlbWVudCl7Ly8gb25seSBjbG9zZSByZXZlYWwgd2hlbiBpdCdzIGV4cGxpY2l0bHkgY2FsbGVkXG5yZXR1cm4gX3RoaXMyLmNsb3NlLmFwcGx5KF90aGlzMik7fX0sJ3RvZ2dsZS56Zi50cmlnZ2VyJzp0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLCdyZXNpemVtZS56Zi50cmlnZ2VyJzpmdW5jdGlvbiByZXNpemVtZVpmVHJpZ2dlcigpe190aGlzLl91cGRhdGVQb3NpdGlvbigpO319KTtpZih0aGlzLiRhbmNob3IubGVuZ3RoKXt0aGlzLiRhbmNob3Iub24oJ2tleWRvd24uemYucmV2ZWFsJyxmdW5jdGlvbihlKXtpZihlLndoaWNoPT09MTN8fGUud2hpY2g9PT0zMil7ZS5zdG9wUHJvcGFnYXRpb24oKTtlLnByZXZlbnREZWZhdWx0KCk7X3RoaXMub3BlbigpO319KTt9aWYodGhpcy5vcHRpb25zLmNsb3NlT25DbGljayYmdGhpcy5vcHRpb25zLm92ZXJsYXkpe3RoaXMuJG92ZXJsYXkub2ZmKCcuemYucmV2ZWFsJykub24oJ2NsaWNrLnpmLnJldmVhbCcsZnVuY3Rpb24oZSl7aWYoZS50YXJnZXQ9PT1fdGhpcy4kZWxlbWVudFswXXx8JC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSxlLnRhcmdldCkpe3JldHVybjt9X3RoaXMuY2xvc2UoKTt9KTt9aWYodGhpcy5vcHRpb25zLmRlZXBMaW5rKXskKHdpbmRvdykub24oJ3BvcHN0YXRlLnpmLnJldmVhbDonK3RoaXMuaWQsdGhpcy5faGFuZGxlU3RhdGUuYmluZCh0aGlzKSk7fX0vKipcbiAgICAgICAqIEhhbmRsZXMgbW9kYWwgbWV0aG9kcyBvbiBiYWNrL2ZvcndhcmQgYnV0dG9uIGNsaWNrcyBvciBhbnkgb3RoZXIgZXZlbnQgdGhhdCB0cmlnZ2VycyBwb3BzdGF0ZS5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19oYW5kbGVTdGF0ZScsdmFsdWU6ZnVuY3Rpb24gX2hhbmRsZVN0YXRlKGUpe2lmKHdpbmRvdy5sb2NhdGlvbi5oYXNoPT09JyMnK3RoaXMuaWQmJiF0aGlzLmlzQWN0aXZlKXt0aGlzLm9wZW4oKTt9ZWxzZXt0aGlzLmNsb3NlKCk7fX0vKipcbiAgICAgICAqIE9wZW5zIHRoZSBtb2RhbCBjb250cm9sbGVkIGJ5IGB0aGlzLiRhbmNob3JgLCBhbmQgY2xvc2VzIGFsbCBvdGhlcnMgYnkgZGVmYXVsdC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIFJldmVhbCNjbG9zZW1lXG4gICAgICAgKiBAZmlyZXMgUmV2ZWFsI29wZW5cbiAgICAgICAqL30se2tleTonb3BlbicsdmFsdWU6ZnVuY3Rpb24gb3Blbigpe3ZhciBfdGhpczM9dGhpcztpZih0aGlzLm9wdGlvbnMuZGVlcExpbmspe3ZhciBoYXNoPScjJyt0aGlzLmlkO2lmKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSl7d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsbnVsbCxoYXNoKTt9ZWxzZXt3aW5kb3cubG9jYXRpb24uaGFzaD1oYXNoO319dGhpcy5pc0FjdGl2ZT10cnVlOy8vIE1ha2UgZWxlbWVudHMgaW52aXNpYmxlLCBidXQgcmVtb3ZlIGRpc3BsYXk6IG5vbmUgc28gd2UgY2FuIGdldCBzaXplIGFuZCBwb3NpdGlvbmluZ1xudGhpcy4kZWxlbWVudC5jc3Moeyd2aXNpYmlsaXR5JzonaGlkZGVuJ30pLnNob3coKS5zY3JvbGxUb3AoMCk7aWYodGhpcy5vcHRpb25zLm92ZXJsYXkpe3RoaXMuJG92ZXJsYXkuY3NzKHsndmlzaWJpbGl0eSc6J2hpZGRlbid9KS5zaG93KCk7fXRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7dGhpcy4kZWxlbWVudC5oaWRlKCkuY3NzKHsndmlzaWJpbGl0eSc6Jyd9KTtpZih0aGlzLiRvdmVybGF5KXt0aGlzLiRvdmVybGF5LmNzcyh7J3Zpc2liaWxpdHknOicnfSkuaGlkZSgpO2lmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Zhc3QnKSl7dGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnZmFzdCcpO31lbHNlIGlmKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3Nsb3cnKSl7dGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnc2xvdycpO319aWYoIXRoaXMub3B0aW9ucy5tdWx0aXBsZU9wZW5lZCl7LyoqXG4gICAgICAgICAgICogRmlyZXMgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBtb2RhbCBvcGVucy5cbiAgICAgICAgICAgKiBDbG9zZXMgYW55IG90aGVyIG1vZGFscyB0aGF0IGFyZSBjdXJyZW50bHkgb3BlblxuICAgICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VtZVxuICAgICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VtZS56Zi5yZXZlYWwnLHRoaXMuaWQpO30vLyBNb3Rpb24gVUkgbWV0aG9kIG9mIHJldmVhbFxuaWYodGhpcy5vcHRpb25zLmFuaW1hdGlvbkluKXt2YXIgX3RoaXM7KGZ1bmN0aW9uKCl7dmFyIGFmdGVyQW5pbWF0aW9uRm9jdXM9ZnVuY3Rpb24gYWZ0ZXJBbmltYXRpb25Gb2N1cygpe190aGlzLiRlbGVtZW50LmF0dHIoeydhcmlhLWhpZGRlbic6ZmFsc2UsJ3RhYmluZGV4JzotMX0pLmZvY3VzKCk7Y29uc29sZS5sb2coJ2ZvY3VzJyk7fTtfdGhpcz1fdGhpczM7aWYoX3RoaXMzLm9wdGlvbnMub3ZlcmxheSl7Rm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKF90aGlzMy4kb3ZlcmxheSwnZmFkZS1pbicpO31Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oX3RoaXMzLiRlbGVtZW50LF90aGlzMy5vcHRpb25zLmFuaW1hdGlvbkluLGZ1bmN0aW9uKCl7X3RoaXMzLmZvY3VzYWJsZUVsZW1lbnRzPUZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShfdGhpczMuJGVsZW1lbnQpO2FmdGVyQW5pbWF0aW9uRm9jdXMoKTt9KTt9KSgpO30vLyBqUXVlcnkgbWV0aG9kIG9mIHJldmVhbFxuZWxzZXtpZih0aGlzLm9wdGlvbnMub3ZlcmxheSl7dGhpcy4kb3ZlcmxheS5zaG93KDApO310aGlzLiRlbGVtZW50LnNob3codGhpcy5vcHRpb25zLnNob3dEZWxheSk7fS8vIGhhbmRsZSBhY2Nlc3NpYmlsaXR5XG50aGlzLiRlbGVtZW50LmF0dHIoeydhcmlhLWhpZGRlbic6ZmFsc2UsJ3RhYmluZGV4JzotMX0pLmZvY3VzKCk7LyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGhhcyBzdWNjZXNzZnVsbHkgb3BlbmVkLlxuICAgICAgICAgKiBAZXZlbnQgUmV2ZWFsI29wZW5cbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvcGVuLnpmLnJldmVhbCcpO2lmKHRoaXMuaXNNb2JpbGUpe3RoaXMub3JpZ2luYWxTY3JvbGxQb3M9d2luZG93LnBhZ2VZT2Zmc2V0OyQoJ2h0bWwsIGJvZHknKS5hZGRDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTt9ZWxzZXskKCdib2R5JykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7fXNldFRpbWVvdXQoZnVuY3Rpb24oKXtfdGhpczMuX2V4dHJhSGFuZGxlcnMoKTt9LDApO30vKipcbiAgICAgICAqIEFkZHMgZXh0cmEgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBib2R5IGFuZCB3aW5kb3cgaWYgbmVjZXNzYXJ5LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V4dHJhSGFuZGxlcnMnLHZhbHVlOmZ1bmN0aW9uIF9leHRyYUhhbmRsZXJzKCl7dmFyIF90aGlzPXRoaXM7dGhpcy5mb2N1c2FibGVFbGVtZW50cz1Gb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7aWYoIXRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrJiYhdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4peyQoJ2JvZHknKS5vbignY2xpY2suemYucmV2ZWFsJyxmdW5jdGlvbihlKXtpZihlLnRhcmdldD09PV90aGlzLiRlbGVtZW50WzBdfHwkLmNvbnRhaW5zKF90aGlzLiRlbGVtZW50WzBdLGUudGFyZ2V0KSl7cmV0dXJuO31fdGhpcy5jbG9zZSgpO30pO31pZih0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyl7JCh3aW5kb3cpLm9uKCdrZXlkb3duLnpmLnJldmVhbCcsZnVuY3Rpb24oZSl7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoZSwnUmV2ZWFsJyx7Y2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtpZihfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2Mpe190aGlzLmNsb3NlKCk7X3RoaXMuJGFuY2hvci5mb2N1cygpO319fSk7fSk7fS8vIGxvY2sgZm9jdXMgd2l0aGluIG1vZGFsIHdoaWxlIHRhYmJpbmdcbnRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uemYucmV2ZWFsJyxmdW5jdGlvbihlKXt2YXIgJHRhcmdldD0kKHRoaXMpOy8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbkZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsJ1JldmVhbCcse3RhYl9mb3J3YXJkOmZ1bmN0aW9uIHRhYl9mb3J3YXJkKCl7aWYoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXMoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpKSl7Ly8gbGVmdCBtb2RhbCBkb3dud2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxuX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkuZm9jdXMoKTtyZXR1cm4gdHJ1ZTt9aWYoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoPT09MCl7Ly8gbm8gZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSB0aGUgbW9kYWwgYXQgYWxsLCBwcmV2ZW50IHRhYmJpbmcgaW4gZ2VuZXJhbFxucmV0dXJuIHRydWU7fX0sdGFiX2JhY2t3YXJkOmZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpe2lmKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApKXx8X3RoaXMuJGVsZW1lbnQuaXMoJzpmb2N1cycpKXsvLyBsZWZ0IG1vZGFsIHVwd2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gbGFzdCBlbGVtZW50XG5fdGhpcy5mb2N1c2FibGVFbGVtZW50cy5lcSgtMSkuZm9jdXMoKTtyZXR1cm4gdHJ1ZTt9aWYoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoPT09MCl7Ly8gbm8gZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSB0aGUgbW9kYWwgYXQgYWxsLCBwcmV2ZW50IHRhYmJpbmcgaW4gZ2VuZXJhbFxucmV0dXJuIHRydWU7fX0sb3BlbjpmdW5jdGlvbiBvcGVuKCl7aWYoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXMoX3RoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtY2xvc2VdJykpKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Ly8gc2V0IGZvY3VzIGJhY2sgdG8gYW5jaG9yIGlmIGNsb3NlIGJ1dHRvbiBoYXMgYmVlbiBhY3RpdmF0ZWRcbl90aGlzLiRhbmNob3IuZm9jdXMoKTt9LDEpO31lbHNlIGlmKCR0YXJnZXQuaXMoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMpKXsvLyBkb250J3QgdHJpZ2dlciBpZiBhY3VhbCBlbGVtZW50IGhhcyBmb2N1cyAoaS5lLiBpbnB1dHMsIGxpbmtzLCAuLi4pXG5fdGhpcy5vcGVuKCk7fX0sY2xvc2U6ZnVuY3Rpb24gY2xvc2UoKXtpZihfdGhpcy5vcHRpb25zLmNsb3NlT25Fc2Mpe190aGlzLmNsb3NlKCk7X3RoaXMuJGFuY2hvci5mb2N1cygpO319LGhhbmRsZWQ6ZnVuY3Rpb24gaGFuZGxlZChwcmV2ZW50RGVmYXVsdCl7aWYocHJldmVudERlZmF1bHQpe2UucHJldmVudERlZmF1bHQoKTt9fX0pO30pO30vKipcbiAgICAgICAqIENsb3NlcyB0aGUgbW9kYWwuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBmaXJlcyBSZXZlYWwjY2xvc2VkXG4gICAgICAgKi99LHtrZXk6J2Nsb3NlJyx2YWx1ZTpmdW5jdGlvbiBjbG9zZSgpe2lmKCF0aGlzLmlzQWN0aXZlfHwhdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSl7cmV0dXJuIGZhbHNlO312YXIgX3RoaXM9dGhpczsvLyBNb3Rpb24gVUkgbWV0aG9kIG9mIGhpZGluZ1xuaWYodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCl7aWYodGhpcy5vcHRpb25zLm92ZXJsYXkpe0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kb3ZlcmxheSwnZmFkZS1vdXQnLGZpbmlzaFVwKTt9ZWxzZXtmaW5pc2hVcCgpO31Gb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCk7fS8vIGpRdWVyeSBtZXRob2Qgb2YgaGlkaW5nXG5lbHNle2lmKHRoaXMub3B0aW9ucy5vdmVybGF5KXt0aGlzLiRvdmVybGF5LmhpZGUoMCxmaW5pc2hVcCk7fWVsc2V7ZmluaXNoVXAoKTt9dGhpcy4kZWxlbWVudC5oaWRlKHRoaXMub3B0aW9ucy5oaWRlRGVsYXkpO30vLyBDb25kaXRpb25hbHMgdG8gcmVtb3ZlIGV4dHJhIGV2ZW50IGxpc3RlbmVycyBhZGRlZCBvbiBvcGVuXG5pZih0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYyl7JCh3aW5kb3cpLm9mZigna2V5ZG93bi56Zi5yZXZlYWwnKTt9aWYoIXRoaXMub3B0aW9ucy5vdmVybGF5JiZ0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKXskKCdib2R5Jykub2ZmKCdjbGljay56Zi5yZXZlYWwnKTt9dGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uemYucmV2ZWFsJyk7ZnVuY3Rpb24gZmluaXNoVXAoKXtpZihfdGhpcy5pc01vYmlsZSl7JCgnaHRtbCwgYm9keScpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO2lmKF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zKXskKCdib2R5Jykuc2Nyb2xsVG9wKF90aGlzLm9yaWdpbmFsU2Nyb2xsUG9zKTtfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcz1udWxsO319ZWxzZXskKCdib2R5JykucmVtb3ZlQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7fV90aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJyx0cnVlKTsvKipcbiAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1vZGFsIGlzIGRvbmUgY2xvc2luZy5cbiAgICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VkXG4gICAgICAgICAgKi9fdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYucmV2ZWFsJyk7fS8qKlxuICAgICAgICAqIFJlc2V0cyB0aGUgbW9kYWwgY29udGVudFxuICAgICAgICAqIFRoaXMgcHJldmVudHMgYSBydW5uaW5nIHZpZGVvIHRvIGtlZXAgZ29pbmcgaW4gdGhlIGJhY2tncm91bmRcbiAgICAgICAgKi9pZih0aGlzLm9wdGlvbnMucmVzZXRPbkNsb3NlKXt0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy4kZWxlbWVudC5odG1sKCkpO310aGlzLmlzQWN0aXZlPWZhbHNlO2lmKF90aGlzLm9wdGlvbnMuZGVlcExpbmspe2lmKHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSl7d2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFwiXCIsZG9jdW1lbnQudGl0bGUsd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKTt9ZWxzZXt3aW5kb3cubG9jYXRpb24uaGFzaD0nJzt9fX0vKipcbiAgICAgICAqIFRvZ2dsZXMgdGhlIG9wZW4vY2xvc2VkIHN0YXRlIG9mIGEgbW9kYWwuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTondG9nZ2xlJyx2YWx1ZTpmdW5jdGlvbiB0b2dnbGUoKXtpZih0aGlzLmlzQWN0aXZlKXt0aGlzLmNsb3NlKCk7fWVsc2V7dGhpcy5vcGVuKCk7fX19LHtrZXk6J2Rlc3Ryb3knLC8qKlxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbC5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe2lmKHRoaXMub3B0aW9ucy5vdmVybGF5KXt0aGlzLiRlbGVtZW50LmFwcGVuZFRvKCQoJ2JvZHknKSk7Ly8gbW92ZSAkZWxlbWVudCBvdXRzaWRlIG9mICRvdmVybGF5IHRvIHByZXZlbnQgZXJyb3IgdW5yZWdpc3RlclBsdWdpbigpXG50aGlzLiRvdmVybGF5LmhpZGUoKS5vZmYoKS5yZW1vdmUoKTt9dGhpcy4kZWxlbWVudC5oaWRlKCkub2ZmKCk7dGhpcy4kYW5jaG9yLm9mZignLnpmJyk7JCh3aW5kb3cpLm9mZignLnpmLnJldmVhbDonK3RoaXMuaWQpO0ZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTt9fV0pO3JldHVybiBSZXZlYWw7fSgpO1JldmVhbC5kZWZhdWx0cz17LyoqXG4gICAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NsaWRlLWluLWxlZnQnXG4gICAgICovYW5pbWF0aW9uSW46JycsLyoqXG4gICAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3NsaWRlLW91dC1yaWdodCdcbiAgICAgKi9hbmltYXRpb25PdXQ6JycsLyoqXG4gICAgICogVGltZSwgaW4gbXMsIHRvIGRlbGF5IHRoZSBvcGVuaW5nIG9mIGEgbW9kYWwgYWZ0ZXIgYSBjbGljayBpZiBubyBhbmltYXRpb24gdXNlZC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMTBcbiAgICAgKi9zaG93RGVsYXk6MCwvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgdG8gZGVsYXkgdGhlIGNsb3Npbmcgb2YgYSBtb2RhbCBhZnRlciBhIGNsaWNrIGlmIG5vIGFuaW1hdGlvbiB1c2VkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMFxuICAgICAqL2hpZGVEZWxheTowLC8qKlxuICAgICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5L292ZXJsYXkgdG8gY2xvc2UgdGhlIG1vZGFsLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovY2xvc2VPbkNsaWNrOnRydWUsLyoqXG4gICAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBjbG9zZSBpZiB0aGUgdXNlciBwcmVzc2VzIHRoZSBgRVNDQVBFYCBrZXkuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9jbG9zZU9uRXNjOnRydWUsLyoqXG4gICAgICogSWYgdHJ1ZSwgYWxsb3dzIG11bHRpcGxlIG1vZGFscyB0byBiZSBkaXNwbGF5ZWQgYXQgb25jZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9tdWx0aXBsZU9wZW5lZDpmYWxzZSwvKipcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggZG93biBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgYXV0b1xuICAgICAqL3ZPZmZzZXQ6J2F1dG8nLC8qKlxuICAgICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSBtb2RhbCBzaG91bGQgcHVzaCBpbiBmcm9tIHRoZSBzaWRlIG9mIHRoZSBzY3JlZW4uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGF1dG9cbiAgICAgKi9oT2Zmc2V0OidhdXRvJywvKipcbiAgICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGJlIGZ1bGxzY3JlZW4sIGNvbXBsZXRlbHkgYmxvY2tpbmcgb3V0IHRoZSByZXN0IG9mIHRoZSB2aWV3LiBKUyBjaGVja3MgZm9yIHRoaXMgYXMgd2VsbC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9mdWxsU2NyZWVuOmZhbHNlLC8qKlxuICAgICAqIFBlcmNlbnRhZ2Ugb2Ygc2NyZWVuIGhlaWdodCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggdXAgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMFxuICAgICAqL2J0bU9mZnNldFBjdDoxMCwvKipcbiAgICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIGdlbmVyYXRlIGFuIG92ZXJsYXkgZGl2LCB3aGljaCB3aWxsIGNvdmVyIHRoZSB2aWV3IHdoZW4gbW9kYWwgb3BlbnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9vdmVybGF5OnRydWUsLyoqXG4gICAgICogQWxsb3dzIHRoZSBtb2RhbCB0byByZW1vdmUgYW5kIHJlaW5qZWN0IG1hcmt1cCBvbiBjbG9zZS4gU2hvdWxkIGJlIHRydWUgaWYgdXNpbmcgdmlkZW8gZWxlbWVudHMgdy9vIHVzaW5nIHByb3ZpZGVyJ3MgYXBpLCBvdGhlcndpc2UsIHZpZGVvcyB3aWxsIGNvbnRpbnVlIHRvIHBsYXkgaW4gdGhlIGJhY2tncm91bmQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovcmVzZXRPbkNsb3NlOmZhbHNlLC8qKlxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYWx0ZXIgdGhlIHVybCBvbiBvcGVuL2Nsb3NlLCBhbmQgYWxsb3dzIHRoZSB1c2Ugb2YgdGhlIGBiYWNrYCBidXR0b24gdG8gY2xvc2UgbW9kYWxzLiBBTFNPLCBhbGxvd3MgYSBtb2RhbCB0byBhdXRvLW1hbmlhY2FsbHkgb3BlbiBvbiBwYWdlIGxvYWQgSUYgdGhlIGhhc2ggPT09IHRoZSBtb2RhbCdzIHVzZXItc2V0IGlkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL2RlZXBMaW5rOmZhbHNlfTsvLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oUmV2ZWFsLCdSZXZlYWwnKTtmdW5jdGlvbiBpUGhvbmVTbmlmZigpe3JldHVybiAvaVAoYWR8aG9uZXxvZCkuKk9TLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTt9ZnVuY3Rpb24gYW5kcm9pZFNuaWZmKCl7cmV0dXJuIC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTt9ZnVuY3Rpb24gbW9iaWxlU25pZmYoKXtyZXR1cm4gaVBob25lU25pZmYoKXx8YW5kcm9pZFNuaWZmKCk7fX0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogU2xpZGVyIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLnNsaWRlclxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxuICAgKi92YXIgU2xpZGVyPWZ1bmN0aW9uKCl7LyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyaWxsZG93biBtZW51LlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIFNsaWRlcihlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLFNsaWRlcik7dGhpcy4kZWxlbWVudD1lbGVtZW50O3RoaXMub3B0aW9ucz0kLmV4dGVuZCh7fSxTbGlkZXIuZGVmYXVsdHMsdGhpcy4kZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5faW5pdCgpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnU2xpZGVyJyk7Rm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignU2xpZGVyJyx7J2x0cic6eydBUlJPV19SSUdIVCc6J2luY3JlYXNlJywnQVJST1dfVVAnOidpbmNyZWFzZScsJ0FSUk9XX0RPV04nOidkZWNyZWFzZScsJ0FSUk9XX0xFRlQnOidkZWNyZWFzZScsJ1NISUZUX0FSUk9XX1JJR0hUJzonaW5jcmVhc2VfZmFzdCcsJ1NISUZUX0FSUk9XX1VQJzonaW5jcmVhc2VfZmFzdCcsJ1NISUZUX0FSUk9XX0RPV04nOidkZWNyZWFzZV9mYXN0JywnU0hJRlRfQVJST1dfTEVGVCc6J2RlY3JlYXNlX2Zhc3QnfSwncnRsJzp7J0FSUk9XX0xFRlQnOidpbmNyZWFzZScsJ0FSUk9XX1JJR0hUJzonZGVjcmVhc2UnLCdTSElGVF9BUlJPV19MRUZUJzonaW5jcmVhc2VfZmFzdCcsJ1NISUZUX0FSUk9XX1JJR0hUJzonZGVjcmVhc2VfZmFzdCd9fSk7fS8qKlxuICAgICAqIEluaXRpbGl6ZXMgdGhlIHBsdWdpbiBieSByZWFkaW5nL3NldHRpbmcgYXR0cmlidXRlcywgY3JlYXRpbmcgY29sbGVjdGlvbnMgYW5kIHNldHRpbmcgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGhhbmRsZShzKS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhTbGlkZXIsW3trZXk6J19pbml0Jyx2YWx1ZTpmdW5jdGlvbiBfaW5pdCgpe3RoaXMuaW5wdXRzPXRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKTt0aGlzLmhhbmRsZXM9dGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItaGFuZGxlXScpO3RoaXMuJGhhbmRsZT10aGlzLmhhbmRsZXMuZXEoMCk7dGhpcy4kaW5wdXQ9dGhpcy5pbnB1dHMubGVuZ3RoP3RoaXMuaW5wdXRzLmVxKDApOiQoJyMnK3RoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLWNvbnRyb2xzJykpO3RoaXMuJGZpbGw9dGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zbGlkZXItZmlsbF0nKS5jc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsPydoZWlnaHQnOid3aWR0aCcsMCk7dmFyIGlzRGJsPWZhbHNlLF90aGlzPXRoaXM7aWYodGhpcy5vcHRpb25zLmRpc2FibGVkfHx0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSl7dGhpcy5vcHRpb25zLmRpc2FibGVkPXRydWU7dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZGlzYWJsZWRDbGFzcyk7fWlmKCF0aGlzLmlucHV0cy5sZW5ndGgpe3RoaXMuaW5wdXRzPSQoKS5hZGQodGhpcy4kaW5wdXQpO3RoaXMub3B0aW9ucy5iaW5kaW5nPXRydWU7fXRoaXMuX3NldEluaXRBdHRyKDApO3RoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUpO2lmKHRoaXMuaGFuZGxlc1sxXSl7dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkPXRydWU7dGhpcy4kaGFuZGxlMj10aGlzLmhhbmRsZXMuZXEoMSk7dGhpcy4kaW5wdXQyPXRoaXMuaW5wdXRzLmxlbmd0aD4xP3RoaXMuaW5wdXRzLmVxKDEpOiQoJyMnK3RoaXMuJGhhbmRsZTIuYXR0cignYXJpYS1jb250cm9scycpKTtpZighdGhpcy5pbnB1dHNbMV0pe3RoaXMuaW5wdXRzPXRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpO31pc0RibD10cnVlO3RoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCx0cnVlLGZ1bmN0aW9uKCl7X3RoaXMuX3NldEhhbmRsZVBvcyhfdGhpcy4kaGFuZGxlMixfdGhpcy5vcHRpb25zLmluaXRpYWxFbmQsdHJ1ZSk7fSk7Ly8gdGhpcy4kaGFuZGxlLnRyaWdnZXJIYW5kbGVyKCdjbGljay56Zi5zbGlkZXInKTtcbnRoaXMuX3NldEluaXRBdHRyKDEpO3RoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUyKTt9aWYoIWlzRGJsKXt0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsdHJ1ZSk7fX0vKipcbiAgICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzZWxlY3RlZCBoYW5kbGUgYW5kIGZpbGwgYmFyLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRobmRsIC0gdGhlIHNlbGVjdGVkIGhhbmRsZSB0byBtb3ZlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gZmxvYXRpbmcgcG9pbnQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgb2YgdGhlIHNsaWRlciBiYXIuXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbi5cbiAgICAgICAqIEBmaXJlcyBTbGlkZXIjbW92ZWRcbiAgICAgICAqIEBmaXJlcyBTbGlkZXIjY2hhbmdlZFxuICAgICAgICovfSx7a2V5Oidfc2V0SGFuZGxlUG9zJyx2YWx1ZTpmdW5jdGlvbiBfc2V0SGFuZGxlUG9zKCRobmRsLGxvY2F0aW9uLG5vSW52ZXJ0LGNiKXsvLyBkb24ndCBtb3ZlIGlmIHRoZSBzbGlkZXIgaGFzIGJlZW4gZGlzYWJsZWQgc2luY2UgaXRzIGluaXRpYWxpemF0aW9uXG5pZih0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSl7cmV0dXJuO30vL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXG5sb2NhdGlvbj1wYXJzZUZsb2F0KGxvY2F0aW9uKTsvL29uIGlucHV0IGNoYW5nZSBldmVudHMsIGNvbnZlcnQgc3RyaW5nIHRvIG51bWJlci4uLmdydW1ibGUuXG4vLyBwcmV2ZW50IHNsaWRlciBmcm9tIHJ1bm5pbmcgb3V0IG9mIGJvdW5kcywgaWYgdmFsdWUgZXhjZWVkcyB0aGUgbGltaXRzIHNldCB0aHJvdWdoIG9wdGlvbnMsIG92ZXJyaWRlIHRoZSB2YWx1ZSB0byBtaW4vbWF4XG5pZihsb2NhdGlvbjx0aGlzLm9wdGlvbnMuc3RhcnQpe2xvY2F0aW9uPXRoaXMub3B0aW9ucy5zdGFydDt9ZWxzZSBpZihsb2NhdGlvbj50aGlzLm9wdGlvbnMuZW5kKXtsb2NhdGlvbj10aGlzLm9wdGlvbnMuZW5kO312YXIgaXNEYmw9dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkO2lmKGlzRGJsKXsvL3RoaXMgYmxvY2sgaXMgdG8gcHJldmVudCAyIGhhbmRsZXMgZnJvbSBjcm9zc2luZyBlYWNob3RoZXIuIENvdWxkL3Nob3VsZCBiZSBpbXByb3ZlZC5cbmlmKHRoaXMuaGFuZGxlcy5pbmRleCgkaG5kbCk9PT0wKXt2YXIgaDJWYWw9cGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7bG9jYXRpb249bG9jYXRpb24+PWgyVmFsP2gyVmFsLXRoaXMub3B0aW9ucy5zdGVwOmxvY2F0aW9uO31lbHNle3ZhciBoMVZhbD1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO2xvY2F0aW9uPWxvY2F0aW9uPD1oMVZhbD9oMVZhbCt0aGlzLm9wdGlvbnMuc3RlcDpsb2NhdGlvbjt9fS8vdGhpcyBpcyBmb3Igc2luZ2xlLWhhbmRsZWQgdmVydGljYWwgc2xpZGVycywgaXQgYWRqdXN0cyB0aGUgdmFsdWUgdG8gYWNjb3VudCBmb3IgdGhlIHNsaWRlciBiZWluZyBcInVwc2lkZS1kb3duXCJcbi8vZm9yIGNsaWNrIGFuZCBkcmFnIGV2ZW50cywgaXQncyB3ZWlyZCBkdWUgdG8gdGhlIHNjYWxlKC0xLCAxKSBjc3MgcHJvcGVydHlcbmlmKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmIW5vSW52ZXJ0KXtsb2NhdGlvbj10aGlzLm9wdGlvbnMuZW5kLWxvY2F0aW9uO312YXIgX3RoaXM9dGhpcyx2ZXJ0PXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxoT3JXPXZlcnQ/J2hlaWdodCc6J3dpZHRoJyxsT3JUPXZlcnQ/J3RvcCc6J2xlZnQnLGhhbmRsZURpbT0kaG5kbFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtoT3JXXSxlbGVtRGltPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaE9yV10sLy9wZXJjZW50YWdlIG9mIGJhciBtaW4vbWF4IHZhbHVlIGJhc2VkIG9uIGNsaWNrIG9yIGRyYWcgcG9pbnRcbnBjdE9mQmFyPXBlcmNlbnQobG9jYXRpb24tdGhpcy5vcHRpb25zLnN0YXJ0LHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KS50b0ZpeGVkKDIpLC8vbnVtYmVyIG9mIGFjdHVhbCBwaXhlbHMgdG8gc2hpZnQgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2J0YWluZWQgYWJvdmVcbnB4VG9Nb3ZlPShlbGVtRGltLWhhbmRsZURpbSkqcGN0T2ZCYXIsLy9wZXJjZW50YWdlIG9mIGJhciB0byBzaGlmdCB0aGUgaGFuZGxlXG5tb3ZlbWVudD0ocGVyY2VudChweFRvTW92ZSxlbGVtRGltKSoxMDApLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpOy8vZml4aW5nIHRoZSBkZWNpbWFsIHZhbHVlIGZvciB0aGUgbG9jYXRpb24gbnVtYmVyLCBpcyBwYXNzZWQgdG8gb3RoZXIgbWV0aG9kcyBhcyBhIGZpeGVkIGZsb2F0aW5nLXBvaW50IHZhbHVlXG5sb2NhdGlvbj1wYXJzZUZsb2F0KGxvY2F0aW9uLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpKTsvLyBkZWNsYXJlIGVtcHR5IG9iamVjdCBmb3IgY3NzIGFkanVzdG1lbnRzLCBvbmx5IHVzZWQgd2l0aCAyIGhhbmRsZWQtc2xpZGVyc1xudmFyIGNzcz17fTt0aGlzLl9zZXRWYWx1ZXMoJGhuZGwsbG9jYXRpb24pOy8vIFRPRE8gdXBkYXRlIHRvIGNhbGN1bGF0ZSBiYXNlZCBvbiB2YWx1ZXMgc2V0IHRvIHJlc3BlY3RpdmUgaW5wdXRzPz9cbmlmKGlzRGJsKXt2YXIgaXNMZWZ0SG5kbD10aGlzLmhhbmRsZXMuaW5kZXgoJGhuZGwpPT09MCwvL2VtcHR5IHZhcmlhYmxlLCB3aWxsIGJlIHVzZWQgZm9yIG1pbi1oZWlnaHQvd2lkdGggZm9yIGZpbGwgYmFyXG5kaW0sLy9wZXJjZW50YWdlIHcvaCBvZiB0aGUgaGFuZGxlIGNvbXBhcmVkIHRvIHRoZSBzbGlkZXIgYmFyXG5oYW5kbGVQY3Q9fn4ocGVyY2VudChoYW5kbGVEaW0sZWxlbURpbSkqMTAwKTsvL2lmIGxlZnQgaGFuZGxlLCB0aGUgbWF0aCBpcyBzbGlnaHRseSBkaWZmZXJlbnQgdGhhbiBpZiBpdCdzIHRoZSByaWdodCBoYW5kbGUsIGFuZCB0aGUgbGVmdC90b3AgcHJvcGVydHkgbmVlZHMgdG8gYmUgY2hhbmdlZCBmb3IgdGhlIGZpbGwgYmFyXG5pZihpc0xlZnRIbmRsKXsvL2xlZnQgb3IgdG9wIHBlcmNlbnRhZ2UgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIGZpbGwgYmFyLlxuY3NzW2xPclRdPW1vdmVtZW50KyclJzsvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci5cbmRpbT1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZTJbMF0uc3R5bGVbbE9yVF0pLW1vdmVtZW50K2hhbmRsZVBjdDsvL3RoaXMgY2FsbGJhY2sgaXMgbmVjZXNzYXJ5IHRvIHByZXZlbnQgZXJyb3JzIGFuZCBhbGxvdyB0aGUgcHJvcGVyIHBsYWNlbWVudCBhbmQgaW5pdGlhbGl6YXRpb24gb2YgYSAyLWhhbmRsZWQgc2xpZGVyXG4vL3BsdXMsIGl0IG1lYW5zIHdlIGRvbid0IGNhcmUgaWYgJ2RpbScgaXNOYU4gb24gaW5pdCwgaXQgd29uJ3QgYmUgaW4gdGhlIGZ1dHVyZS5cbmlmKGNiJiZ0eXBlb2YgY2I9PT0nZnVuY3Rpb24nKXtjYigpO30vL3RoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBpbml0aWFsaXphdGlvbiBvZiAyIGhhbmRsZWQgc2xpZGVyc1xufWVsc2V7Ly9qdXN0IGNhY2hpbmcgdGhlIHZhbHVlIG9mIHRoZSBsZWZ0L2JvdHRvbSBoYW5kbGUncyBsZWZ0L3RvcCBwcm9wZXJ0eVxudmFyIGhhbmRsZVBvcz1wYXJzZUZsb2F0KHRoaXMuJGhhbmRsZVswXS5zdHlsZVtsT3JUXSk7Ly9jYWxjdWxhdGUgdGhlIG5ldyBtaW4taGVpZ2h0L3dpZHRoIGZvciB0aGUgZmlsbCBiYXIuIFVzZSBpc05hTiB0byBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcyBmb3IgbnVtYmVycyA8PSAwXG4vL2Jhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9mIG1vdmVtZW50IG9mIHRoZSBoYW5kbGUgYmVpbmcgbWFuaXB1bGF0ZWQsIGxlc3MgdGhlIG9wcG9zaW5nIGhhbmRsZSdzIGxlZnQvdG9wIHBvc2l0aW9uLCBwbHVzIHRoZSBwZXJjZW50YWdlIHcvaCBvZiB0aGUgaGFuZGxlIGl0c2VsZlxuZGltPW1vdmVtZW50LShpc05hTihoYW5kbGVQb3MpP3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQvKCh0aGlzLm9wdGlvbnMuZW5kLXRoaXMub3B0aW9ucy5zdGFydCkvMTAwKTpoYW5kbGVQb3MpK2hhbmRsZVBjdDt9Ly8gYXNzaWduIHRoZSBtaW4taGVpZ2h0L3dpZHRoIHRvIG91ciBjc3Mgb2JqZWN0XG5jc3NbJ21pbi0nK2hPclddPWRpbSsnJSc7fXRoaXMuJGVsZW1lbnQub25lKCdmaW5pc2hlZC56Zi5hbmltYXRlJyxmdW5jdGlvbigpey8qKlxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhhbmRsZSBpcyBkb25lIG1vdmluZy5cbiAgICAgICAgICAgKiBAZXZlbnQgU2xpZGVyI21vdmVkXG4gICAgICAgICAgICovX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignbW92ZWQuemYuc2xpZGVyJyxbJGhuZGxdKTt9KTsvL2JlY2F1c2Ugd2UgZG9uJ3Qga25vdyBleGFjdGx5IGhvdyB0aGUgaGFuZGxlIHdpbGwgYmUgbW92ZWQsIGNoZWNrIHRoZSBhbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byBtb3ZlLlxudmFyIG1vdmVUaW1lPXRoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKT8xMDAwLzYwOnRoaXMub3B0aW9ucy5tb3ZlVGltZTtGb3VuZGF0aW9uLk1vdmUobW92ZVRpbWUsJGhuZGwsZnVuY3Rpb24oKXsvL2FkanVzdGluZyB0aGUgbGVmdC90b3AgcHJvcGVydHkgb2YgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2UgY2FsY3VsYXRlZCBhYm92ZVxuJGhuZGwuY3NzKGxPclQsbW92ZW1lbnQrJyUnKTtpZighX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCl7Ly9pZiBzaW5nbGUtaGFuZGxlZCwgYSBzaW1wbGUgbWV0aG9kIHRvIGV4cGFuZCB0aGUgZmlsbCBiYXJcbl90aGlzLiRmaWxsLmNzcyhoT3JXLHBjdE9mQmFyKjEwMCsnJScpO31lbHNley8vb3RoZXJ3aXNlLCB1c2UgdGhlIGNzcyBvYmplY3Qgd2UgY3JlYXRlZCBhYm92ZVxuX3RoaXMuJGZpbGwuY3NzKGNzcyk7fX0pOy8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB2YWx1ZSBoYXMgbm90IGJlZW4gY2hhbmdlIGZvciBhIGdpdmVuIHRpbWUuXG4gICAgICAgICAqIEBldmVudCBTbGlkZXIjY2hhbmdlZFxuICAgICAgICAgKi9jbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7X3RoaXMudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7X3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZC56Zi5zbGlkZXInLFskaG5kbF0pO30sX3RoaXMub3B0aW9ucy5jaGFuZ2VkRGVsYXkpO30vKipcbiAgICAgICAqIFNldHMgdGhlIGluaXRpYWwgYXR0cmlidXRlIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlIGN1cnJlbnQgaGFuZGxlL2lucHV0IHRvIHVzZS5cbiAgICAgICAqL30se2tleTonX3NldEluaXRBdHRyJyx2YWx1ZTpmdW5jdGlvbiBfc2V0SW5pdEF0dHIoaWR4KXt2YXIgaWQ9dGhpcy5pbnB1dHMuZXEoaWR4KS5hdHRyKCdpZCcpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsJ3NsaWRlcicpO3RoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cih7J2lkJzppZCwnbWF4Jzp0aGlzLm9wdGlvbnMuZW5kLCdtaW4nOnRoaXMub3B0aW9ucy5zdGFydCwnc3RlcCc6dGhpcy5vcHRpb25zLnN0ZXB9KTt0aGlzLmhhbmRsZXMuZXEoaWR4KS5hdHRyKHsncm9sZSc6J3NsaWRlcicsJ2FyaWEtY29udHJvbHMnOmlkLCdhcmlhLXZhbHVlbWF4Jzp0aGlzLm9wdGlvbnMuZW5kLCdhcmlhLXZhbHVlbWluJzp0aGlzLm9wdGlvbnMuc3RhcnQsJ2FyaWEtdmFsdWVub3cnOmlkeD09PTA/dGhpcy5vcHRpb25zLmluaXRpYWxTdGFydDp0aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCwnYXJpYS1vcmllbnRhdGlvbic6dGhpcy5vcHRpb25zLnZlcnRpY2FsPyd2ZXJ0aWNhbCc6J2hvcml6b250YWwnLCd0YWJpbmRleCc6MH0pO30vKipcbiAgICAgICAqIFNldHMgdGhlIGlucHV0IGFuZCBgYXJpYS12YWx1ZW5vd2AgdmFsdWVzIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaGFuZGxlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIGZsb2F0aW5nIHBvaW50IG9mIHRoZSBuZXcgdmFsdWUuXG4gICAgICAgKi99LHtrZXk6J19zZXRWYWx1ZXMnLHZhbHVlOmZ1bmN0aW9uIF9zZXRWYWx1ZXMoJGhhbmRsZSx2YWwpe3ZhciBpZHg9dGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkP3RoaXMuaGFuZGxlcy5pbmRleCgkaGFuZGxlKTowO3RoaXMuaW5wdXRzLmVxKGlkeCkudmFsKHZhbCk7JGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93Jyx2YWwpO30vKipcbiAgICAgICAqIEhhbmRsZXMgZXZlbnRzIG9uIHRoZSBzbGlkZXIgZWxlbWVudC5cbiAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG5ldyBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBoYW5kbGUuXG4gICAgICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50IGhhbmRsZSB0byBjYWxjdWxhdGUgZm9yLCBpZiBzZWxlY3RlZC5cbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBudW1iZXIgZm9yIHRoZSBuZXcgdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICAgICAqIFRPRE8gY2xlYW4gdGhpcyB1cCwgdGhlcmUncyBhIGxvdCBvZiByZXBlYXRlZCBjb2RlIGJldHdlZW4gdGhpcyBhbmQgdGhlIF9zZXRIYW5kbGVQb3MgZm4uXG4gICAgICAgKi99LHtrZXk6J19oYW5kbGVFdmVudCcsdmFsdWU6ZnVuY3Rpb24gX2hhbmRsZUV2ZW50KGUsJGhhbmRsZSx2YWwpe3ZhciB2YWx1ZSxoYXNWYWw7aWYoIXZhbCl7Ly9jbGljayBvciBkcmFnIGV2ZW50c1xuZS5wcmV2ZW50RGVmYXVsdCgpO3ZhciBfdGhpcz10aGlzLHZlcnRpY2FsPXRoaXMub3B0aW9ucy52ZXJ0aWNhbCxwYXJhbT12ZXJ0aWNhbD8naGVpZ2h0Jzond2lkdGgnLGRpcmVjdGlvbj12ZXJ0aWNhbD8ndG9wJzonbGVmdCcsZXZlbnRPZmZzZXQ9dmVydGljYWw/ZS5wYWdlWTplLnBhZ2VYLGhhbGZPZkhhbmRsZT10aGlzLiRoYW5kbGVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dLzIsYmFyRGltPXRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbcGFyYW1dLHdpbmRvd1Njcm9sbD12ZXJ0aWNhbD8kKHdpbmRvdykuc2Nyb2xsVG9wKCk6JCh3aW5kb3cpLnNjcm9sbExlZnQoKTt2YXIgZWxlbU9mZnNldD10aGlzLiRlbGVtZW50Lm9mZnNldCgpW2RpcmVjdGlvbl07Ly8gdG91Y2ggZXZlbnRzIGVtdWxhdGVkIGJ5IHRoZSB0b3VjaCB1dGlsIGdpdmUgcG9zaXRpb24gcmVsYXRpdmUgdG8gc2NyZWVuLCBhZGQgd2luZG93LnNjcm9sbCB0byBldmVudCBjb29yZGluYXRlcy4uLlxuLy8gYmVzdCB3YXkgdG8gZ3Vlc3MgdGhpcyBpcyBzaW11bGF0ZWQgaXMgaWYgY2xpZW50WSA9PSBwYWdlWVxuaWYoZS5jbGllbnRZPT09ZS5wYWdlWSl7ZXZlbnRPZmZzZXQ9ZXZlbnRPZmZzZXQrd2luZG93U2Nyb2xsO312YXIgZXZlbnRGcm9tQmFyPWV2ZW50T2Zmc2V0LWVsZW1PZmZzZXQ7dmFyIGJhclhZO2lmKGV2ZW50RnJvbUJhcjwwKXtiYXJYWT0wO31lbHNlIGlmKGV2ZW50RnJvbUJhcj5iYXJEaW0pe2JhclhZPWJhckRpbTt9ZWxzZXtiYXJYWT1ldmVudEZyb21CYXI7fW9mZnNldFBjdD1wZXJjZW50KGJhclhZLGJhckRpbSk7dmFsdWU9KHRoaXMub3B0aW9ucy5lbmQtdGhpcy5vcHRpb25zLnN0YXJ0KSpvZmZzZXRQY3QrdGhpcy5vcHRpb25zLnN0YXJ0Oy8vIHR1cm4gZXZlcnl0aGluZyBhcm91bmQgZm9yIFJUTCwgeWF5IG1hdGghXG5pZihGb3VuZGF0aW9uLnJ0bCgpJiYhdGhpcy5vcHRpb25zLnZlcnRpY2FsKXt2YWx1ZT10aGlzLm9wdGlvbnMuZW5kLXZhbHVlO312YWx1ZT1fdGhpcy5fYWRqdXN0VmFsdWUobnVsbCx2YWx1ZSk7Ly9ib29sZWFuIGZsYWcgZm9yIHRoZSBzZXRIYW5kbGVQb3MgZm4sIHNwZWNpZmljYWxseSBmb3IgdmVydGljYWwgc2xpZGVyc1xuaGFzVmFsPWZhbHNlO2lmKCEkaGFuZGxlKXsvL2ZpZ3VyZSBvdXQgd2hpY2ggaGFuZGxlIGl0IGlzLCBwYXNzIGl0IHRvIHRoZSBuZXh0IGZ1bmN0aW9uLlxudmFyIGZpcnN0SG5kbFBvcz1hYnNQb3NpdGlvbih0aGlzLiRoYW5kbGUsZGlyZWN0aW9uLGJhclhZLHBhcmFtKSxzZWNuZEhuZGxQb3M9YWJzUG9zaXRpb24odGhpcy4kaGFuZGxlMixkaXJlY3Rpb24sYmFyWFkscGFyYW0pOyRoYW5kbGU9Zmlyc3RIbmRsUG9zPD1zZWNuZEhuZGxQb3M/dGhpcy4kaGFuZGxlOnRoaXMuJGhhbmRsZTI7fX1lbHNley8vY2hhbmdlIGV2ZW50IG9uIGlucHV0XG52YWx1ZT10aGlzLl9hZGp1c3RWYWx1ZShudWxsLHZhbCk7aGFzVmFsPXRydWU7fXRoaXMuX3NldEhhbmRsZVBvcygkaGFuZGxlLHZhbHVlLGhhc1ZhbCk7fS8qKlxuICAgICAgICogQWRqdXN0ZXMgdmFsdWUgZm9yIGhhbmRsZSBpbiByZWdhcmQgdG8gc3RlcCB2YWx1ZS4gcmV0dXJucyBhZGp1c3RlZCB2YWx1ZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgc2VsZWN0ZWQgaGFuZGxlLlxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIC0gdmFsdWUgdG8gYWRqdXN0LiB1c2VkIGlmICRoYW5kbGUgaXMgZmFsc3lcbiAgICAgICAqL30se2tleTonX2FkanVzdFZhbHVlJyx2YWx1ZTpmdW5jdGlvbiBfYWRqdXN0VmFsdWUoJGhhbmRsZSx2YWx1ZSl7dmFyIHZhbCxzdGVwPXRoaXMub3B0aW9ucy5zdGVwLGRpdj1wYXJzZUZsb2F0KHN0ZXAvMiksbGVmdCxwcmV2X3ZhbCxuZXh0X3ZhbDtpZighISRoYW5kbGUpe3ZhbD1wYXJzZUZsb2F0KCRoYW5kbGUuYXR0cignYXJpYS12YWx1ZW5vdycpKTt9ZWxzZXt2YWw9dmFsdWU7fWxlZnQ9dmFsJXN0ZXA7cHJldl92YWw9dmFsLWxlZnQ7bmV4dF92YWw9cHJldl92YWwrc3RlcDtpZihsZWZ0PT09MCl7cmV0dXJuIHZhbDt9dmFsPXZhbD49cHJldl92YWwrZGl2P25leHRfdmFsOnByZXZfdmFsO3JldHVybiB2YWw7fS8qKlxuICAgICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNsaWRlciBlbGVtZW50cy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkaGFuZGxlIC0gdGhlIGN1cnJlbnQgaGFuZGxlIHRvIGFwcGx5IGxpc3RlbmVycyB0by5cbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygkaGFuZGxlKXt2YXIgX3RoaXM9dGhpcyxjdXJIYW5kbGUsdGltZXI7dGhpcy5pbnB1dHMub2ZmKCdjaGFuZ2UuemYuc2xpZGVyJykub24oJ2NoYW5nZS56Zi5zbGlkZXInLGZ1bmN0aW9uKGUpe3ZhciBpZHg9X3RoaXMuaW5wdXRzLmluZGV4KCQodGhpcykpO190aGlzLl9oYW5kbGVFdmVudChlLF90aGlzLmhhbmRsZXMuZXEoaWR4KSwkKHRoaXMpLnZhbCgpKTt9KTtpZih0aGlzLm9wdGlvbnMuY2xpY2tTZWxlY3Qpe3RoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbGlkZXInKS5vbignY2xpY2suemYuc2xpZGVyJyxmdW5jdGlvbihlKXtpZihfdGhpcy4kZWxlbWVudC5kYXRhKCdkcmFnZ2luZycpKXtyZXR1cm4gZmFsc2U7fWlmKCEkKGUudGFyZ2V0KS5pcygnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKSl7aWYoX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCl7X3RoaXMuX2hhbmRsZUV2ZW50KGUpO31lbHNle190aGlzLl9oYW5kbGVFdmVudChlLF90aGlzLiRoYW5kbGUpO319fSk7fWlmKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpe3RoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO3ZhciAkYm9keT0kKCdib2R5Jyk7JGhhbmRsZS5vZmYoJ21vdXNlZG93bi56Zi5zbGlkZXInKS5vbignbW91c2Vkb3duLnpmLnNsaWRlcicsZnVuY3Rpb24oZSl7JGhhbmRsZS5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTtfdGhpcy4kZmlsbC5hZGRDbGFzcygnaXMtZHJhZ2dpbmcnKTsvL1xuX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLHRydWUpO2N1ckhhbmRsZT0kKGUuY3VycmVudFRhcmdldCk7JGJvZHkub24oJ21vdXNlbW92ZS56Zi5zbGlkZXInLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtfdGhpcy5faGFuZGxlRXZlbnQoZSxjdXJIYW5kbGUpO30pLm9uKCdtb3VzZXVwLnpmLnNsaWRlcicsZnVuY3Rpb24oZSl7X3RoaXMuX2hhbmRsZUV2ZW50KGUsY3VySGFuZGxlKTskaGFuZGxlLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO190aGlzLiRmaWxsLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO190aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJyxmYWxzZSk7JGJvZHkub2ZmKCdtb3VzZW1vdmUuemYuc2xpZGVyIG1vdXNldXAuemYuc2xpZGVyJyk7fSk7fSkvLyBwcmV2ZW50IGV2ZW50cyB0cmlnZ2VyZWQgYnkgdG91Y2hcbi5vbignc2VsZWN0c3RhcnQuemYuc2xpZGVyIHRvdWNobW92ZS56Zi5zbGlkZXInLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTt9KTt9JGhhbmRsZS5vZmYoJ2tleWRvd24uemYuc2xpZGVyJykub24oJ2tleWRvd24uemYuc2xpZGVyJyxmdW5jdGlvbihlKXt2YXIgXyRoYW5kbGU9JCh0aGlzKSxpZHg9X3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZD9fdGhpcy5oYW5kbGVzLmluZGV4KF8kaGFuZGxlKTowLG9sZFZhbHVlPXBhcnNlRmxvYXQoX3RoaXMuaW5wdXRzLmVxKGlkeCkudmFsKCkpLG5ld1ZhbHVlOy8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbkZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsJ1NsaWRlcicse2RlY3JlYXNlOmZ1bmN0aW9uIGRlY3JlYXNlKCl7bmV3VmFsdWU9b2xkVmFsdWUtX3RoaXMub3B0aW9ucy5zdGVwO30saW5jcmVhc2U6ZnVuY3Rpb24gaW5jcmVhc2UoKXtuZXdWYWx1ZT1vbGRWYWx1ZStfdGhpcy5vcHRpb25zLnN0ZXA7fSxkZWNyZWFzZV9mYXN0OmZ1bmN0aW9uIGRlY3JlYXNlX2Zhc3QoKXtuZXdWYWx1ZT1vbGRWYWx1ZS1fdGhpcy5vcHRpb25zLnN0ZXAqMTA7fSxpbmNyZWFzZV9mYXN0OmZ1bmN0aW9uIGluY3JlYXNlX2Zhc3QoKXtuZXdWYWx1ZT1vbGRWYWx1ZStfdGhpcy5vcHRpb25zLnN0ZXAqMTA7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXsvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XG5lLnByZXZlbnREZWZhdWx0KCk7X3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSxuZXdWYWx1ZSx0cnVlKTt9fSk7LyppZiAobmV3VmFsdWUpIHsgLy8gaWYgcHJlc3NlZCBrZXkgaGFzIHNwZWNpYWwgZnVuY3Rpb24sIHVwZGF0ZSB2YWx1ZVxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgX3RoaXMuX3NldEhhbmRsZVBvcyhfJGhhbmRsZSwgbmV3VmFsdWUpO1xuICAgICAgICAgIH0qL30pO30vKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBzbGlkZXIgcGx1Z2luLlxuICAgICAgICovfSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dGhpcy5oYW5kbGVzLm9mZignLnpmLnNsaWRlcicpO3RoaXMuaW5wdXRzLm9mZignLnpmLnNsaWRlcicpO3RoaXMuJGVsZW1lbnQub2ZmKCcuemYuc2xpZGVyJyk7Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSk7cmV0dXJuIFNsaWRlcjt9KCk7U2xpZGVyLmRlZmF1bHRzPXsvKipcbiAgICAgKiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAwXG4gICAgICovc3RhcnQ6MCwvKipcbiAgICAgKiBNYXhpbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxMDBcbiAgICAgKi9lbmQ6MTAwLC8qKlxuICAgICAqIE1pbmltdW0gdmFsdWUgY2hhbmdlIHBlciBjaGFuZ2UgZXZlbnQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDFcbiAgICAgKi9zdGVwOjEsLyoqXG4gICAgICogVmFsdWUgYXQgd2hpY2ggdGhlIGhhbmRsZS9pbnB1dCAqKGxlZnQgaGFuZGxlL2ZpcnN0IGlucHV0KSogc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMFxuICAgICAqL2luaXRpYWxTdGFydDowLC8qKlxuICAgICAqIFZhbHVlIGF0IHdoaWNoIHRoZSByaWdodCBoYW5kbGUvc2Vjb25kIGlucHV0IHNob3VsZCBiZSBzZXQgdG8gb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDEwMFxuICAgICAqL2luaXRpYWxFbmQ6MTAwLC8qKlxuICAgICAqIEFsbG93cyB0aGUgaW5wdXQgdG8gYmUgbG9jYXRlZCBvdXRzaWRlIHRoZSBjb250YWluZXIgYW5kIHZpc2libGUuIFNldCB0byBieSB0aGUgSlNcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9iaW5kaW5nOmZhbHNlLC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBjbGljay90YXAgb24gdGhlIHNsaWRlciBiYXIgdG8gc2VsZWN0IGEgdmFsdWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIHRydWVcbiAgICAgKi9jbGlja1NlbGVjdDp0cnVlLC8qKlxuICAgICAqIFNldCB0byB0cnVlIGFuZCB1c2UgdGhlIGB2ZXJ0aWNhbGAgY2xhc3MgdG8gY2hhbmdlIGFsaWdubWVudCB0byB2ZXJ0aWNhbC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi92ZXJ0aWNhbDpmYWxzZSwvKipcbiAgICAgKiBBbGxvd3MgdGhlIHVzZXIgdG8gZHJhZyB0aGUgc2xpZGVyIGhhbmRsZShzKSB0byBzZWxlY3QgYSB2YWx1ZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL2RyYWdnYWJsZTp0cnVlLC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBzbGlkZXIgYW5kIHByZXZlbnRzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGJlaW5nIGFwcGxpZWQuIERvdWJsZSBjaGVja2VkIGJ5IEpTIHdpdGggYGRpc2FibGVkQ2xhc3NgLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL2Rpc2FibGVkOmZhbHNlLC8qKlxuICAgICAqIEFsbG93cyB0aGUgdXNlIG9mIHR3byBoYW5kbGVzLiBEb3VibGUgY2hlY2tlZCBieSB0aGUgSlMuIENoYW5nZXMgc29tZSBsb2dpYyBoYW5kbGluZy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9kb3VibGVTaWRlZDpmYWxzZSwvKipcbiAgICAgKiBQb3RlbnRpYWwgZnV0dXJlIGZlYXR1cmUuXG4gICAgICovLy8gc3RlcHM6IDEwMCxcbi8qKlxuICAgICAqIE51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB0aGUgcGx1Z2luIHNob3VsZCBnbyB0byBmb3IgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyXG4gICAgICovZGVjaW1hbDoyLC8qKlxuICAgICAqIFRpbWUgZGVsYXkgZm9yIGRyYWdnZWQgZWxlbWVudHMuXG4gICAgICovLy8gZHJhZ0RlbGF5OiAwLFxuLyoqXG4gICAgICogVGltZSwgaW4gbXMsIHRvIGFuaW1hdGUgdGhlIG1vdmVtZW50IG9mIGEgc2xpZGVyIGhhbmRsZSBpZiB1c2VyIGNsaWNrcy90YXBzIG9uIHRoZSBiYXIuIE5lZWRzIHRvIGJlIG1hbnVhbGx5IHNldCBpZiB1cGRhdGluZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBTYXNzIHNldHRpbmdzLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyMDBcbiAgICAgKi9tb3ZlVGltZToyMDAsLy91cGRhdGUgdGhpcyBpZiBjaGFuZ2luZyB0aGUgdHJhbnNpdGlvbiB0aW1lIGluIHRoZSBzYXNzXG4vKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIGRpc2FibGVkIHNsaWRlcnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdkaXNhYmxlZCdcbiAgICAgKi9kaXNhYmxlZENsYXNzOidkaXNhYmxlZCcsLyoqXG4gICAgICogV2lsbCBpbnZlcnQgdGhlIGRlZmF1bHQgbGF5b3V0IGZvciBhIHZlcnRpY2FsPHNwYW4gZGF0YS10b29sdGlwIHRpdGxlPVwid2hvIHdvdWxkIGRvIHRoaXM/Pz9cIj4gPC9zcGFuPnNsaWRlci5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9pbnZlcnRWZXJ0aWNhbDpmYWxzZSwvKipcbiAgICAgKiBNaWxsaXNlY29uZHMgYmVmb3JlIHRoZSBgY2hhbmdlZC56Zi1zbGlkZXJgIGV2ZW50IGlzIHRyaWdnZXJlZCBhZnRlciB2YWx1ZSBjaGFuZ2UuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIDUwMFxuICAgICAqL2NoYW5nZWREZWxheTo1MDB9O2Z1bmN0aW9uIHBlcmNlbnQoZnJhYyxudW0pe3JldHVybiBmcmFjL251bTt9ZnVuY3Rpb24gYWJzUG9zaXRpb24oJGhhbmRsZSxkaXIsY2xpY2tQb3MscGFyYW0pe3JldHVybiBNYXRoLmFicygkaGFuZGxlLnBvc2l0aW9uKClbZGlyXSskaGFuZGxlW3BhcmFtXSgpLzItY2xpY2tQb3MpO30vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oU2xpZGVyLCdTbGlkZXInKTt9KGpRdWVyeSk7Ly8qKioqKioqKip0aGlzIGlzIGluIGNhc2Ugd2UgZ28gdG8gc3RhdGljLCBhYnNvbHV0ZSBwb3NpdGlvbnMgaW5zdGVhZCBvZiBkeW5hbWljIHBvc2l0aW9uaW5nKioqKioqKipcbnZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fTt9KCk7IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBTdGlja3kgbW9kdWxlLlxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uc3RpY2t5XG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XG4gICAqL3ZhciBTdGlja3k9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc3RpY2t5IHRoaW5nLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIHN0aWNreS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50IHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICovZnVuY3Rpb24gU3RpY2t5KGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsU3RpY2t5KTt0aGlzLiRlbGVtZW50PWVsZW1lbnQ7dGhpcy5vcHRpb25zPSQuZXh0ZW5kKHt9LFN0aWNreS5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxvcHRpb25zKTt0aGlzLl9pbml0KCk7Rm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCdTdGlja3knKTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHN0aWNreSBlbGVtZW50IGJ5IGFkZGluZyBjbGFzc2VzLCBnZXR0aW5nL3NldHRpbmcgZGltZW5zaW9ucywgYnJlYWtwb2ludHMgYW5kIGF0dHJpYnV0ZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhTdGlja3ksW3trZXk6J19pbml0Jyx2YWx1ZTpmdW5jdGlvbiBfaW5pdCgpe3ZhciAkcGFyZW50PXRoaXMuJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdGlja3ktY29udGFpbmVyXScpLGlkPXRoaXMuJGVsZW1lbnRbMF0uaWR8fEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwnc3RpY2t5JyksX3RoaXM9dGhpcztpZighJHBhcmVudC5sZW5ndGgpe3RoaXMud2FzV3JhcHBlZD10cnVlO310aGlzLiRjb250YWluZXI9JHBhcmVudC5sZW5ndGg/JHBhcmVudDokKHRoaXMub3B0aW9ucy5jb250YWluZXIpLndyYXBJbm5lcih0aGlzLiRlbGVtZW50KTt0aGlzLiRjb250YWluZXIuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTt0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcykuYXR0cih7J2RhdGEtcmVzaXplJzppZH0pO3RoaXMuc2Nyb2xsQ291bnQ9dGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7dGhpcy5pc1N0dWNrPWZhbHNlOyQod2luZG93KS5vbmUoJ2xvYWQuemYuc3RpY2t5JyxmdW5jdGlvbigpe2lmKF90aGlzLm9wdGlvbnMuYW5jaG9yIT09Jycpe190aGlzLiRhbmNob3I9JCgnIycrX3RoaXMub3B0aW9ucy5hbmNob3IpO31lbHNle190aGlzLl9wYXJzZVBvaW50cygpO31fdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtfdGhpcy5fY2FsYyhmYWxzZSk7fSk7X3RoaXMuX2V2ZW50cyhpZC5zcGxpdCgnLScpLnJldmVyc2UoKS5qb2luKCctJykpO30pO30vKipcbiAgICAgICAqIElmIHVzaW5nIG11bHRpcGxlIGVsZW1lbnRzIGFzIGFuY2hvcnMsIGNhbGN1bGF0ZXMgdGhlIHRvcCBhbmQgYm90dG9tIHBpeGVsIHZhbHVlcyB0aGUgc3RpY2t5IHRoaW5nIHNob3VsZCBzdGljayBhbmQgdW5zdGljayBvbi5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX3BhcnNlUG9pbnRzJyx2YWx1ZTpmdW5jdGlvbiBfcGFyc2VQb2ludHMoKXt2YXIgdG9wPXRoaXMub3B0aW9ucy50b3BBbmNob3I9PVwiXCI/MTp0aGlzLm9wdGlvbnMudG9wQW5jaG9yLGJ0bT10aGlzLm9wdGlvbnMuYnRtQW5jaG9yPT1cIlwiP2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQ6dGhpcy5vcHRpb25zLmJ0bUFuY2hvcixwdHM9W3RvcCxidG1dLGJyZWFrcz17fTtmb3IodmFyIGk9MCxsZW49cHRzLmxlbmd0aDtpPGxlbiYmcHRzW2ldO2krKyl7dmFyIHB0O2lmKHR5cGVvZiBwdHNbaV09PT0nbnVtYmVyJyl7cHQ9cHRzW2ldO31lbHNle3ZhciBwbGFjZT1wdHNbaV0uc3BsaXQoJzonKSxhbmNob3I9JCgnIycrcGxhY2VbMF0pO3B0PWFuY2hvci5vZmZzZXQoKS50b3A7aWYocGxhY2VbMV0mJnBsYWNlWzFdLnRvTG93ZXJDYXNlKCk9PT0nYm90dG9tJyl7cHQrPWFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7fX1icmVha3NbaV09cHQ7fXRoaXMucG9pbnRzPWJyZWFrcztyZXR1cm47fS8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIHNjcm9sbGluZyBlbGVtZW50LlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHBzdWVkby1yYW5kb20gaWQgZm9yIHVuaXF1ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXG4gICAgICAgKi99LHtrZXk6J19ldmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9ldmVudHMoaWQpe3ZhciBfdGhpcz10aGlzLHNjcm9sbExpc3RlbmVyPXRoaXMuc2Nyb2xsTGlzdGVuZXI9J3Njcm9sbC56Zi4nK2lkO2lmKHRoaXMuaXNPbil7cmV0dXJuO31pZih0aGlzLmNhblN0aWNrKXt0aGlzLmlzT249dHJ1ZTskKHdpbmRvdykub2ZmKHNjcm9sbExpc3RlbmVyKS5vbihzY3JvbGxMaXN0ZW5lcixmdW5jdGlvbihlKXtpZihfdGhpcy5zY3JvbGxDb3VudD09PTApe190aGlzLnNjcm9sbENvdW50PV90aGlzLm9wdGlvbnMuY2hlY2tFdmVyeTtfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24oKXtfdGhpcy5fY2FsYyhmYWxzZSx3aW5kb3cucGFnZVlPZmZzZXQpO30pO31lbHNle190aGlzLnNjcm9sbENvdW50LS07X3RoaXMuX2NhbGMoZmFsc2Usd2luZG93LnBhZ2VZT2Zmc2V0KTt9fSk7fXRoaXMuJGVsZW1lbnQub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJykub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLGZ1bmN0aW9uKGUsZWwpe190aGlzLl9zZXRTaXplcyhmdW5jdGlvbigpe190aGlzLl9jYWxjKGZhbHNlKTtpZihfdGhpcy5jYW5TdGljayl7aWYoIV90aGlzLmlzT24pe190aGlzLl9ldmVudHMoaWQpO319ZWxzZSBpZihfdGhpcy5pc09uKXtfdGhpcy5fcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpO319KTt9KTt9LyoqXG4gICAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZvciBzY3JvbGwgYW5kIGNoYW5nZSBldmVudHMgb24gYW5jaG9yLlxuICAgICAgICogQGZpcmVzIFN0aWNreSNwYXVzZVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHNjcm9sbExpc3RlbmVyIC0gdW5pcXVlLCBuYW1lc3BhY2VkIHNjcm9sbCBsaXN0ZW5lciBhdHRhY2hlZCB0byBgd2luZG93YFxuICAgICAgICovfSx7a2V5OidfcGF1c2VMaXN0ZW5lcnMnLHZhbHVlOmZ1bmN0aW9uIF9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcil7dGhpcy5pc09uPWZhbHNlOyQod2luZG93KS5vZmYoc2Nyb2xsTGlzdGVuZXIpOy8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaXMgcGF1c2VkIGR1ZSB0byByZXNpemUgZXZlbnQgc2hyaW5raW5nIHRoZSB2aWV3LlxuICAgICAgICAgKiBAZXZlbnQgU3RpY2t5I3BhdXNlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcigncGF1c2UuemYuc3RpY2t5Jyk7fS8qKlxuICAgICAgICogQ2FsbGVkIG9uIGV2ZXJ5IGBzY3JvbGxgIGV2ZW50IGFuZCBvbiBgX2luaXRgXG4gICAgICAgKiBmaXJlcyBmdW5jdGlvbnMgYmFzZWQgb24gYm9vbGVhbnMgYW5kIGNhY2hlZCB2YWx1ZXNcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2hlY2tTaXplcyAtIHRydWUgaWYgcGx1Z2luIHNob3VsZCByZWNhbGN1bGF0ZSBzaXplcyBhbmQgYnJlYWtwb2ludHMuXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2Nyb2xsIC0gY3VycmVudCBzY3JvbGwgcG9zaXRpb24gcGFzc2VkIGZyb20gc2Nyb2xsIGV2ZW50IGNiIGZ1bmN0aW9uLiBJZiBub3QgcGFzc2VkLCBkZWZhdWx0cyB0byBgd2luZG93LnBhZ2VZT2Zmc2V0YC5cbiAgICAgICAqL30se2tleTonX2NhbGMnLHZhbHVlOmZ1bmN0aW9uIF9jYWxjKGNoZWNrU2l6ZXMsc2Nyb2xsKXtpZihjaGVja1NpemVzKXt0aGlzLl9zZXRTaXplcygpO31pZighdGhpcy5jYW5TdGljayl7aWYodGhpcy5pc1N0dWNrKXt0aGlzLl9yZW1vdmVTdGlja3kodHJ1ZSk7fXJldHVybiBmYWxzZTt9aWYoIXNjcm9sbCl7c2Nyb2xsPXdpbmRvdy5wYWdlWU9mZnNldDt9aWYoc2Nyb2xsPj10aGlzLnRvcFBvaW50KXtpZihzY3JvbGw8PXRoaXMuYm90dG9tUG9pbnQpe2lmKCF0aGlzLmlzU3R1Y2spe3RoaXMuX3NldFN0aWNreSgpO319ZWxzZXtpZih0aGlzLmlzU3R1Y2spe3RoaXMuX3JlbW92ZVN0aWNreShmYWxzZSk7fX19ZWxzZXtpZih0aGlzLmlzU3R1Y2spe3RoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTt9fX0vKipcbiAgICAgICAqIENhdXNlcyB0aGUgJGVsZW1lbnQgdG8gYmVjb21lIHN0dWNrLlxuICAgICAgICogQWRkcyBgcG9zaXRpb246IGZpeGVkO2AsIGFuZCBoZWxwZXIgY2xhc3Nlcy5cbiAgICAgICAqIEBmaXJlcyBTdGlja3kjc3R1Y2t0b1xuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5Oidfc2V0U3RpY2t5Jyx2YWx1ZTpmdW5jdGlvbiBfc2V0U3RpY2t5KCl7dmFyIF90aGlzPXRoaXMsc3RpY2tUbz10aGlzLm9wdGlvbnMuc3RpY2tUbyxtcmduPXN0aWNrVG89PT0ndG9wJz8nbWFyZ2luVG9wJzonbWFyZ2luQm90dG9tJyxub3RTdHVja1RvPXN0aWNrVG89PT0ndG9wJz8nYm90dG9tJzondG9wJyxjc3M9e307Y3NzW21yZ25dPXRoaXMub3B0aW9uc1ttcmduXSsnZW0nO2Nzc1tzdGlja1RvXT0wO2Nzc1tub3RTdHVja1RvXT0nYXV0byc7Y3NzWydsZWZ0J109dGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQrcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kY29udGFpbmVyWzBdKVtcInBhZGRpbmctbGVmdFwiXSwxMCk7dGhpcy5pc1N0dWNrPXRydWU7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtYW5jaG9yZWQgaXMtYXQtJytub3RTdHVja1RvKS5hZGRDbGFzcygnaXMtc3R1Y2sgaXMtYXQtJytzdGlja1RvKS5jc3MoY3NzKS8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSAkZWxlbWVudCBoYXMgYmVjb21lIGBwb3NpdGlvbjogZml4ZWQ7YFxuICAgICAgICAgKiBOYW1lc3BhY2VkIHRvIGB0b3BgIG9yIGBib3R0b21gLCBlLmcuIGBzdGlja3kuemYuc3R1Y2t0bzp0b3BgXG4gICAgICAgICAqIEBldmVudCBTdGlja3kjc3R1Y2t0b1xuICAgICAgICAgKi8udHJpZ2dlcignc3RpY2t5LnpmLnN0dWNrdG86JytzdGlja1RvKTt0aGlzLiRlbGVtZW50Lm9uKFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFwiLGZ1bmN0aW9uKCl7X3RoaXMuX3NldFNpemVzKCk7fSk7fS8qKlxuICAgICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgdW5zdHVjay5cbiAgICAgICAqIFJlbW92ZXMgYHBvc2l0aW9uOiBmaXhlZDtgLCBhbmQgaGVscGVyIGNsYXNzZXMuXG4gICAgICAgKiBBZGRzIG90aGVyIGhlbHBlciBjbGFzc2VzLlxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc1RvcCAtIHRlbGxzIHRoZSBmdW5jdGlvbiBpZiB0aGUgJGVsZW1lbnQgc2hvdWxkIGFuY2hvciB0byB0aGUgdG9wIG9yIGJvdHRvbSBvZiBpdHMgJGFuY2hvciBlbGVtZW50LlxuICAgICAgICogQGZpcmVzIFN0aWNreSN1bnN0dWNrZnJvbVxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX3JlbW92ZVN0aWNreScsdmFsdWU6ZnVuY3Rpb24gX3JlbW92ZVN0aWNreShpc1RvcCl7dmFyIHN0aWNrVG89dGhpcy5vcHRpb25zLnN0aWNrVG8sc3RpY2tUb1RvcD1zdGlja1RvPT09J3RvcCcsY3NzPXt9LGFuY2hvclB0PSh0aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXS10aGlzLnBvaW50c1swXTp0aGlzLmFuY2hvckhlaWdodCktdGhpcy5lbGVtSGVpZ2h0LG1yZ249c3RpY2tUb1RvcD8nbWFyZ2luVG9wJzonbWFyZ2luQm90dG9tJyxub3RTdHVja1RvPXN0aWNrVG9Ub3A/J2JvdHRvbSc6J3RvcCcsdG9wT3JCb3R0b209aXNUb3A/J3RvcCc6J2JvdHRvbSc7Y3NzW21yZ25dPTA7Y3NzWydib3R0b20nXT0nYXV0byc7aWYoaXNUb3Ape2Nzc1sndG9wJ109MDt9ZWxzZXtjc3NbJ3RvcCddPWFuY2hvclB0O31jc3NbJ2xlZnQnXT0nJzt0aGlzLmlzU3R1Y2s9ZmFsc2U7dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtc3R1Y2sgaXMtYXQtJytzdGlja1RvKS5hZGRDbGFzcygnaXMtYW5jaG9yZWQgaXMtYXQtJyt0b3BPckJvdHRvbSkuY3NzKGNzcykvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBhbmNob3JlZC5cbiAgICAgICAgICogTmFtZXNwYWNlZCB0byBgdG9wYCBvciBgYm90dG9tYCwgZS5nLiBgc3RpY2t5LnpmLnVuc3R1Y2tmcm9tOmJvdHRvbWBcbiAgICAgICAgICogQGV2ZW50IFN0aWNreSN1bnN0dWNrZnJvbVxuICAgICAgICAgKi8udHJpZ2dlcignc3RpY2t5LnpmLnVuc3R1Y2tmcm9tOicrdG9wT3JCb3R0b20pO30vKipcbiAgICAgICAqIFNldHMgdGhlICRlbGVtZW50IGFuZCAkY29udGFpbmVyIHNpemVzIGZvciBwbHVnaW4uXG4gICAgICAgKiBDYWxscyBgX3NldEJyZWFrUG9pbnRzYC5cbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSBvbiBjb21wbGV0aW9uIG9mIGBfc2V0QnJlYWtQb2ludHNgLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX3NldFNpemVzJyx2YWx1ZTpmdW5jdGlvbiBfc2V0U2l6ZXMoY2Ipe3RoaXMuY2FuU3RpY2s9Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnN0aWNreU9uKTtpZighdGhpcy5jYW5TdGljayl7Y2IoKTt9dmFyIF90aGlzPXRoaXMsbmV3RWxlbVdpZHRoPXRoaXMuJGNvbnRhaW5lclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCxjb21wPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSkscGRuZz1wYXJzZUludChjb21wWydwYWRkaW5nLXJpZ2h0J10sMTApO2lmKHRoaXMuJGFuY2hvciYmdGhpcy4kYW5jaG9yLmxlbmd0aCl7dGhpcy5hbmNob3JIZWlnaHQ9dGhpcy4kYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDt9ZWxzZXt0aGlzLl9wYXJzZVBvaW50cygpO310aGlzLiRlbGVtZW50LmNzcyh7J21heC13aWR0aCc6bmV3RWxlbVdpZHRoLXBkbmcrJ3B4J30pO3ZhciBuZXdDb250YWluZXJIZWlnaHQ9dGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHR8fHRoaXMuY29udGFpbmVySGVpZ2h0O2lmKHRoaXMuJGVsZW1lbnQuY3NzKFwiZGlzcGxheVwiKT09XCJub25lXCIpe25ld0NvbnRhaW5lckhlaWdodD0wO310aGlzLmNvbnRhaW5lckhlaWdodD1uZXdDb250YWluZXJIZWlnaHQ7dGhpcy4kY29udGFpbmVyLmNzcyh7aGVpZ2h0Om5ld0NvbnRhaW5lckhlaWdodH0pO3RoaXMuZWxlbUhlaWdodD1uZXdDb250YWluZXJIZWlnaHQ7aWYodGhpcy5pc1N0dWNrKXt0aGlzLiRlbGVtZW50LmNzcyh7XCJsZWZ0XCI6dGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQrcGFyc2VJbnQoY29tcFsncGFkZGluZy1sZWZ0J10sMTApfSk7fXRoaXMuX3NldEJyZWFrUG9pbnRzKG5ld0NvbnRhaW5lckhlaWdodCxmdW5jdGlvbigpe2lmKGNiKXtjYigpO319KTt9LyoqXG4gICAgICAgKiBTZXRzIHRoZSB1cHBlciBhbmQgbG93ZXIgYnJlYWtwb2ludHMgZm9yIHRoZSBlbGVtZW50IHRvIGJlY29tZSBzdGlja3kvdW5zdGlja3kuXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gZWxlbUhlaWdodCAtIHB4IHZhbHVlIGZvciBzdGlja3kuJGVsZW1lbnQgaGVpZ2h0LCBjYWxjdWxhdGVkIGJ5IGBfc2V0U2l6ZXNgLlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbi5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19zZXRCcmVha1BvaW50cycsdmFsdWU6ZnVuY3Rpb24gX3NldEJyZWFrUG9pbnRzKGVsZW1IZWlnaHQsY2Ipe2lmKCF0aGlzLmNhblN0aWNrKXtpZihjYil7Y2IoKTt9ZWxzZXtyZXR1cm4gZmFsc2U7fX12YXIgbVRvcD1lbUNhbGModGhpcy5vcHRpb25zLm1hcmdpblRvcCksbUJ0bT1lbUNhbGModGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksdG9wUG9pbnQ9dGhpcy5wb2ludHM/dGhpcy5wb2ludHNbMF06dGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxib3R0b21Qb2ludD10aGlzLnBvaW50cz90aGlzLnBvaW50c1sxXTp0b3BQb2ludCt0aGlzLmFuY2hvckhlaWdodCwvLyB0b3BQb2ludCA9IHRoaXMuJGFuY2hvci5vZmZzZXQoKS50b3AgfHwgdGhpcy5wb2ludHNbMF0sXG4vLyBib3R0b21Qb2ludCA9IHRvcFBvaW50ICsgdGhpcy5hbmNob3JIZWlnaHQgfHwgdGhpcy5wb2ludHNbMV0sXG53aW5IZWlnaHQ9d2luZG93LmlubmVySGVpZ2h0O2lmKHRoaXMub3B0aW9ucy5zdGlja1RvPT09J3RvcCcpe3RvcFBvaW50LT1tVG9wO2JvdHRvbVBvaW50LT1lbGVtSGVpZ2h0K21Ub3A7fWVsc2UgaWYodGhpcy5vcHRpb25zLnN0aWNrVG89PT0nYm90dG9tJyl7dG9wUG9pbnQtPXdpbkhlaWdodC0oZWxlbUhlaWdodCttQnRtKTtib3R0b21Qb2ludC09d2luSGVpZ2h0LW1CdG07fWVsc2V7Ly90aGlzIHdvdWxkIGJlIHRoZSBzdGlja1RvOiBib3RoIG9wdGlvbi4uLiB0cmlja3lcbn10aGlzLnRvcFBvaW50PXRvcFBvaW50O3RoaXMuYm90dG9tUG9pbnQ9Ym90dG9tUG9pbnQ7aWYoY2Ipe2NiKCk7fX0vKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHN0aWNreSBlbGVtZW50LlxuICAgICAgICogUmVzZXRzIHRoZSBlbGVtZW50IHRvIHRoZSB0b3AgcG9zaXRpb24gZmlyc3QuXG4gICAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycywgSlMtYWRkZWQgY3NzIHByb3BlcnRpZXMgYW5kIGNsYXNzZXMsIGFuZCB1bndyYXBzIHRoZSAkZWxlbWVudCBpZiB0aGUgSlMgYWRkZWQgdGhlICRjb250YWluZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe3RoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTt0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcysnIGlzLWFuY2hvcmVkIGlzLWF0LXRvcCcpLmNzcyh7aGVpZ2h0OicnLHRvcDonJyxib3R0b206JycsJ21heC13aWR0aCc6Jyd9KS5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKTtpZih0aGlzLiRhbmNob3ImJnRoaXMuJGFuY2hvci5sZW5ndGgpe3RoaXMuJGFuY2hvci5vZmYoJ2NoYW5nZS56Zi5zdGlja3knKTt9JCh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKTtpZih0aGlzLndhc1dyYXBwZWQpe3RoaXMuJGVsZW1lbnQudW53cmFwKCk7fWVsc2V7dGhpcy4kY29udGFpbmVyLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5jb250YWluZXJDbGFzcykuY3NzKHtoZWlnaHQ6Jyd9KTt9Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO319XSk7cmV0dXJuIFN0aWNreTt9KCk7U3RpY2t5LmRlZmF1bHRzPXsvKipcbiAgICAgKiBDdXN0b21pemFibGUgY29udGFpbmVyIHRlbXBsYXRlLiBBZGQgeW91ciBvd24gY2xhc3NlcyBmb3Igc3R5bGluZyBhbmQgc2l6aW5nLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnJmx0O2RpdiBkYXRhLXN0aWNreS1jb250YWluZXIgY2xhc3M9XCJzbWFsbC02IGNvbHVtbnNcIiZndDsmbHQ7L2RpdiZndDsnXG4gICAgICovY29udGFpbmVyOic8ZGl2IGRhdGEtc3RpY2t5LWNvbnRhaW5lcj48L2Rpdj4nLC8qKlxuICAgICAqIExvY2F0aW9uIGluIHRoZSB2aWV3IHRoZSBlbGVtZW50IHN0aWNrcyB0by5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3RvcCdcbiAgICAgKi9zdGlja1RvOid0b3AnLC8qKlxuICAgICAqIElmIGFuY2hvcmVkIHRvIGEgc2luZ2xlIGVsZW1lbnQsIHRoZSBpZCBvZiB0aGF0IGVsZW1lbnQuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdleGFtcGxlSWQnXG4gICAgICovYW5jaG9yOicnLC8qKlxuICAgICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdleGFtcGxlSWQ6dG9wJ1xuICAgICAqL3RvcEFuY2hvcjonJywvKipcbiAgICAgKiBJZiB1c2luZyBtb3JlIHRoYW4gb25lIGVsZW1lbnQgYXMgYW5jaG9yIHBvaW50cywgdGhlIGlkIG9mIHRoZSBib3R0b20gYW5jaG9yLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkOmJvdHRvbSdcbiAgICAgKi9idG1BbmNob3I6JycsLyoqXG4gICAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIHRvcCBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxXG4gICAgICovbWFyZ2luVG9wOjEsLyoqXG4gICAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxXG4gICAgICovbWFyZ2luQm90dG9tOjEsLyoqXG4gICAgICogQnJlYWtwb2ludCBzdHJpbmcgdGhhdCBpcyB0aGUgbWluaW11bSBzY3JlZW4gc2l6ZSBhbiBlbGVtZW50IHNob3VsZCBiZWNvbWUgc3RpY2t5LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xuICAgICAqL3N0aWNreU9uOidtZWRpdW0nLC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGVsZW1lbnQsIGFuZCByZW1vdmVkIG9uIGRlc3RydWN0aW9uLiBGb3VuZGF0aW9uIGRlZmF1bHRzIHRvIGBzdGlja3lgLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnc3RpY2t5J1xuICAgICAqL3N0aWNreUNsYXNzOidzdGlja3knLC8qKlxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGNvbnRhaW5lci4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5LWNvbnRhaW5lcmAuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICdzdGlja3ktY29udGFpbmVyJ1xuICAgICAqL2NvbnRhaW5lckNsYXNzOidzdGlja3ktY29udGFpbmVyJywvKipcbiAgICAgKiBOdW1iZXIgb2Ygc2Nyb2xsIGV2ZW50cyBiZXR3ZWVuIHRoZSBwbHVnaW4ncyByZWNhbGN1bGF0aW5nIHN0aWNreSBwb2ludHMuIFNldHRpbmcgaXQgdG8gYDBgIHdpbGwgY2F1c2UgaXQgdG8gcmVjYWxjIGV2ZXJ5IHNjcm9sbCBldmVudCwgc2V0dGluZyBpdCB0byBgLTFgIHdpbGwgcHJldmVudCByZWNhbGMgb24gc2Nyb2xsLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSA1MFxuICAgICAqL2NoZWNrRXZlcnk6LTF9Oy8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY2FsY3VsYXRlIGVtIHZhbHVlc1xuICAgKiBAcGFyYW0gTnVtYmVyIHtlbX0gLSBudW1iZXIgb2YgZW0ncyB0byBjYWxjdWxhdGUgaW50byBwaXhlbHNcbiAgICovZnVuY3Rpb24gZW1DYWxjKGVtKXtyZXR1cm4gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSxudWxsKS5mb250U2l6ZSwxMCkqZW07fS8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihTdGlja3ksJ1N0aWNreScpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogVGFicyBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi50YWJzXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyIGlmIHRhYnMgY29udGFpbiBpbWFnZXNcbiAgICovdmFyIFRhYnM9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRhYnMuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIFRhYnMjaW5pdFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gdGFicy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXG4gICAgICovZnVuY3Rpb24gVGFicyhlbGVtZW50LG9wdGlvbnMpe19jbGFzc0NhbGxDaGVjayh0aGlzLFRhYnMpO3RoaXMuJGVsZW1lbnQ9ZWxlbWVudDt0aGlzLm9wdGlvbnM9JC5leHRlbmQoe30sVGFicy5kZWZhdWx0cyx0aGlzLiRlbGVtZW50LmRhdGEoKSxvcHRpb25zKTt0aGlzLl9pbml0KCk7Rm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCdUYWJzJyk7Rm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignVGFicycseydFTlRFUic6J29wZW4nLCdTUEFDRSc6J29wZW4nLCdBUlJPV19SSUdIVCc6J25leHQnLCdBUlJPV19VUCc6J3ByZXZpb3VzJywnQVJST1dfRE9XTic6J25leHQnLCdBUlJPV19MRUZUJzoncHJldmlvdXMnLy8gJ1RBQic6ICduZXh0Jyxcbi8vICdTSElGVF9UQUInOiAncHJldmlvdXMnXG59KTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYnMgYnkgc2hvd2luZyBhbmQgZm9jdXNpbmcgKGlmIGF1dG9Gb2N1cz10cnVlKSB0aGUgcHJlc2V0IGFjdGl2ZSB0YWIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9fY3JlYXRlQ2xhc3MoVGFicyxbe2tleTonX2luaXQnLHZhbHVlOmZ1bmN0aW9uIF9pbml0KCl7dmFyIF90aGlzPXRoaXM7dGhpcy4kdGFiVGl0bGVzPXRoaXMuJGVsZW1lbnQuZmluZCgnLicrdGhpcy5vcHRpb25zLmxpbmtDbGFzcyk7dGhpcy4kdGFiQ29udGVudD0kKCdbZGF0YS10YWJzLWNvbnRlbnQ9XCInK3RoaXMuJGVsZW1lbnRbMF0uaWQrJ1wiXScpO3RoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uKCl7dmFyICRlbGVtPSQodGhpcyksJGxpbms9JGVsZW0uZmluZCgnYScpLGlzQWN0aXZlPSRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSxoYXNoPSRsaW5rWzBdLmhhc2guc2xpY2UoMSksbGlua0lkPSRsaW5rWzBdLmlkPyRsaW5rWzBdLmlkOmhhc2grJy1sYWJlbCcsJHRhYkNvbnRlbnQ9JCgnIycraGFzaCk7JGVsZW0uYXR0cih7J3JvbGUnOidwcmVzZW50YXRpb24nfSk7JGxpbmsuYXR0cih7J3JvbGUnOid0YWInLCdhcmlhLWNvbnRyb2xzJzpoYXNoLCdhcmlhLXNlbGVjdGVkJzppc0FjdGl2ZSwnaWQnOmxpbmtJZH0pOyR0YWJDb250ZW50LmF0dHIoeydyb2xlJzondGFicGFuZWwnLCdhcmlhLWhpZGRlbic6IWlzQWN0aXZlLCdhcmlhLWxhYmVsbGVkYnknOmxpbmtJZH0pO2lmKGlzQWN0aXZlJiZfdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyl7JGxpbmsuZm9jdXMoKTt9fSk7aWYodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KXt2YXIgJGltYWdlcz10aGlzLiR0YWJDb250ZW50LmZpbmQoJ2ltZycpO2lmKCRpbWFnZXMubGVuZ3RoKXtGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKCRpbWFnZXMsdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpO31lbHNle3RoaXMuX3NldEhlaWdodCgpO319dGhpcy5fZXZlbnRzKCk7fS8qKlxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2V2ZW50cycsdmFsdWU6ZnVuY3Rpb24gX2V2ZW50cygpe3RoaXMuX2FkZEtleUhhbmRsZXIoKTt0aGlzLl9hZGRDbGlja0hhbmRsZXIoKTt0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXI9bnVsbDtpZih0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQpe3RoaXMuX3NldEhlaWdodE1xSGFuZGxlcj10aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKTskKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsdGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyKTt9fS8qKlxuICAgICAgICogQWRkcyBjbGljayBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2FkZENsaWNrSGFuZGxlcicsdmFsdWU6ZnVuY3Rpb24gX2FkZENsaWNrSGFuZGxlcigpe3ZhciBfdGhpcz10aGlzO3RoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi50YWJzJykub24oJ2NsaWNrLnpmLnRhYnMnLCcuJyt0aGlzLm9wdGlvbnMubGlua0NsYXNzLGZ1bmN0aW9uKGUpe2UucHJldmVudERlZmF1bHQoKTtlLnN0b3BQcm9wYWdhdGlvbigpO2lmKCQodGhpcykuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpKXtyZXR1cm47fV90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJCh0aGlzKSk7fSk7fS8qKlxuICAgICAgICogQWRkcyBrZXlib2FyZCBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSB0YWJzLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2FkZEtleUhhbmRsZXInLHZhbHVlOmZ1bmN0aW9uIF9hZGRLZXlIYW5kbGVyKCl7dmFyIF90aGlzPXRoaXM7dmFyICRmaXJzdFRhYj1fdGhpcy4kZWxlbWVudC5maW5kKCdsaTpmaXJzdC1vZi10eXBlJyk7dmFyICRsYXN0VGFiPV90aGlzLiRlbGVtZW50LmZpbmQoJ2xpOmxhc3Qtb2YtdHlwZScpO3RoaXMuJHRhYlRpdGxlcy5vZmYoJ2tleWRvd24uemYudGFicycpLm9uKCdrZXlkb3duLnpmLnRhYnMnLGZ1bmN0aW9uKGUpe2lmKGUud2hpY2g9PT05KXJldHVybjt2YXIgJGVsZW1lbnQ9JCh0aGlzKSwkZWxlbWVudHM9JGVsZW1lbnQucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLCRwcmV2RWxlbWVudCwkbmV4dEVsZW1lbnQ7JGVsZW1lbnRzLmVhY2goZnVuY3Rpb24oaSl7aWYoJCh0aGlzKS5pcygkZWxlbWVudCkpe2lmKF90aGlzLm9wdGlvbnMud3JhcE9uS2V5cyl7JHByZXZFbGVtZW50PWk9PT0wPyRlbGVtZW50cy5sYXN0KCk6JGVsZW1lbnRzLmVxKGktMSk7JG5leHRFbGVtZW50PWk9PT0kZWxlbWVudHMubGVuZ3RoLTE/JGVsZW1lbnRzLmZpcnN0KCk6JGVsZW1lbnRzLmVxKGkrMSk7fWVsc2V7JHByZXZFbGVtZW50PSRlbGVtZW50cy5lcShNYXRoLm1heCgwLGktMSkpOyRuZXh0RWxlbWVudD0kZWxlbWVudHMuZXEoTWF0aC5taW4oaSsxLCRlbGVtZW50cy5sZW5ndGgtMSkpO31yZXR1cm47fX0pOy8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcbkZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsJ1RhYnMnLHtvcGVuOmZ1bmN0aW9uIG9wZW4oKXskZWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7X3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkZWxlbWVudCk7fSxwcmV2aW91czpmdW5jdGlvbiBwcmV2aW91cygpeyRwcmV2RWxlbWVudC5maW5kKCdbcm9sZT1cInRhYlwiXScpLmZvY3VzKCk7X3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkcHJldkVsZW1lbnQpO30sbmV4dDpmdW5jdGlvbiBuZXh0KCl7JG5leHRFbGVtZW50LmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuZm9jdXMoKTtfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRuZXh0RWxlbWVudCk7fSxoYW5kbGVkOmZ1bmN0aW9uIGhhbmRsZWQoKXtlLnN0b3BQcm9wYWdhdGlvbigpO2UucHJldmVudERlZmF1bHQoKTt9fSk7fSk7fS8qKlxuICAgICAgICogT3BlbnMgdGhlIHRhYiBgJHRhcmdldENvbnRlbnRgIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cbiAgICAgICAqIEBmaXJlcyBUYWJzI2NoYW5nZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J19oYW5kbGVUYWJDaGFuZ2UnLHZhbHVlOmZ1bmN0aW9uIF9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCl7dmFyICR0YWJMaW5rPSR0YXJnZXQuZmluZCgnW3JvbGU9XCJ0YWJcIl0nKSxoYXNoPSR0YWJMaW5rWzBdLmhhc2gsJHRhcmdldENvbnRlbnQ9dGhpcy4kdGFiQ29udGVudC5maW5kKGhhc2gpLCRvbGRUYWI9dGhpcy4kZWxlbWVudC5maW5kKCcuJyt0aGlzLm9wdGlvbnMubGlua0NsYXNzKycuaXMtYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmZpbmQoJ1tyb2xlPVwidGFiXCJdJykuYXR0cih7J2FyaWEtc2VsZWN0ZWQnOidmYWxzZSd9KTskKCcjJyskb2xkVGFiLmF0dHIoJ2FyaWEtY29udHJvbHMnKSkucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLmF0dHIoeydhcmlhLWhpZGRlbic6J3RydWUnfSk7JHRhcmdldC5hZGRDbGFzcygnaXMtYWN0aXZlJyk7JHRhYkxpbmsuYXR0cih7J2FyaWEtc2VsZWN0ZWQnOid0cnVlJ30pOyR0YXJnZXRDb250ZW50LmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsnYXJpYS1oaWRkZW4nOidmYWxzZSd9KTsvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgcGx1Z2luIGhhcyBzdWNjZXNzZnVsbHkgY2hhbmdlZCB0YWJzLlxuICAgICAgICAgKiBAZXZlbnQgVGFicyNjaGFuZ2VcbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2UuemYudGFicycsWyR0YXJnZXRdKTt9LyoqXG4gICAgICAgKiBQdWJsaWMgbWV0aG9kIGZvciBzZWxlY3RpbmcgYSBjb250ZW50IHBhbmUgdG8gZGlzcGxheS5cbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5IHwgU3RyaW5nfSBlbGVtIC0galF1ZXJ5IG9iamVjdCBvciBzdHJpbmcgb2YgdGhlIGlkIG9mIHRoZSBwYW5lIHRvIGRpc3BsYXkuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqL30se2tleTonc2VsZWN0VGFiJyx2YWx1ZTpmdW5jdGlvbiBzZWxlY3RUYWIoZWxlbSl7dmFyIGlkU3RyO2lmKCh0eXBlb2YgZWxlbT09PSd1bmRlZmluZWQnPyd1bmRlZmluZWQnOl90eXBlb2YoZWxlbSkpPT09J29iamVjdCcpe2lkU3RyPWVsZW1bMF0uaWQ7fWVsc2V7aWRTdHI9ZWxlbTt9aWYoaWRTdHIuaW5kZXhPZignIycpPDApe2lkU3RyPScjJytpZFN0cjt9dmFyICR0YXJnZXQ9dGhpcy4kdGFiVGl0bGVzLmZpbmQoJ1tocmVmPVwiJytpZFN0cisnXCJdJykucGFyZW50KCcuJyt0aGlzLm9wdGlvbnMubGlua0NsYXNzKTt0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJHRhcmdldCk7fX0se2tleTonX3NldEhlaWdodCcsLyoqXG4gICAgICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgZWFjaCBwYW5lbCB0byB0aGUgaGVpZ2h0IG9mIHRoZSB0YWxsZXN0IHBhbmVsLlxuICAgICAgICogSWYgZW5hYmxlZCBpbiBvcHRpb25zLCBnZXRzIGNhbGxlZCBvbiBtZWRpYSBxdWVyeSBjaGFuZ2UuXG4gICAgICAgKiBJZiBsb2FkaW5nIGNvbnRlbnQgdmlhIGV4dGVybmFsIHNvdXJjZSwgY2FuIGJlIGNhbGxlZCBkaXJlY3RseSBvciB3aXRoIF9yZWZsb3cuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi92YWx1ZTpmdW5jdGlvbiBfc2V0SGVpZ2h0KCl7dmFyIG1heD0wO3RoaXMuJHRhYkNvbnRlbnQuZmluZCgnLicrdGhpcy5vcHRpb25zLnBhbmVsQ2xhc3MpLmNzcygnaGVpZ2h0JywnJykuZWFjaChmdW5jdGlvbigpe3ZhciBwYW5lbD0kKHRoaXMpLGlzQWN0aXZlPXBhbmVsLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtpZighaXNBY3RpdmUpe3BhbmVsLmNzcyh7J3Zpc2liaWxpdHknOidoaWRkZW4nLCdkaXNwbGF5JzonYmxvY2snfSk7fXZhciB0ZW1wPXRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O2lmKCFpc0FjdGl2ZSl7cGFuZWwuY3NzKHsndmlzaWJpbGl0eSc6JycsJ2Rpc3BsYXknOicnfSk7fW1heD10ZW1wPm1heD90ZW1wOm1heDt9KS5jc3MoJ2hlaWdodCcsbWF4KydweCcpO30vKipcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGFuIHRhYnMuXG4gICAgICAgKiBAZmlyZXMgVGFicyNkZXN0cm95ZWRcbiAgICAgICAqL30se2tleTonZGVzdHJveScsdmFsdWU6ZnVuY3Rpb24gZGVzdHJveSgpe3RoaXMuJGVsZW1lbnQuZmluZCgnLicrdGhpcy5vcHRpb25zLmxpbmtDbGFzcykub2ZmKCcuemYudGFicycpLmhpZGUoKS5lbmQoKS5maW5kKCcuJyt0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuaGlkZSgpO2lmKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCl7aWYodGhpcy5fc2V0SGVpZ2h0TXFIYW5kbGVyIT1udWxsKXskKHdpbmRvdykub2ZmKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7fX1Gb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gVGFiczt9KCk7VGFicy5kZWZhdWx0cz17LyoqXG4gICAgICogQWxsb3dzIHRoZSB3aW5kb3cgdG8gc2Nyb2xsIHRvIGNvbnRlbnQgb2YgYWN0aXZlIHBhbmUgb24gbG9hZCBpZiBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9hdXRvRm9jdXM6ZmFsc2UsLyoqXG4gICAgICogQWxsb3dzIGtleWJvYXJkIGlucHV0IHRvICd3cmFwJyBhcm91bmQgdGhlIHRhYiBsaW5rcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxuICAgICAqL3dyYXBPbktleXM6dHJ1ZSwvKipcbiAgICAgKiBBbGxvd3MgdGhlIHRhYiBjb250ZW50IHBhbmVzIHRvIG1hdGNoIGhlaWdodHMgaWYgc2V0IHRvIHRydWUuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlIGZhbHNlXG4gICAgICovbWF0Y2hIZWlnaHQ6ZmFsc2UsLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBgbGlgJ3MgaW4gdGFiIGxpbmsgbGlzdC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ3RhYnMtdGl0bGUnXG4gICAgICovbGlua0NsYXNzOid0YWJzLXRpdGxlJywvKipcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSBjb250ZW50IGNvbnRhaW5lcnMuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICd0YWJzLXBhbmVsJ1xuICAgICAqL3BhbmVsQ2xhc3M6J3RhYnMtcGFuZWwnfTtmdW5jdGlvbiBjaGVja0NsYXNzKCRlbGVtKXtyZXR1cm4gJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO30vLyBXaW5kb3cgZXhwb3J0c1xuRm91bmRhdGlvbi5wbHVnaW4oVGFicywnVGFicycpO30oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQscHJvcHMpe2Zvcih2YXIgaT0wO2k8cHJvcHMubGVuZ3RoO2krKyl7dmFyIGRlc2NyaXB0b3I9cHJvcHNbaV07ZGVzY3JpcHRvci5lbnVtZXJhYmxlPWRlc2NyaXB0b3IuZW51bWVyYWJsZXx8ZmFsc2U7ZGVzY3JpcHRvci5jb25maWd1cmFibGU9dHJ1ZTtpZihcInZhbHVlXCJpbiBkZXNjcmlwdG9yKWRlc2NyaXB0b3Iud3JpdGFibGU9dHJ1ZTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LGRlc2NyaXB0b3Iua2V5LGRlc2NyaXB0b3IpO319cmV0dXJuIGZ1bmN0aW9uKENvbnN0cnVjdG9yLHByb3RvUHJvcHMsc3RhdGljUHJvcHMpe2lmKHByb3RvUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUscHJvdG9Qcm9wcyk7aWYoc3RhdGljUHJvcHMpZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3RvcixzdGF0aWNQcm9wcyk7cmV0dXJuIENvbnN0cnVjdG9yO307fSgpOyFmdW5jdGlvbigkKXsvKipcbiAgICogVG9nZ2xlciBtb2R1bGUuXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi50b2dnbGVyXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcbiAgICovdmFyIFRvZ2dsZXI9ZnVuY3Rpb24oKXsvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFRvZ2dsZXIuXG4gICAgICogQGNsYXNzXG4gICAgICogQGZpcmVzIFRvZ2dsZXIjaW5pdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxuICAgICAqL2Z1bmN0aW9uIFRvZ2dsZXIoZWxlbWVudCxvcHRpb25zKXtfY2xhc3NDYWxsQ2hlY2sodGhpcyxUb2dnbGVyKTt0aGlzLiRlbGVtZW50PWVsZW1lbnQ7dGhpcy5vcHRpb25zPSQuZXh0ZW5kKHt9LFRvZ2dsZXIuZGVmYXVsdHMsZWxlbWVudC5kYXRhKCksb3B0aW9ucyk7dGhpcy5jbGFzc05hbWU9Jyc7dGhpcy5faW5pdCgpO3RoaXMuX2V2ZW50cygpO0ZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywnVG9nZ2xlcicpO30vKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgVG9nZ2xlciBwbHVnaW4gYnkgcGFyc2luZyB0aGUgdG9nZ2xlIGNsYXNzIGZyb20gZGF0YS10b2dnbGVyLCBvciBhbmltYXRpb24gY2xhc3NlcyBmcm9tIGRhdGEtYW5pbWF0ZS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhUb2dnbGVyLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt2YXIgaW5wdXQ7Ly8gUGFyc2UgYW5pbWF0aW9uIGNsYXNzZXMgaWYgdGhleSB3ZXJlIHNldFxuaWYodGhpcy5vcHRpb25zLmFuaW1hdGUpe2lucHV0PXRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7dGhpcy5hbmltYXRpb25Jbj1pbnB1dFswXTt0aGlzLmFuaW1hdGlvbk91dD1pbnB1dFsxXXx8bnVsbDt9Ly8gT3RoZXJ3aXNlLCBwYXJzZSB0b2dnbGUgY2xhc3NcbmVsc2V7aW5wdXQ9dGhpcy4kZWxlbWVudC5kYXRhKCd0b2dnbGVyJyk7Ly8gQWxsb3cgZm9yIGEgLiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcbnRoaXMuY2xhc3NOYW1lPWlucHV0WzBdPT09Jy4nP2lucHV0LnNsaWNlKDEpOmlucHV0O30vLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRyaWdnZXJzXG52YXIgaWQ9dGhpcy4kZWxlbWVudFswXS5pZDskKCdbZGF0YS1vcGVuPVwiJytpZCsnXCJdLCBbZGF0YS1jbG9zZT1cIicraWQrJ1wiXSwgW2RhdGEtdG9nZ2xlPVwiJytpZCsnXCJdJykuYXR0cignYXJpYS1jb250cm9scycsaWQpOy8vIElmIHRoZSB0YXJnZXQgaXMgaGlkZGVuLCBhZGQgYXJpYS1oaWRkZW5cbnRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsdGhpcy4kZWxlbWVudC5pcygnOmhpZGRlbicpP2ZhbHNlOnRydWUpO30vKipcbiAgICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgdGhlIHRvZ2dsZSB0cmlnZ2VyLlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovfSx7a2V5OidfZXZlbnRzJyx2YWx1ZTpmdW5jdGlvbiBfZXZlbnRzKCl7dGhpcy4kZWxlbWVudC5vZmYoJ3RvZ2dsZS56Zi50cmlnZ2VyJykub24oJ3RvZ2dsZS56Zi50cmlnZ2VyJyx0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTt9LyoqXG4gICAgICAgKiBUb2dnbGVzIHRoZSB0YXJnZXQgY2xhc3Mgb24gdGhlIHRhcmdldCBlbGVtZW50LiBBbiBldmVudCBpcyBmaXJlZCBmcm9tIHRoZSBvcmlnaW5hbCB0cmlnZ2VyIGRlcGVuZGluZyBvbiBpZiB0aGUgcmVzdWx0YW50IHN0YXRlIHdhcyBcIm9uXCIgb3IgXCJvZmZcIi5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogQGZpcmVzIFRvZ2dsZXIjb25cbiAgICAgICAqIEBmaXJlcyBUb2dnbGVyI29mZlxuICAgICAgICovfSx7a2V5Oid0b2dnbGUnLHZhbHVlOmZ1bmN0aW9uIHRvZ2dsZSgpe3RoaXNbdGhpcy5vcHRpb25zLmFuaW1hdGU/J190b2dnbGVBbmltYXRlJzonX3RvZ2dsZUNsYXNzJ10oKTt9fSx7a2V5OidfdG9nZ2xlQ2xhc3MnLHZhbHVlOmZ1bmN0aW9uIF90b2dnbGVDbGFzcygpe3RoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5jbGFzc05hbWUpO3ZhciBpc09uPXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5jbGFzc05hbWUpO2lmKGlzT24pey8qKlxuICAgICAgICAgICAqIEZpcmVzIGlmIHRoZSB0YXJnZXQgZWxlbWVudCBoYXMgdGhlIGNsYXNzIGFmdGVyIGEgdG9nZ2xlLlxuICAgICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXG4gICAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvbi56Zi50b2dnbGVyJyk7fWVsc2V7LyoqXG4gICAgICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGRvZXMgbm90IGhhdmUgdGhlIGNsYXNzIGFmdGVyIGEgdG9nZ2xlLlxuICAgICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxuICAgICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTt9dGhpcy5fdXBkYXRlQVJJQShpc09uKTt9fSx7a2V5OidfdG9nZ2xlQW5pbWF0ZScsdmFsdWU6ZnVuY3Rpb24gX3RvZ2dsZUFuaW1hdGUoKXt2YXIgX3RoaXM9dGhpcztpZih0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpe0ZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbih0aGlzLiRlbGVtZW50LHRoaXMuYW5pbWF0aW9uSW4sZnVuY3Rpb24oKXtfdGhpcy5fdXBkYXRlQVJJQSh0cnVlKTt0aGlzLnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTt9KTt9ZWxzZXtGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsdGhpcy5hbmltYXRpb25PdXQsZnVuY3Rpb24oKXtfdGhpcy5fdXBkYXRlQVJJQShmYWxzZSk7dGhpcy50cmlnZ2VyKCdvZmYuemYudG9nZ2xlcicpO30pO319fSx7a2V5OidfdXBkYXRlQVJJQScsdmFsdWU6ZnVuY3Rpb24gX3VwZGF0ZUFSSUEoaXNPbil7dGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJyxpc09uP3RydWU6ZmFsc2UpO30vKipcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBpbnN0YW5jZSBvZiBUb2dnbGVyIG9uIHRoZSBlbGVtZW50LlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J2Rlc3Ryb3knLHZhbHVlOmZ1bmN0aW9uIGRlc3Ryb3koKXt0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRvZ2dsZXInKTtGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gVG9nZ2xlcjt9KCk7VG9nZ2xlci5kZWZhdWx0cz17LyoqXG4gICAgICogVGVsbHMgdGhlIHBsdWdpbiBpZiB0aGUgZWxlbWVudCBzaG91bGQgYW5pbWF0ZWQgd2hlbiB0b2dnbGVkLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxuICAgICAqL2FuaW1hdGU6ZmFsc2V9Oy8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihUb2dnbGVyLCdUb2dnbGVyJyk7fShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCxwcm9wcyl7Zm9yKHZhciBpPTA7aTxwcm9wcy5sZW5ndGg7aSsrKXt2YXIgZGVzY3JpcHRvcj1wcm9wc1tpXTtkZXNjcmlwdG9yLmVudW1lcmFibGU9ZGVzY3JpcHRvci5lbnVtZXJhYmxlfHxmYWxzZTtkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZT10cnVlO2lmKFwidmFsdWVcImluIGRlc2NyaXB0b3IpZGVzY3JpcHRvci53cml0YWJsZT10cnVlO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsZGVzY3JpcHRvci5rZXksZGVzY3JpcHRvcik7fX1yZXR1cm4gZnVuY3Rpb24oQ29uc3RydWN0b3IscHJvdG9Qcm9wcyxzdGF0aWNQcm9wcyl7aWYocHJvdG9Qcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSxwcm90b1Byb3BzKTtpZihzdGF0aWNQcm9wcylkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLHN0YXRpY1Byb3BzKTtyZXR1cm4gQ29uc3RydWN0b3I7fTt9KCk7ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLENvbnN0cnVjdG9yKXtpZighKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO319IWZ1bmN0aW9uKCQpey8qKlxuICAgKiBUb29sdGlwIG1vZHVsZS5cbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLnRvb2x0aXBcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xuICAgKi92YXIgVG9vbHRpcD1mdW5jdGlvbigpey8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBUb29sdGlwLlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIGEgdG9vbHRpcCB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB0byBleHRlbmQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9mdW5jdGlvbiBUb29sdGlwKGVsZW1lbnQsb3B0aW9ucyl7X2NsYXNzQ2FsbENoZWNrKHRoaXMsVG9vbHRpcCk7dGhpcy4kZWxlbWVudD1lbGVtZW50O3RoaXMub3B0aW9ucz0kLmV4dGVuZCh7fSxUb29sdGlwLmRlZmF1bHRzLHRoaXMuJGVsZW1lbnQuZGF0YSgpLG9wdGlvbnMpO3RoaXMuaXNBY3RpdmU9ZmFsc2U7dGhpcy5pc0NsaWNrPWZhbHNlO3RoaXMuX2luaXQoKTtGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsJ1Rvb2x0aXAnKTt9LyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXAgYnkgc2V0dGluZyB0aGUgY3JlYXRpbmcgdGhlIHRpcCBlbGVtZW50LCBhZGRpbmcgaXQncyB0ZXh0LCBzZXR0aW5nIHByaXZhdGUgdmFyaWFibGVzIGFuZCBzZXR0aW5nIGF0dHJpYnV0ZXMgb24gdGhlIGFuY2hvci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL19jcmVhdGVDbGFzcyhUb29sdGlwLFt7a2V5OidfaW5pdCcsdmFsdWU6ZnVuY3Rpb24gX2luaXQoKXt2YXIgZWxlbUlkPXRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScpfHxGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsJ3Rvb2x0aXAnKTt0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcz10aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzc3x8dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KTt0aGlzLm9wdGlvbnMudGlwVGV4dD10aGlzLm9wdGlvbnMudGlwVGV4dHx8dGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO3RoaXMudGVtcGxhdGU9dGhpcy5vcHRpb25zLnRlbXBsYXRlPyQodGhpcy5vcHRpb25zLnRlbXBsYXRlKTp0aGlzLl9idWlsZFRlbXBsYXRlKGVsZW1JZCk7dGhpcy50ZW1wbGF0ZS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KS50ZXh0KHRoaXMub3B0aW9ucy50aXBUZXh0KS5oaWRlKCk7dGhpcy4kZWxlbWVudC5hdHRyKHsndGl0bGUnOicnLCdhcmlhLWRlc2NyaWJlZGJ5JzplbGVtSWQsJ2RhdGEteWV0aS1ib3gnOmVsZW1JZCwnZGF0YS10b2dnbGUnOmVsZW1JZCwnZGF0YS1yZXNpemUnOmVsZW1JZH0pLmFkZENsYXNzKHRoaXMudHJpZ2dlckNsYXNzKTsvL2hlbHBlciB2YXJpYWJsZXMgdG8gdHJhY2sgbW92ZW1lbnQgb24gY29sbGlzaW9uc1xudGhpcy51c2VkUG9zaXRpb25zPVtdO3RoaXMuY291bnRlcj00O3RoaXMuY2xhc3NDaGFuZ2VkPWZhbHNlO3RoaXMuX2V2ZW50cygpO30vKipcbiAgICAgICAqIEdyYWJzIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIGNsYXNzLCBpZiBwcmVzZW50LCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX2dldFBvc2l0aW9uQ2xhc3MnLHZhbHVlOmZ1bmN0aW9uIF9nZXRQb3NpdGlvbkNsYXNzKGVsZW1lbnQpe2lmKCFlbGVtZW50KXtyZXR1cm4nJzt9Ly8gdmFyIHBvc2l0aW9uID0gZWxlbWVudC5hdHRyKCdjbGFzcycpLm1hdGNoKC90b3B8bGVmdHxyaWdodC9nKTtcbnZhciBwb3NpdGlvbj1lbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcYi9nKTtwb3NpdGlvbj1wb3NpdGlvbj9wb3NpdGlvblswXTonJztyZXR1cm4gcG9zaXRpb247fX0se2tleTonX2J1aWxkVGVtcGxhdGUnLC8qKlxuICAgICAgICogYnVpbGRzIHRoZSB0b29sdGlwIGVsZW1lbnQsIGFkZHMgYXR0cmlidXRlcywgYW5kIHJldHVybnMgdGhlIHRlbXBsYXRlLlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL3ZhbHVlOmZ1bmN0aW9uIF9idWlsZFRlbXBsYXRlKGlkKXt2YXIgdGVtcGxhdGVDbGFzc2VzPSh0aGlzLm9wdGlvbnMudG9vbHRpcENsYXNzKycgJyt0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcysnICcrdGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3NlcykudHJpbSgpO3ZhciAkdGVtcGxhdGU9JCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0ZW1wbGF0ZUNsYXNzZXMpLmF0dHIoeydyb2xlJzondG9vbHRpcCcsJ2FyaWEtaGlkZGVuJzp0cnVlLCdkYXRhLWlzLWFjdGl2ZSc6ZmFsc2UsJ2RhdGEtaXMtZm9jdXMnOmZhbHNlLCdpZCc6aWR9KTtyZXR1cm4gJHRlbXBsYXRlO30vKipcbiAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQuXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbmluZyBjbGFzcyB0byB0cnlcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19yZXBvc2l0aW9uJyx2YWx1ZTpmdW5jdGlvbiBfcmVwb3NpdGlvbihwb3NpdGlvbil7dGhpcy51c2VkUG9zaXRpb25zLnB1c2gocG9zaXRpb24/cG9zaXRpb246J2JvdHRvbScpOy8vZGVmYXVsdCwgdHJ5IHN3aXRjaGluZyB0byBvcHBvc2l0ZSBzaWRlXG5pZighcG9zaXRpb24mJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCd0b3AnKTwwKXt0aGlzLnRlbXBsYXRlLmFkZENsYXNzKCd0b3AnKTt9ZWxzZSBpZihwb3NpdGlvbj09PSd0b3AnJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJyk8MCl7dGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbik7fWVsc2UgaWYocG9zaXRpb249PT0nbGVmdCcmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdyaWdodCcpPDApe3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pLmFkZENsYXNzKCdyaWdodCcpO31lbHNlIGlmKHBvc2l0aW9uPT09J3JpZ2h0JyYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKTwwKXt0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO30vL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcbmVsc2UgaWYoIXBvc2l0aW9uJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigndG9wJyk+LTEmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0Jyk8MCl7dGhpcy50ZW1wbGF0ZS5hZGRDbGFzcygnbGVmdCcpO31lbHNlIGlmKHBvc2l0aW9uPT09J3RvcCcmJnRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKTwwKXt0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO31lbHNlIGlmKHBvc2l0aW9uPT09J2xlZnQnJiZ0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpPDApe3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO31lbHNlIGlmKHBvc2l0aW9uPT09J3JpZ2h0JyYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKT4tMSYmdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpPDApe3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO30vL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxuZWxzZXt0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTt9dGhpcy5jbGFzc0NoYW5nZWQ9dHJ1ZTt0aGlzLmNvdW50ZXItLTt9LyoqXG4gICAgICAgKiBzZXRzIHRoZSBwb3NpdGlvbiBjbGFzcyBvZiBhbiBlbGVtZW50IGFuZCByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUgcG9zc2libGUgcG9zaXRpb25zIHRvIGF0dGVtcHQsIG9yIHRoZSB0b29sdGlwIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGNvbGxpZGluZy5cbiAgICAgICAqIGlmIHRoZSB0b29sdGlwIGlzIGxhcmdlciB0aGFuIHRoZSBzY3JlZW4gd2lkdGgsIGRlZmF1bHQgdG8gZnVsbCB3aWR0aCAtIGFueSB1c2VyIHNlbGVjdGVkIG1hcmdpblxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL30se2tleTonX3NldFBvc2l0aW9uJyx2YWx1ZTpmdW5jdGlvbiBfc2V0UG9zaXRpb24oKXt2YXIgcG9zaXRpb249dGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSwkdGlwRGltcz1Gb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMudGVtcGxhdGUpLCRhbmNob3JEaW1zPUZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksZGlyZWN0aW9uPXBvc2l0aW9uPT09J2xlZnQnPydsZWZ0Jzpwb3NpdGlvbj09PSdyaWdodCc/J2xlZnQnOid0b3AnLHBhcmFtPWRpcmVjdGlvbj09PSd0b3AnPydoZWlnaHQnOid3aWR0aCcsb2Zmc2V0PXBhcmFtPT09J2hlaWdodCc/dGhpcy5vcHRpb25zLnZPZmZzZXQ6dGhpcy5vcHRpb25zLmhPZmZzZXQsX3RoaXM9dGhpcztpZigkdGlwRGltcy53aWR0aD49JHRpcERpbXMud2luZG93RGltcy53aWR0aHx8IXRoaXMuY291bnRlciYmIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpe3RoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSx0aGlzLiRlbGVtZW50LCdjZW50ZXIgYm90dG9tJyx0aGlzLm9wdGlvbnMudk9mZnNldCx0aGlzLm9wdGlvbnMuaE9mZnNldCx0cnVlKSkuY3NzKHsvLyB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xuJ3dpZHRoJzokYW5jaG9yRGltcy53aW5kb3dEaW1zLndpZHRoLXRoaXMub3B0aW9ucy5oT2Zmc2V0KjIsJ2hlaWdodCc6J2F1dG8nfSk7cmV0dXJuIGZhbHNlO310aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsdGhpcy4kZWxlbWVudCwnY2VudGVyICcrKHBvc2l0aW9ufHwnYm90dG9tJyksdGhpcy5vcHRpb25zLnZPZmZzZXQsdGhpcy5vcHRpb25zLmhPZmZzZXQpKTt3aGlsZSghRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLnRlbXBsYXRlKSYmdGhpcy5jb3VudGVyKXt0aGlzLl9yZXBvc2l0aW9uKHBvc2l0aW9uKTt0aGlzLl9zZXRQb3NpdGlvbigpO319LyoqXG4gICAgICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcbiAgICAgICAqIEBmaXJlcyBUb29sdGlwI2Nsb3NlbWVcbiAgICAgICAqIEBmaXJlcyBUb29sdGlwI3Nob3dcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5OidzaG93Jyx2YWx1ZTpmdW5jdGlvbiBzaG93KCl7aWYodGhpcy5vcHRpb25zLnNob3dPbiE9PSdhbGwnJiYhRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnNob3dPbikpey8vIGNvbnNvbGUuZXJyb3IoJ1RoZSBzY3JlZW4gaXMgdG9vIHNtYWxsIHRvIGRpc3BsYXkgdGhpcyB0b29sdGlwJyk7XG5yZXR1cm4gZmFsc2U7fXZhciBfdGhpcz10aGlzO3RoaXMudGVtcGxhdGUuY3NzKCd2aXNpYmlsaXR5JywnaGlkZGVuJykuc2hvdygpO3RoaXMuX3NldFBvc2l0aW9uKCk7LyoqXG4gICAgICAgICAqIEZpcmVzIHRvIGNsb3NlIGFsbCBvdGhlciBvcGVuIHRvb2x0aXBzIG9uIHRoZSBwYWdlXG4gICAgICAgICAqIEBldmVudCBDbG9zZW1lI3Rvb2x0aXBcbiAgICAgICAgICovdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnRvb2x0aXAnLHRoaXMudGVtcGxhdGUuYXR0cignaWQnKSk7dGhpcy50ZW1wbGF0ZS5hdHRyKHsnZGF0YS1pcy1hY3RpdmUnOnRydWUsJ2FyaWEtaGlkZGVuJzpmYWxzZX0pO190aGlzLmlzQWN0aXZlPXRydWU7Ly8gY29uc29sZS5sb2codGhpcy50ZW1wbGF0ZSk7XG50aGlzLnRlbXBsYXRlLnN0b3AoKS5oaWRlKCkuY3NzKCd2aXNpYmlsaXR5JywnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbixmdW5jdGlvbigpey8vbWF5YmUgZG8gc3R1ZmY/XG59KTsvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93blxuICAgICAgICAgKiBAZXZlbnQgVG9vbHRpcCNzaG93XG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi50b29sdGlwJyk7fS8qKlxuICAgICAgICogSGlkZXMgdGhlIGN1cnJlbnQgdG9vbHRpcCwgYW5kIHJlc2V0cyB0aGUgcG9zaXRpb25pbmcgY2xhc3MgaWYgaXQgd2FzIGNoYW5nZWQgZHVlIHRvIGNvbGxpc2lvblxuICAgICAgICogQGZpcmVzIFRvb2x0aXAjaGlkZVxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKi99LHtrZXk6J2hpZGUnLHZhbHVlOmZ1bmN0aW9uIGhpZGUoKXsvLyBjb25zb2xlLmxvZygnaGlkaW5nJywgdGhpcy4kZWxlbWVudC5kYXRhKCd5ZXRpLWJveCcpKTtcbnZhciBfdGhpcz10aGlzO3RoaXMudGVtcGxhdGUuc3RvcCgpLmF0dHIoeydhcmlhLWhpZGRlbic6dHJ1ZSwnZGF0YS1pcy1hY3RpdmUnOmZhbHNlfSkuZmFkZU91dCh0aGlzLm9wdGlvbnMuZmFkZU91dER1cmF0aW9uLGZ1bmN0aW9uKCl7X3RoaXMuaXNBY3RpdmU9ZmFsc2U7X3RoaXMuaXNDbGljaz1mYWxzZTtpZihfdGhpcy5jbGFzc0NoYW5nZWQpe190aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKF90aGlzLl9nZXRQb3NpdGlvbkNsYXNzKF90aGlzLnRlbXBsYXRlKSkuYWRkQ2xhc3MoX3RoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzKTtfdGhpcy51c2VkUG9zaXRpb25zPVtdO190aGlzLmNvdW50ZXI9NDtfdGhpcy5jbGFzc0NoYW5nZWQ9ZmFsc2U7fX0pOy8qKlxuICAgICAgICAgKiBmaXJlcyB3aGVuIHRoZSB0b29sdGlwIGlzIGhpZGRlblxuICAgICAgICAgKiBAZXZlbnQgVG9vbHRpcCNoaWRlXG4gICAgICAgICAqL3RoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi50b29sdGlwJyk7fS8qKlxuICAgICAgICogYWRkcyBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpdHMgYW5jaG9yXG4gICAgICAgKiBUT0RPIGNvbWJpbmUgc29tZSBvZiB0aGUgbGlzdGVuZXJzIGxpa2UgZm9jdXMgYW5kIG1vdXNlZW50ZXIsIGV0Yy5cbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi99LHtrZXk6J19ldmVudHMnLHZhbHVlOmZ1bmN0aW9uIF9ldmVudHMoKXt2YXIgX3RoaXM9dGhpczt2YXIgJHRlbXBsYXRlPXRoaXMudGVtcGxhdGU7dmFyIGlzRm9jdXM9ZmFsc2U7aWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpe3RoaXMuJGVsZW1lbnQub24oJ21vdXNlZW50ZXIuemYudG9vbHRpcCcsZnVuY3Rpb24oZSl7aWYoIV90aGlzLmlzQWN0aXZlKXtfdGhpcy50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtfdGhpcy5zaG93KCk7fSxfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO319KS5vbignbW91c2VsZWF2ZS56Zi50b29sdGlwJyxmdW5jdGlvbihlKXtjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7aWYoIWlzRm9jdXN8fF90aGlzLmlzQ2xpY2smJiFfdGhpcy5vcHRpb25zLmNsaWNrT3Blbil7X3RoaXMuaGlkZSgpO319KTt9aWYodGhpcy5vcHRpb25zLmNsaWNrT3Blbil7dGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7aWYoX3RoaXMuaXNDbGljayl7Ly9fdGhpcy5oaWRlKCk7XG4vLyBfdGhpcy5pc0NsaWNrID0gZmFsc2U7XG59ZWxzZXtfdGhpcy5pc0NsaWNrPXRydWU7aWYoKF90aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyfHwhX3RoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSkmJiFfdGhpcy5pc0FjdGl2ZSl7X3RoaXMuc2hvdygpO319fSk7fWVsc2V7dGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLGZ1bmN0aW9uKGUpe2Uuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7X3RoaXMuaXNDbGljaz10cnVlO30pO31pZighdGhpcy5vcHRpb25zLmRpc2FibGVGb3JUb3VjaCl7dGhpcy4kZWxlbWVudC5vbigndGFwLnpmLnRvb2x0aXAgdG91Y2hlbmQuemYudG9vbHRpcCcsZnVuY3Rpb24oZSl7X3RoaXMuaXNBY3RpdmU/X3RoaXMuaGlkZSgpOl90aGlzLnNob3coKTt9KTt9dGhpcy4kZWxlbWVudC5vbih7Ly8gJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcbi8vICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcbidjbG9zZS56Zi50cmlnZ2VyJzp0aGlzLmhpZGUuYmluZCh0aGlzKX0pO3RoaXMuJGVsZW1lbnQub24oJ2ZvY3VzLnpmLnRvb2x0aXAnLGZ1bmN0aW9uKGUpe2lzRm9jdXM9dHJ1ZTtpZihfdGhpcy5pc0NsaWNrKXsvLyBJZiB3ZSdyZSBub3Qgc2hvd2luZyBvcGVuIG9uIGNsaWNrcywgd2UgbmVlZCB0byBwcmV0ZW5kIGEgY2xpY2stbGF1bmNoZWQgZm9jdXMgaXNuJ3Rcbi8vIGEgcmVhbCBmb2N1cywgb3RoZXJ3aXNlIG9uIGhvdmVyIGFuZCBjb21lIGJhY2sgd2UgZ2V0IGJhZCBiZWhhdmlvclxuaWYoIV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKXtpc0ZvY3VzPWZhbHNlO31yZXR1cm4gZmFsc2U7fWVsc2V7X3RoaXMuc2hvdygpO319KS5vbignZm9jdXNvdXQuemYudG9vbHRpcCcsZnVuY3Rpb24oZSl7aXNGb2N1cz1mYWxzZTtfdGhpcy5pc0NsaWNrPWZhbHNlO190aGlzLmhpZGUoKTt9KS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsZnVuY3Rpb24oKXtpZihfdGhpcy5pc0FjdGl2ZSl7X3RoaXMuX3NldFBvc2l0aW9uKCk7fX0pO30vKipcbiAgICAgICAqIGFkZHMgYSB0b2dnbGUgbWV0aG9kLCBpbiBhZGRpdGlvbiB0byB0aGUgc3RhdGljIHNob3coKSAmIGhpZGUoKSBmdW5jdGlvbnNcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5Oid0b2dnbGUnLHZhbHVlOmZ1bmN0aW9uIHRvZ2dsZSgpe2lmKHRoaXMuaXNBY3RpdmUpe3RoaXMuaGlkZSgpO31lbHNle3RoaXMuc2hvdygpO319LyoqXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiB0b29sdGlwLCByZW1vdmVzIHRlbXBsYXRlIGVsZW1lbnQgZnJvbSB0aGUgdmlldy5cbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICovfSx7a2V5OidkZXN0cm95Jyx2YWx1ZTpmdW5jdGlvbiBkZXN0cm95KCl7dGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScsdGhpcy50ZW1wbGF0ZS50ZXh0KCkpLm9mZignLnpmLnRyaWdnZXIgLnpmLnRvb3RpcCcpLy8gIC5yZW1vdmVDbGFzcygnaGFzLXRpcCcpXG4ucmVtb3ZlQXR0cignYXJpYS1kZXNjcmliZWRieScpLnJlbW92ZUF0dHIoJ2RhdGEteWV0aS1ib3gnKS5yZW1vdmVBdHRyKCdkYXRhLXRvZ2dsZScpLnJlbW92ZUF0dHIoJ2RhdGEtcmVzaXplJyk7dGhpcy50ZW1wbGF0ZS5yZW1vdmUoKTtGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7fX1dKTtyZXR1cm4gVG9vbHRpcDt9KCk7VG9vbHRpcC5kZWZhdWx0cz17ZGlzYWJsZUZvclRvdWNoOmZhbHNlLC8qKlxuICAgICAqIFRpbWUsIGluIG1zLCBiZWZvcmUgYSB0b29sdGlwIHNob3VsZCBvcGVuIG9uIGhvdmVyLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAyMDBcbiAgICAgKi9ob3ZlckRlbGF5OjIwMCwvKipcbiAgICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxNTBcbiAgICAgKi9mYWRlSW5EdXJhdGlvbjoxNTAsLyoqXG4gICAgICogVGltZSwgaW4gbXMsIGEgdG9vbHRpcCBzaG91bGQgdGFrZSB0byBmYWRlIG91dCBvZiB2aWV3LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAxNTBcbiAgICAgKi9mYWRlT3V0RHVyYXRpb246MTUwLC8qKlxuICAgICAqIERpc2FibGVzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgdGhlIHRvb2x0aXAgaWYgc2V0IHRvIHRydWVcbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgZmFsc2VcbiAgICAgKi9kaXNhYmxlSG92ZXI6ZmFsc2UsLyoqXG4gICAgICogT3B0aW9uYWwgYWRkdGlvbmFsIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gaW5pdC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ215LWNvb2wtdGlwLWNsYXNzJ1xuICAgICAqL3RlbXBsYXRlQ2xhc3NlczonJywvKipcbiAgICAgKiBOb24tb3B0aW9uYWwgY2xhc3MgYWRkZWQgdG8gdG9vbHRpcCB0ZW1wbGF0ZXMuIEZvdW5kYXRpb24gZGVmYXVsdCBpcyAndG9vbHRpcCcuXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICd0b29sdGlwJ1xuICAgICAqL3Rvb2x0aXBDbGFzczondG9vbHRpcCcsLyoqXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgdG9vbHRpcCBhbmNob3IgZWxlbWVudC5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ2hhcy10aXAnXG4gICAgICovdHJpZ2dlckNsYXNzOidoYXMtdGlwJywvKipcbiAgICAgKiBNaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSBhdCB3aGljaCB0byBvcGVuIHRoZSB0b29sdGlwLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnc21hbGwnXG4gICAgICovc2hvd09uOidzbWFsbCcsLyoqXG4gICAgICogQ3VzdG9tIHRlbXBsYXRlIHRvIGJlIHVzZWQgdG8gZ2VuZXJhdGUgbWFya3VwIGZvciB0b29sdGlwLlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSAnJmx0O2RpdiBjbGFzcz1cInRvb2x0aXBcIiZndDsmbHQ7L2RpdiZndDsnXG4gICAgICovdGVtcGxhdGU6JycsLyoqXG4gICAgICogVGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gb3Blbi5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgJ1NvbWUgY29vbCBzcGFjZSBmYWN0IGhlcmUuJ1xuICAgICAqL3RpcFRleHQ6JycsdG91Y2hDbG9zZVRleHQ6J1RhcCB0byBjbG9zZS4nLC8qKlxuICAgICAqIEFsbG93cyB0aGUgdG9vbHRpcCB0byByZW1haW4gb3BlbiBpZiB0cmlnZ2VyZWQgd2l0aCBhIGNsaWNrIG9yIHRvdWNoIGV2ZW50LlxuICAgICAqIEBvcHRpb25cbiAgICAgKiBAZXhhbXBsZSB0cnVlXG4gICAgICovY2xpY2tPcGVuOnRydWUsLyoqXG4gICAgICogQWRkaXRpb25hbCBwb3NpdGlvbmluZyBjbGFzc2VzLCBzZXQgYnkgdGhlIEpTXG4gICAgICogQG9wdGlvblxuICAgICAqIEBleGFtcGxlICd0b3AnXG4gICAgICovcG9zaXRpb25DbGFzczonJywvKipcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgdGVtcGxhdGUgc2hvdWxkIHB1c2ggYXdheSBmcm9tIHRoZSBhbmNob3Igb24gdGhlIFkgYXhpcy5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMTBcbiAgICAgKi92T2Zmc2V0OjEwLC8qKlxuICAgICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgcHVzaCBhd2F5IGZyb20gdGhlIGFuY2hvciBvbiB0aGUgWCBheGlzLCBpZiBhbGlnbmVkIHRvIGEgc2lkZS5cbiAgICAgKiBAb3B0aW9uXG4gICAgICogQGV4YW1wbGUgMTJcbiAgICAgKi9oT2Zmc2V0OjEyfTsvKipcbiAgICogVE9ETyB1dGlsaXplIHJlc2l6ZSBldmVudCB0cmlnZ2VyXG4gICAqLy8vIFdpbmRvdyBleHBvcnRzXG5Gb3VuZGF0aW9uLnBsdWdpbihUb29sdGlwLCdUb29sdGlwJyk7fShqUXVlcnkpO1xuXG4vLyBJbXBvcnQgZm91bmRhdGlvbiBmcm9tIGJvd2VyXG4vLyBleHBvcnQgYXMgZnVuY3Rpb25cbnZhciBmb3VuZGF0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQvLyBpbml0YWxpemUgZm91bmRhdGlvblxuXHRqUXVlcnkoZG9jdW1lbnQpLmZvdW5kYXRpb24oKTtcblxuXHQvLyBub3RpZnkgY3NzIHRoYXQgZm91bmRhdGlvbiBqYXZhc2NyaXB0IGlzIHVwIGFuZCBydW5uaW5nXG5cdGpRdWVyeSgnYm9keScpLmFkZENsYXNzKCdmb3VuZGF0aW9uLXJlYWR5Jyk7XG59XG5cbnZhciBOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKCkge1xuXHRmdW5jdGlvbiBOYXZpZ2F0aW9uKGJvZHkpIHtcblx0XHRjbGFzc0NhbGxDaGVjayh0aGlzLCBOYXZpZ2F0aW9uKTtcblxuXHRcdHRoaXMuJGJvZHkgPSBib2R5O1xuXHRcdHRoaXMuJGNvbnRlbnQgPSB0aGlzLiRib2R5LmZpbmQoJ2Rpdltyb2xlPVwiZG9jdW1lbnRcIl0nKTtcblx0XHR0aGlzLiR0cmlnZ2VyID0gdGhpcy4kYm9keS5maW5kKCdbZGF0YS1uYXZpZ2F0aW9uLXRyaWdnZXJdJyk7XG5cdFx0dGhpcy4kaW5uZXIgPSB0aGlzLiRib2R5LmZpbmQoJ1tkYXRhLW5hdmlnYXRpb24tY29udGFpbmVyXScpO1xuXHRcdHRoaXMuYm9keUFjdGl2ZUNsYXNzID0gJ25hdi1vcGVuJztcblx0XHR0aGlzLmFuaW1hdGlvbkRlbGF5ID0gJzUwMCc7XG5cdFx0dGhpcy5fYmluZEV2ZW50cygpO1xuXHR9XG5cblx0Ly8gUHJpdmF0ZSBNZXRob2RzXG5cblxuXHRjcmVhdGVDbGFzcyhOYXZpZ2F0aW9uLCBbe1xuXHRcdGtleTogJ19iaW5kRXZlbnRzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLiR0cmlnZ2VyLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0X3RoaXMudG9nZ2xlKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy4kaW5uZXIuZmluZCgnbGkgYScpLmxhc3QoKS5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmICghZS5zaGlmdEtleSkge1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRfdGhpcy5jbG9zZSgpO1xuXHRcdFx0XHRcdF90aGlzLiRjb250ZW50LmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLiRpbm5lci5maW5kKCdsaSBhJykuZmlyc3QoKS5vbignZm9jdXMnLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRpZiAoIWUuc2hpZnRLZXkpIHtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0X3RoaXMub3BlbigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfaGFzQm9keUNsYXNzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2hhc0JvZHlDbGFzcygpIHtcblx0XHRcdHJldHVybiB0aGlzLiRib2R5Lmhhc0NsYXNzKHRoaXMuYm9keUFjdGl2ZUNsYXNzKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdfYWRkQm9keUNsYXNzJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gX2FkZEJvZHlDbGFzcygpIHtcblx0XHRcdGlmICghdGhpcy5faGFzQm9keUNsYXNzKCkpIHRoaXMuJGJvZHkuYWRkQ2xhc3ModGhpcy5ib2R5QWN0aXZlQ2xhc3MpO1xuXHRcdFx0dGhpcy4kYm9keS50cmlnZ2VyKCduYXZpZ2F0aW9uLmNsYXNzLmFkZGVkJyk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnX3JlbW92ZUJvZHlDbGFzcycsXG5cdFx0dmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVCb2R5Q2xhc3MoKSB7XG5cdFx0XHRpZiAodGhpcy5faGFzQm9keUNsYXNzKCkpIHRoaXMuJGJvZHkucmVtb3ZlQ2xhc3ModGhpcy5ib2R5QWN0aXZlQ2xhc3MpO1xuXHRcdFx0dGhpcy4kYm9keS50cmlnZ2VyKCduYXZpZ2F0aW9uLmNsYXNzLnJlbW92ZWQnKTtcblx0XHR9XG5cblx0XHQvLyBQdWJsaWMgTWV0aG9kc1xuXG5cdH0sIHtcblx0XHRrZXk6ICd0b2dnbGUnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2hhc0JvZHlDbGFzcygpKSB0aGlzLm9wZW4oKTtlbHNlIHRoaXMuY2xvc2UoKTtcblx0XHR9XG5cdH0sIHtcblx0XHRrZXk6ICdvcGVuJyxcblx0XHR2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcblx0XHRcdHZhciBfdGhpczIgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLl9hZGRCb2R5Q2xhc3MoKTtcblx0XHRcdHRoaXMuJHRyaWdnZXIuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzMi4kYm9keS50cmlnZ2VyKCduYXZpZ2F0aW9uLm9wZW5lZCcpO1xuXHRcdFx0fSwgdGhpcy5hbmltYXRpb25EZWxheSk7XG5cdFx0fVxuXHR9LCB7XG5cdFx0a2V5OiAnY2xvc2UnLFxuXHRcdHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcblx0XHRcdHZhciBfdGhpczMgPSB0aGlzO1xuXG5cdFx0XHR0aGlzLl9yZW1vdmVCb2R5Q2xhc3MoKTtcblx0XHRcdHRoaXMuJHRyaWdnZXIucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpO1xuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdF90aGlzMy4kYm9keS50cmlnZ2VyKCduYXZpZ2F0aW9uLmNsb3NlZCcpO1xuXHRcdFx0fSwgdGhpcy5hbmltYXRpb25EZWxheSk7XG5cdFx0fVxuXG5cdFx0Ly8gbWV0aG9kc1xuXG5cdH1dKTtcblx0cmV0dXJuIE5hdmlnYXRpb247XG59KCk7XG5cbnZhciBjb21tb24gPSBmdW5jdGlvbiAoKSB7XG5cdC8vIEJpbmQgdGhlIG5hdmlnYXRpb25cblx0bmV3IE5hdmlnYXRpb24oalF1ZXJ5KCdib2R5JykpO1xufVxuXG52YXIgcGFnZSA9IGZ1bmN0aW9uICgpIHt9XG5cbnZhciBzaW5nbGUgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBFeHBvcnQgcm91dGUgZnVuY3Rpb25zXG5cblxudmFyIHJvdXRlcyA9IE9iamVjdC5mcmVlemUoe1xuXHRjb21tb246IGNvbW1vbixcblx0cGFnZTogcGFnZSxcblx0c2luZ2xlOiBzaW5nbGVcbn0pO1xuXG4vLyBMb2FkIGRlcGVuZGVuY2llc1xuLy8gTG9hZCBtb2R1bGVzXG5qUXVlcnkoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uICgpIHtcblxuXHQvLyBMZXQgQ1NTIGtub3cgdGhhdCB3ZSdyZSByZWFkeVxuXHRqUXVlcnkoJ2JvZHknKS5hZGRDbGFzcygndGhlbWUtcmVhZHknKTtcblxuXHQvLyBMb2FkIHJvdXRlclxuXHRuZXcgalF1ZXJ5LkRPTVJvdXRlci5yb3V0ZXIoZG9jdW1lbnQsIHJvdXRlcyk7XG5cblx0Ly8gSW5pdGlhbGl6ZSBGb3VuZGF0aW9uXG5cdGZvdW5kYXRpb24oKTtcbn0pO1xuIl0sImZpbGUiOiJhcHAuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
