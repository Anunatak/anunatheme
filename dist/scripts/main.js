(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var DomRouter, routes;

  DomRouter = require("./../../bower_components/jquery-dom-router/src/jquery.dom-router.js");

  routes = require('./plugins/routes');

  new DomRouter(document, routes);

}).call(this);


},{"./../../bower_components/jquery-dom-router/src/jquery.dom-router.js":6,"./plugins/routes":4}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Ajax, jQ;

  jQ = jQuery;


  /**
   * Ajax Request Class
   */

  Ajax = (function() {

    /**
    	 * Create a new Ajax handler
    	 * @param  {String} @action   The action to listen for
    	 * @param  {Function} @callback The function to run when success
    	 * @param  {Object} @data     Data to pass to the action
    	 * @param  {String} @method   Method to use for the request
    	 * @return {Void}
     */
    function Ajax(action, callback, data1, method) {
      this.action = action;
      this.callback = callback;
      this.data = data1;
      this.method = method;
      this.setup();
    }


    /**
    	 * Set up the ajax request
     */

    Ajax.prototype.setup = function() {
      var data;
      data = this.data || {};
      data = jQ.extend(data, {
        action: this.action
      });
      return jQ.ajax({
        url: App.ajax,
        type: this.method || 'GET',
        data: data,
        success: this.callback,
        error: function(err) {
          return console.log(err);
        }
      });
    };

    return Ajax;

  })();


  /**
   * Export the class a module
   * @type {Object}
   */

  module.exports = Ajax;

}).call(this);


},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var jQ;

  jQ = jQuery;

  module.exports = {
    $body: jQ('body'),
    $content: jQ('div[role="document"]'),
    $trigger: jQ('[data-navigation-trigger]'),
    $inner: jQ('[data-navigation-container]'),
    bodyActiveClass: 'nav-open',
    toggle: function() {
      if (!this._hasBodyClass()) {
        return this.open();
      } else {
        return this.close();
      }
    },
    open: function() {
      this._addBodyClass();
      return this.$body.trigger('navigation.opened');
    },
    close: function() {
      this._removeBodyClass();
      return this.$body.trigger('navigation.closed');
    },
    _hasBodyClass: function() {
      return this.$body.hasClass(this.bodyActiveClass);
    },
    _addBodyClass: function() {
      if (!this._hasBodyClass()) {
        this.$body.addClass(this.bodyActiveClass);
      }
      return this.$body.trigger('navigation.class.added');
    },
    _removeBodyClass: function() {
      if (this._hasBodyClass()) {
        this.$body.removeClass(this.bodyActiveClass);
      }
      return this.$body.trigger('navigation.class.removed');
    },
    bind: function() {
      var self;
      self = this;
      self.$trigger.on('click', function() {
        return self.toggle();
      });
      self.$inner.find('li a').last().on('keydown', function(e) {
        if (!e.shiftKey) {
          e.preventDefault();
          self.close();
          return self.$content.find('a').first().focus();
        }
      });
      self.$inner.find('li a').first().on('focus', function(e) {
        if (!e.shiftKey) {
          e.preventDefault();
          return self.open();
        }
      });
      return self.$body.trigger('navigation.binded');
    }
  };

}).call(this);


},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Ajax, jQ, menu, snake;

  jQ = jQuery;

  menu = require('../plugins/navigation');

  snake = require('../plugins/snake');

  Ajax = require('../classes/Ajax');

  module.exports = {
    common: function() {
      return menu.bind();
    },
    home: function() {
      return new Ajax('my_cool_action', (function(response) {
        return console.log(response);
      }), {
        cool_parameter_from_request: 'You are cool!'
      });
    },
    page: function() {
      return console.log("Page");
    },
    error404: function() {
      return snake.bind();
    }
  };

}).call(this);


},{"../classes/Ajax":2,"../plugins/navigation":3,"../plugins/snake":5}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Modernizr, Snake, jQ;

  jQ = jQuery;

  Snake = require("./../../../bower_components/jquery-snake/dist/jquery.snake.js");

  Modernizr = require('browsernizr');

  module.exports = {
    bind: function() {
      var $canvas, $container, apple, canvas, game, score, snakeHead, snakeTail;
      $container = jQ('.snake-container');
      $canvas = $container.find('.snake-canvas');
      canvas = $canvas.get(0);
      apple = $container.find('.snake-color.apple').css('color');
      snakeHead = $container.find('.snake-color.snake-head').css('color');
      snakeTail = $container.find('.snake-color.snake-tail').css('color');
      score = $container.find('.snake-color.score').css('color');
      game = new Snake(canvas, {
        snakeHeadColor: snakeHead,
        snakeTailColor: snakeTail,
        appleColor: apple,
        scoreColor: score
      });
      if (Modernizr.touch) {
        $canvas.trigger('snake.enable.controls');
      }
      $canvas.on('snake.game.collide', function() {
        $container.find('.snake-crash').fadeIn();
        return $canvas.addClass('snake-crashed');
      });
      $canvas.on('snake.game.play', function(event, snake, gameOver) {
        $canvas.trigger('snake.reset');
        $canvas.removeClass('snake-crashed');
        return $canvas.addClass('snake-playing');
      });
      return jQ('.snake-play').on('click', function(e) {
        e.preventDefault();
        return $(this).parent().fadeOut(function() {
          canvas.focus();
          return $canvas.trigger('snake.play');
        });
      });
    }
  };

}).call(this);


},{"./../../../bower_components/jquery-snake/dist/jquery.snake.js":7,"browsernizr":8}],6:[function(require,module,exports){
;(function ( $ ) {

    if(!$.fn.watch && !$.fn.unwatch) {

    	/**
    	 * Watches an element for a change in a property
    	 * @param  {string}   id The property to watch
    	 * @param  {Function} fn The function to execute when something has changed
    	 */
	    $.fn.watch = function( id, fn ) {

		    return this.each(function(){

		        var self = this;

		        var oldVal = self[id];
		        $(self).data(
		            'watch_timer',
		            setInterval(function(){
		                if (self[id] !== oldVal) {
		                    fn.call(self, id, oldVal, self[id]);
		                    oldVal = self[id];
		                }
		            }, 100)
		        );

		    });
		};

		/**
		 * Unwatches an element
		 */
		$.fn.unwatch = function() {

		    return this.each(function(){
		        clearInterval( $(this).data('watch_timer') );
		    });

		};

	}

    if (!$.DOMRouter) {
        $.DOMRouter = {
        	router: function(el, routes) {
		        var base = this;
		        base.$el = $(el);
		        base.el = el;
		        base.$el.data( 'DOMRouter.router' , base );

		        base.element = base.$el.find($.DOMRouter.defaults.element);

		        base.element.addClass('dom-router-ready');

		        /**
		         * Initalize the functions
		         * @return {void}
		         */
		        base.init = function () {
		            base.routes = routes;
		            $(document).ready(base.load);

		            base.executed = [];

		            base.element.watch('className', function(property, oldClasses, newClasses) {
		            	var classes = newClasses.replace(/-/g, '_').split(/\s+/);

		            	$.each(classes, function(i, className) {
		            		if(!base.routeExecuted(className)) {
		            			base.fire(className);
            					base.executed.push(className);
		            		}
		            	});
		            });
		        };

		        /**
		         * Checks if a route has been executed already
		         * @param  {string} 	route        [description]
		         * @return {boolean}
		         */
		        base.routeExecuted = function(route) {
		        	return base.executed.indexOf(route) > -1;
		        };

		        /**
		         * Gets the classes on the body element
		         * @return {array}
		         */
		        base.classes = function() {
		        	return base.element.get(0).className.replace(/-/g, '_').split(/\s+/);
		        };

		        /**
		         * Load all events to be fired
		         * @return {void}
		         */
	        	base.load = function() {
	        		base.fire('common');
	        		$.each(base.classes(), function(i, className) {
	        			base.fire(className);
            			base.executed.push(className);
	        		});
	        	};

	        	/**
	        	 * Fire an event
	        	 * @param  {Function} func The function to be fired
	        	 * @param  {Array} args Arguments
	        	 * @return {Void}
	        	 */
	        	base.fire = function(func, args) {
	        		var fire,
	        			routes = base.routes;

	        		fire = func !== '';
	        		fire = fire && routes[func];
      				fire = fire && typeof routes[func] === 'function';

      				if(fire) {
	      				routes[func](args);
	      			}
	        	};

		        // Run initializer
		        base.init();

        	},
        	defaults: {
        		element: 'body'
        	}
        };
    }

    $.fn.router = function( routes ) {
        return this.each(function () {
            (new $.DOMRouter.router(this, routes));
        });
    };

    if(typeof module !== 'undefined' && module.exports) {
		module.exports = $.DOMRouter.router;
	}

})( jQuery );

},{}],7:[function(require,module,exports){
/*
 *  jquery-snake - v3.6.0
 *  A jQuery plugin for the Snake game.
 *  http://jqueryboilerplate.com
 *
 *  Made by Tor Morten Jensen
 *  Under MIT License
 */
const BLOCK_SIZE = 10;

var Direction = {
	LEFT: 0,
	RIGHT: 1,
	UP: 2,
	DOWN: 3
};

function Point(x, y) {
	this.x = x;
	this.y = y;
}

function Controls(canvas) {
	const SIZE = 50;
	const GAP = 5;

	var left, right, up, down;

	var listener = null;

	this.updateLocation = function() {
		left  = new Point(canvas.width - SIZE * 3 - GAP * 3,
											canvas.height - SIZE - GAP);
		down  = new Point(canvas.width - SIZE * 2 - GAP * 2,
											canvas.height - SIZE - GAP);
		right = new Point(canvas.width - SIZE - GAP,
											canvas.height - SIZE - GAP);
		up    = new Point(canvas.width - SIZE * 2 - GAP * 2,
											canvas.height - SIZE * 2 - GAP * 2);
	};
	this.updateLocation();

	this.register = function(newListener) {
		listener = newListener;
	};

	this.listen = function() {
		$(canvas).on('touchstart', checkForTouch);
		$(canvas).on('click', checkForClick);
	};

	var touched = false;
	function checkForTouch(e) {
		touched = true;

		var eventX = e.touches[0].pageX - canvas.offsetLeft;
		var eventY = e.touches[0].pageY - canvas.offsetTop;

		checkForCollision(eventX, eventY);
	}

	function checkForClick(e) {
		console.log(canvas);
		if (touched) { return; }

		var eventX = e.pageX - canvas.offsetLeft;
		var eventY = e.pageY - canvas.offsetTop;

		return checkForCollision(eventX, eventY);
	}

	function checkForCollision(eventX, eventY) {
		if (collidesWithLeft(eventX, eventY)) {
			listener.turnLeft();
		} else if (collidesWithRight(eventX, eventY)) {
			listener.turnRight();
		} else if (collidesWithUp(eventX, eventY)) {
			listener.turnUp();
		} else if (collidesWithDown(eventX, eventY)) {
			listener.turnDown();
		}
	}

	function collidesWithLeft(x, y) {
		return collidesWithControl(left, x, y);
	}

	function collidesWithRight(x, y) {
		return collidesWithControl(right, x, y);
	}

	function collidesWithUp(x, y) {
		return collidesWithControl(up, x, y);
	}

	function collidesWithDown(x, y) {
		return collidesWithControl(down, x, y);
	}

	function collidesWithControl(control, x, y) {
		var xCollides = control.x <= x && x <= control.x + SIZE;
		var yCollides = control.y <= y && y <= control.y + SIZE;
		return xCollides && yCollides;
	}

	this.draw = function(context) {
		context.fillStyle = 'rgba(0, 0, 0, 0.1)';

		context.fillRect(left.x, left.y, SIZE, SIZE);
		context.fillRect(right.x, right.y, SIZE, SIZE);
		context.fillRect(up.x, up.y, SIZE, SIZE);
		context.fillRect(down.x, down.y, SIZE, SIZE);
	};
}

function ResetButton(canvas, game) {
	this.x = 10;
	this.y = canvas.height - 50;
	this.width = 100;
	this.height = 40;

	var btn = this;

	this.updateLocation = function() {
		this.y = canvas.height - 50;
	};

	this.listen = function() {
		$(canvas).on('click', checkForClick);
	};

	function checkForClick(e) {
		var eventX = e.pageX - canvas.offsetLeft;
		var eventY = e.pageY - canvas.offsetTop;

		var xCollides = btn.x <= eventX && eventX <= btn.x + btn.width;
		var yCollides = btn.y <= eventY && eventY <= btn.y + btn.height;

		if (xCollides && yCollides) {
			game.reset();
		}
	}

	this.draw = function(context) {

		// context.fillRect(this.x, this.y, this.width, this.height);

		// context.font = '16px sans-serif';
		// context.textAlign = 'center';
		// context.textBaseline = 'middle';
		// context.fillStyle = '#333';

		// var centerX = this.x + (this.width / 2);
		// var centerY = this.y + (this.height / 2);
		// context.fillText(options.labels.reset, centerX, centerY);
	};
}

function Score(canvas, options) {
	this.score = 0;

	this.reset = function() {
		this.score = 0;
	};

	this.increment = function() {
		this.score++;
	};

	this.draw = function(context) {
		context.font = 'bold 36px sans-serif';
		context.textAlign = 'left';
		context.textBaseline = 'top';
		context.fillStyle = options.scoreColor;
		context.fillText(options.labels.score + ': ' + this.score, 10, 10);
	};
}

function Snake(canvas, options) {
	this.points = [new Point(BLOCK_SIZE, BLOCK_SIZE)];
	this.direction = Direction.RIGHT;

	var snake = this;

	this.reset = function() {
		this.points = [new Point(50, 50)];
		this.direction = Direction.RIGHT;
	};

	this.headCollidesWithWall = function(canvas) {
		var head = this.points[0];
		var xCollides = 0 > head.x || head.x > canvas.width - BLOCK_SIZE;
		var yCollides = 0 > head.y || head.y > canvas.height - BLOCK_SIZE;
		return xCollides || yCollides;
	};

	this.headCollidesWithSelf = function() {
		var head = this.points[0];
		for (i = 1; i < this.points.length; i++) {
			if (head.x === this.points[i].x && head.y === this.points[i].y) {
				return true;
			}
		}

		return false;
	};

	this.headCollidesWithApple = function(apple){
		var head = this.points[0];
		return head.x === apple.x && head.y === apple.y;
	};

	this.turnLeft = function() {
		if (snake.points.length === 1 || snake.points[1].x === snake.points[0].x) {
			snake.direction = Direction.LEFT;
		}
	};

	this.turnRight = function() {
		if (snake.points.length === 1 || snake.points[1].x === snake.points[0].x) {
			snake.direction = Direction.RIGHT;
		}
	};

	this.turnUp = function() {
		if (snake.points.length === 1 || snake.points[1].y === snake.points[0].y) {
			snake.direction = Direction.UP;
		}
	};

	this.turnDown = function() {
		if (snake.points.length === 1 || snake.points[1].y === snake.points[0].y) {
			snake.direction = Direction.DOWN;
		}
	};

	var keyMap = {
		'37': this.turnLeft,
		'38': this.turnUp,
		'39': this.turnRight,
		'40': this.turnDown
	};

	this.listenForKeyPress = function(canvas) {
		$(document).on('keydown', $(canvas), function(e) {
			var code = e.keyCode;
			if (37 <= code && code <= 40) {
				e.preventDefault();
				keyMap[code]();
			}
		});
	};

	this.draw = function(context) {

		for (i = 0; i < this.points.length; i++) {
			if(i === 0) {
				context.fillStyle = options.snakeHeadColor;
			}
			else {
				context.fillStyle = options.snakeTailColor;
			}
			context.fillRect(this.points[i].x, this.points[i].y, BLOCK_SIZE, BLOCK_SIZE);
		}
	};
}

function Apple(canvas, options) {

	function generateX() {
		var x = Math.random() * (canvas.width - BLOCK_SIZE);
		return Math.round(x / BLOCK_SIZE) * BLOCK_SIZE;
	}

	function generateY() {
		var y = Math.random() * (canvas.height - BLOCK_SIZE);
		return Math.round(y / BLOCK_SIZE) * BLOCK_SIZE;
	}

	this.x = generateX();
	this.y = generateY();

	this.move = function() {
		this.x = generateX();
		this.y = generateY();
	};

	this.draw = function(context) {
		context.fillStyle = options.appleColor;
		context.fillRect(this.x, this.y, BLOCK_SIZE, BLOCK_SIZE);
	};
}

function SnakeGame(canvas, options) {
	var snake = new Snake(canvas, options);
	var apple = new Apple(canvas, options);
	var btnReset = new ResetButton(canvas, this);
	var score = new Score(canvas, options);
	var controls = null;

	var context = canvas.getContext('2d');

	var time = Date.now();
	var gameOver = false;

	var game = this;

	this.moveApple = function() {
		apple.move();
	};

	this.resize = function() {
		var appleOutsideX = apple.x > canvas.width - BLOCK_SIZE;
		var appleOutsideY = apple.y > canvas.height - BLOCK_SIZE;

		if (appleOutsideX || appleOutsideY) {
			apple.move();
		}

		btnReset.updateLocation();

		if (controls !== null) {
			controls.updateLocation();
		}
		jQuery(canvas).trigger('snake.game.resize', [game]);
		drawGame();
	};

	this.reset = function() {
		jQuery(canvas).trigger('snake.game.reset', [game]);
		gameOver = false;
		time = Date.now();

		snake.reset();
		apple.move();
		score.reset();
	};

	this.pause = function() {
		gameOver = true;
	};

	this.continue = function() {
		gameOver = false;
	};

	this.enableControls = function() {
		controls = new Controls(canvas);
		controls.register(snake);
		jQuery(canvas).trigger('snake.game.enable.controls', [game]);
	};

	this.play = function() {
		btnReset.listen();
		snake.listenForKeyPress(canvas);

		if (controls !== null) {
			controls.listen();
		}

		jQuery(canvas).trigger('snake.game.play', [game, gameOver]);

		// game loop
		function mainloop() {
			if (!gameOver) {
				updateGame();
				drawGame();
			}
		}

		// game loop timing
		if (window.requestAnimationFrame !== null) {
			var recursiveAnim = function() {
				mainloop();
				window.requestAnimationFrame(recursiveAnim);
			};

			window.requestAnimationFrame(recursiveAnim);
		} else {
			setInterval(mainloop, 1000.0 / 60);
		}
	};

	function updateGame() {
		var newTime = Date.now();

		if (newTime - time > 50) {
			time = newTime;

			if (snake.headCollidesWithApple(apple)) {
				var last = snake.points[snake.points.length-1];
				snake.points.push(new Point(last.x, last.y));

				score.increment();
				jQuery(canvas).trigger('snake.game.score.update', [score.score]);
				apple.move();
			}

			// update all but head of snake
			for (i = snake.points.length - 1; i > 0; i--) {
				snake.points[i].x = snake.points[i-1].x;
				snake.points[i].y = snake.points[i-1].y;
			}

			// update head
			if (snake.direction === Direction.LEFT) {
				snake.points[0].x -= BLOCK_SIZE;
			} else if (snake.direction === Direction.RIGHT) {
				snake.points[0].x += BLOCK_SIZE;
			} else if (snake.direction === Direction.UP) {
				snake.points[0].y -= BLOCK_SIZE;
			} else {
				snake.points[0].y += BLOCK_SIZE;
			}

			if (snake.headCollidesWithWall(canvas) || snake.headCollidesWithSelf()) {
				jQuery(canvas).trigger('snake.game.collide', [score.score]);
				gameOver = true;
			}
		}
	}

	function drawGame() {
		context.clearRect(0, 0, canvas.width, canvas.height);

		snake.draw(context);

		apple.draw(context);

		score.draw(context);

		btnReset.draw(context);

		if (controls !== null) {
			controls.draw(context);
		}
		jQuery(canvas).trigger('snake.game.ready', [game]);
	}
}


;(function ( $, window, document, undefined ) {

	'use strict';

		var pluginName = 'snake',
			defaults = {
				snakeHeadColor: 'rgb(0,0,0)',
				snakeTailColor: 'rgb(115,115,115)',
				appleColor: 'rgb(255,0,0)',
				scoreColor: 'rgb(200,200,200)',
				responsive: true,
				ratio: '16:9',
				labels: {
					score: 'Score',
					reset: 'Reset'
				}
			};

		function Plugin ( element, options ) {
			this.element = element;
			this.$element = $(element);
			this.settings = $.extend( {}, defaults, options );
			this._defaults = defaults;
			this._name = pluginName;
			this.init();
		}

		$.extend(Plugin.prototype, {
			init: function () {
				this.game = new SnakeGame(this.element, this.settings);

				if(this.settings.responsive) {
					this.resize();
					$(window).on('resize', this.resize);
				}

				this.listen();
			},
			listen: function() {
				var me = this;

				this.$element.on('snake.play', function() {
					me.game.play();
				});

				this.$element.on('snake.reset', function() {
					me.game.reset();
				});

				this.$element.on('snake.pause', function() {
					me.game.pause();
				});

				this.$element.on('snake.enable.controls', function() {
					me.game.enableControls();
				});

				this.$element.on('snake.continue', function() {
					me.game.continue();
				});

				this.$element.on('snake.resize', function() {
					me.game.resize();
				});

				this.$element.on('snake.move.apple', function() {
					me.game.moveApple();
				});

				$(window).focus(function() {
					me.game.continue();
				});

				$(window).blur(function() {
					me.game.pause();
				});

			},
			resize: function() {

				// get the aspect ratio
				var ratio = this.settings.ratio.split(':');
				// fetch the width of the parent element
				var width = this.$element.parent().width();

				// figure out what the height should be according to our aspect ratio
				var height = width*ratio[1]/ratio[0];

				// set these to whatever dimensions you want
				this.element.style.width = width + 'px'; // width same as parent
				this.element.style.height = height + 'px'; // height same as parent

				// these must be set for proper drawing
				this.element.width = width;
				this.element.height = height;

				this.game.resize();
			}
		});

		// A really lightweight plugin wrapper around the constructor,
		// preventing against multiple instantiations
		$.fn[ pluginName ] = function ( options ) {
			return this.each(function() {
				if ( !$.data( this, 'plugin_' + pluginName ) ) {
						$.data( this, 'plugin_' + pluginName, new Plugin( this, options ) );
				}
			});
		};

		if(typeof module !== 'undefined' && module.exports) {
			module.exports = Plugin;
		}

})( jQuery, window, document );

},{}],8:[function(require,module,exports){
var Modernizr = require('./lib/Modernizr'),
    ModernizrProto = require('./lib/ModernizrProto'),
    classes = require('./lib/classes'),
    testRunner = require('./lib/testRunner'),
    setClasses = require('./lib/setClasses');

// Run each test
testRunner();

// Remove the "no-js" class if it exists
setClasses(classes);

delete ModernizrProto.addTest;
delete ModernizrProto.addAsyncTest;

// Run the things that are supposed to run after the tests
for (var i = 0; i < Modernizr._q.length; i++) {
  Modernizr._q[i]();
}

module.exports = Modernizr;

},{"./lib/Modernizr":9,"./lib/ModernizrProto":10,"./lib/classes":11,"./lib/setClasses":15,"./lib/testRunner":16}],9:[function(require,module,exports){
var ModernizrProto = require('./ModernizrProto.js');
  // Fake some of Object.create so we can force non test results to be non "own" properties.
  var Modernizr = function() {};
  Modernizr.prototype = ModernizrProto;

  // Leak modernizr globally when you `require` it rather than force it here.
  // Overwrite name so constructor name is nicer :D
  Modernizr = new Modernizr();

  module.exports = Modernizr;


},{"./ModernizrProto.js":10}],10:[function(require,module,exports){
var tests = require('./tests.js');
  /**
   *
   * ModernizrProto is the constructor for Modernizr
   *
   * @class
   * @access public
   */

  var ModernizrProto = {
    // The current version, dummy
    _version: '3.2.0 (browsernizr 2.0.1)',

    // Any settings that don't work as separate modules
    // can go in here as configuration.
    _config: {
      'classPrefix' : '',
      'enableClasses' : true,
      'enableJSClass' : true,
      'usePrefixes' : true
    },

    // Queue of tests
    _q: [],

    // Stub these for people who are listening
    on: function(test, cb) {
      // I don't really think people should do this, but we can
      // safe guard it a bit.
      // -- NOTE:: this gets WAY overridden in src/addTest for actual async tests.
      // This is in case people listen to synchronous tests. I would leave it out,
      // but the code to *disallow* sync tests in the real version of this
      // function is actually larger than this.
      var self = this;
      setTimeout(function() {
        cb(self[test]);
      }, 0);
    },

    addTest: function(name, fn, options) {
      tests.push({name : name, fn : fn, options : options});
    },

    addAsyncTest: function(fn) {
      tests.push({name : null, fn : fn});
    }
  };

  module.exports = ModernizrProto;


},{"./tests.js":17}],11:[function(require,module,exports){

  var classes = [];
  module.exports = classes;


},{}],12:[function(require,module,exports){

  /**
   * docElement is a convenience wrapper to grab the root element of the document
   *
   * @access private
   * @returns {HTMLElement|SVGElement} The root element of the document
   */

  var docElement = document.documentElement;
  module.exports = docElement;


},{}],13:[function(require,module,exports){

  /**
   * is returns a boolean if the typeof an obj is exactly type.
   *
   * @access private
   * @function is
   * @param {*} obj - A thing we want to check the type of
   * @param {string} type - A string to compare the typeof against
   * @returns {boolean}
   */

  function is(obj, type) {
    return typeof obj === type;
  }
  module.exports = is;


},{}],14:[function(require,module,exports){
var docElement = require('./docElement.js');
  /**
   * A convenience helper to check if the document we are running in is an SVG document
   *
   * @access private
   * @returns {boolean}
   */

  var isSVG = docElement.nodeName.toLowerCase() === 'svg';
  module.exports = isSVG;


},{"./docElement.js":12}],15:[function(require,module,exports){
var Modernizr = require('./Modernizr.js');
var docElement = require('./docElement.js');
var isSVG = require('./isSVG.js');
  /**
   * setClasses takes an array of class names and adds them to the root element
   *
   * @access private
   * @function setClasses
   * @param {string[]} classes - Array of class names
   */

  // Pass in an and array of class names, e.g.:
  //  ['no-webp', 'borderradius', ...]
  function setClasses(classes) {
    var className = docElement.className;
    var classPrefix = Modernizr._config.classPrefix || '';

    if (isSVG) {
      className = className.baseVal;
    }

    // Change `no-js` to `js` (independently of the `enableClasses` option)
    // Handle classPrefix on this too
    if (Modernizr._config.enableJSClass) {
      var reJS = new RegExp('(^|\\s)' + classPrefix + 'no-js(\\s|$)');
      className = className.replace(reJS, '$1' + classPrefix + 'js$2');
    }

    if (Modernizr._config.enableClasses) {
      // Add the new classes
      className += ' ' + classPrefix + classes.join(' ' + classPrefix);
      isSVG ? docElement.className.baseVal = className : docElement.className = className;
    }

  }

  module.exports = setClasses;


},{"./Modernizr.js":9,"./docElement.js":12,"./isSVG.js":14}],16:[function(require,module,exports){
var tests = require('./tests.js');
var Modernizr = require('./Modernizr.js');
var classes = require('./classes.js');
var is = require('./is.js');
  /**
   * Run through all tests and detect their support in the current UA.
   *
   * @access private
   */

  function testRunner() {
    var featureNames;
    var feature;
    var aliasIdx;
    var result;
    var nameIdx;
    var featureName;
    var featureNameSplit;

    for (var featureIdx in tests) {
      if (tests.hasOwnProperty(featureIdx)) {
        featureNames = [];
        feature = tests[featureIdx];
        // run the test, throw the return value into the Modernizr,
        // then based on that boolean, define an appropriate className
        // and push it into an array of classes we'll join later.
        //
        // If there is no name, it's an 'async' test that is run,
        // but not directly added to the object. That should
        // be done with a post-run addTest call.
        if (feature.name) {
          featureNames.push(feature.name.toLowerCase());

          if (feature.options && feature.options.aliases && feature.options.aliases.length) {
            // Add all the aliases into the names list
            for (aliasIdx = 0; aliasIdx < feature.options.aliases.length; aliasIdx++) {
              featureNames.push(feature.options.aliases[aliasIdx].toLowerCase());
            }
          }
        }

        // Run the test, or use the raw value if it's not a function
        result = is(feature.fn, 'function') ? feature.fn() : feature.fn;


        // Set each of the names on the Modernizr object
        for (nameIdx = 0; nameIdx < featureNames.length; nameIdx++) {
          featureName = featureNames[nameIdx];
          // Support dot properties as sub tests. We don't do checking to make sure
          // that the implied parent tests have been added. You must call them in
          // order (either in the test, or make the parent test a dependency).
          //
          // Cap it to TWO to make the logic simple and because who needs that kind of subtesting
          // hashtag famous last words
          featureNameSplit = featureName.split('.');

          if (featureNameSplit.length === 1) {
            Modernizr[featureNameSplit[0]] = result;
          } else {
            // cast to a Boolean, if not one already
            /* jshint -W053 */
            if (Modernizr[featureNameSplit[0]] && !(Modernizr[featureNameSplit[0]] instanceof Boolean)) {
              Modernizr[featureNameSplit[0]] = new Boolean(Modernizr[featureNameSplit[0]]);
            }

            Modernizr[featureNameSplit[0]][featureNameSplit[1]] = result;
          }

          classes.push((result ? '' : 'no-') + featureNameSplit.join('-'));
        }
      }
    }
  }
  module.exports = testRunner;


},{"./Modernizr.js":9,"./classes.js":11,"./is.js":13,"./tests.js":17}],17:[function(require,module,exports){

  var tests = [];
  module.exports = tests;


},{}]},{},[1]);
